<?xml version="1.0"?>
<rss version="2.0">
<channel>
<title>Karl Arao's TiddlyWiki</title>
<link>http://karlarao.tiddlyspot.com</link>
<description></description>
<language>en</language>
<copyright>Copyright 2017 YourName</copyright>
<pubDate>Thu, 22 Jun 2017 19:11:25 GMT</pubDate>
<lastBuildDate>Thu, 22 Jun 2017 19:11:25 GMT</lastBuildDate>
<docs>http://blogs.law.harvard.edu/tech/rss</docs>
<generator>TiddlyWiki 2.5.0</generator>
<item>
<title>TiddlyWiki setup hacks</title>
<description>this is tiddlywiki version &lt;span&gt;2.5.0&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;div class=&quot;dcTOC&quot;&gt;&lt;a class=&quot;toggleButton&quot; title=&quot;show/collapse table of contents&quot; href=&quot;javascript:;&quot;&gt;/* Table of Contents */&lt;/a&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' TiddlyWiki Documentation', event)&quot;&gt; TiddlyWiki Documentation&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' HOWTO install a PLUGIN', event)&quot;&gt; HOWTO install a PLUGIN&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' Changes done on this Tiddly', event)&quot;&gt; Changes done on this Tiddly&lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@0) go to systemConfig and copy/paste all plugins code when migrating/creating a new tiddlywiki@@', event)&quot;&gt; @@0) go to systemConfig and copy/paste all plugins code when migrating/creating a new tiddlywiki@@&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@1) Look and Feel@@', event)&quot;&gt; @@1) Look and Feel@@&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@2) Hide the right hand side bar@@', event)&quot;&gt; @@2) Hide the right hand side bar@@&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@3) Tag Cloud@@', event)&quot;&gt; @@3) Tag Cloud@@&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@4) Check out the following to edit the look and feel@@', event)&quot;&gt; @@4) Check out the following to edit the look and feel@@&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@5) Install Table of Contents plugin@@ ', event)&quot;&gt; @@5) Install Table of Contents plugin@@ &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' @@6) Setup RSS@@ ', event)&quot;&gt; @@6) Setup RSS@@ &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' Some useful links on TiddlyWiki', event)&quot;&gt; Some useful links on TiddlyWiki&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' Some caveat on Linux/Windows and other browsers', event)&quot;&gt; Some caveat on Linux/Windows and other browsers&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; &lt;a tiddlylink=&quot;TiddlyWiki&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TiddlyWiki&quot; href=&quot;http://karlarao.tiddlyspot.com#TiddlyWiki&quot; class=&quot;externalLink null&quot;&gt;TiddlyWiki&lt;/a&gt; Documentation&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://db.tt/VhwdfmiJ&quot; href=&quot;http://db.tt/VhwdfmiJ&quot; class=&quot;externalLink&quot;&gt;http://db.tt/VhwdfmiJ&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; HOWTO install a PLUGIN&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.wikihow.com/Install-a-Tiddlywiki-Plugin&quot; href=&quot;http://www.wikihow.com/Install-a-Tiddlywiki-Plugin&quot; class=&quot;externalLink&quot;&gt;http://www.wikihow.com/Install-a-Tiddlywiki-Plugin&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://mnteractive.com/archive/how-to-install-a-tiddlywiki-plugin/&quot; href=&quot;http://mnteractive.com/archive/how-to-install-a-tiddlywiki-plugin/&quot; class=&quot;externalLink&quot;&gt;http://mnteractive.com/archive/how-to-install-a-tiddlywiki-plugin/&lt;/a&gt;  , copy source, save, reload, link to systemConfig&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Changes done on this Tiddly&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;0) go to systemConfig and copy/paste all plugins code when migrating/creating a new tiddlywiki&lt;/span&gt;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;1) Look and Feel&lt;/span&gt;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;go to Tags -&amp;gt; systemPalette -&amp;gt; &lt;a tiddlylink=&quot;MptwSmoke&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#MptwSmoke&quot; href=&quot;http://karlarao.tiddlyspot.com#MptwSmoke&quot; class=&quot;externalLink null&quot;&gt;MptwSmoke&lt;/a&gt; -&amp;gt; then add this line -&amp;gt; click Apply&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;Name: &lt;a tiddlylink=&quot;MptwSmoke&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#MptwSmoke&quot; href=&quot;http://karlarao.tiddlyspot.com#MptwSmoke&quot; class=&quot;externalLink null&quot;&gt;MptwSmoke&lt;/a&gt;&lt;br&gt;Background: #fff&lt;br&gt;Foreground: #000&lt;br&gt;&lt;a tiddlylink=&quot;PrimaryPale&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#PrimaryPale&quot; href=&quot;http://karlarao.tiddlyspot.com#PrimaryPale&quot; class=&quot;externalLink null&quot;&gt;PrimaryPale&lt;/a&gt;: #&lt;a tiddlylink=&quot;F5F5F5&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#F5F5F5&quot; href=&quot;http://karlarao.tiddlyspot.com#F5F5F5&quot; class=&quot;externalLink null&quot;&gt;F5F5F5&lt;/a&gt;&lt;br&gt;&lt;a tiddlylink=&quot;PrimaryLight&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#PrimaryLight&quot; href=&quot;http://karlarao.tiddlyspot.com#PrimaryLight&quot; class=&quot;externalLink null&quot;&gt;PrimaryLight&lt;/a&gt;: #228B22&lt;br&gt;&lt;a tiddlylink=&quot;PrimaryMid&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#PrimaryMid&quot; href=&quot;http://karlarao.tiddlyspot.com#PrimaryMid&quot; class=&quot;externalLink null&quot;&gt;PrimaryMid&lt;/a&gt;: #111&lt;br&gt;&lt;a tiddlylink=&quot;PrimaryDark&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#PrimaryDark&quot; href=&quot;http://karlarao.tiddlyspot.com#PrimaryDark&quot; class=&quot;externalLink null&quot;&gt;PrimaryDark&lt;/a&gt;: #000&lt;br&gt;&lt;a tiddlylink=&quot;SecondaryPale&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SecondaryPale&quot; href=&quot;http://karlarao.tiddlyspot.com#SecondaryPale&quot; class=&quot;externalLink null&quot;&gt;SecondaryPale&lt;/a&gt;: #ffc&lt;br&gt;&lt;a tiddlylink=&quot;SecondaryLight&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SecondaryLight&quot; href=&quot;http://karlarao.tiddlyspot.com#SecondaryLight&quot; class=&quot;externalLink null&quot;&gt;SecondaryLight&lt;/a&gt;: #fe8&lt;br&gt;&lt;a tiddlylink=&quot;SecondaryMid&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SecondaryMid&quot; href=&quot;http://karlarao.tiddlyspot.com#SecondaryMid&quot; class=&quot;externalLink null&quot;&gt;SecondaryMid&lt;/a&gt;: #db4&lt;br&gt;&lt;a tiddlylink=&quot;SecondaryDark&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SecondaryDark&quot; href=&quot;http://karlarao.tiddlyspot.com#SecondaryDark&quot; class=&quot;externalLink null&quot;&gt;SecondaryDark&lt;/a&gt;: #841&lt;br&gt;&lt;a tiddlylink=&quot;TertiaryPale&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TertiaryPale&quot; href=&quot;http://karlarao.tiddlyspot.com#TertiaryPale&quot; class=&quot;externalLink null&quot;&gt;TertiaryPale&lt;/a&gt;: #eee&lt;br&gt;&lt;a tiddlylink=&quot;TertiaryLight&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TertiaryLight&quot; href=&quot;http://karlarao.tiddlyspot.com#TertiaryLight&quot; class=&quot;externalLink null&quot;&gt;TertiaryLight&lt;/a&gt;: #ccc&lt;br&gt;&lt;a tiddlylink=&quot;TertiaryMid&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TertiaryMid&quot; href=&quot;http://karlarao.tiddlyspot.com#TertiaryMid&quot; class=&quot;externalLink null&quot;&gt;TertiaryMid&lt;/a&gt;: #999&lt;br&gt;&lt;a tiddlylink=&quot;TertiaryDark&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TertiaryDark&quot; href=&quot;http://karlarao.tiddlyspot.com#TertiaryDark&quot; class=&quot;externalLink null&quot;&gt;TertiaryDark&lt;/a&gt;: #666&lt;br&gt;Error: #f88&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;2) Hide the right hand side bar&lt;/span&gt;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlywiki.org/wiki/How_To/Setting_Up_TiddlyWiki_As_a_Website#Hide_right_side_bar&quot; href=&quot;http://tiddlywiki.org/wiki/How_To/Setting_Up_TiddlyWiki_As_a_Website#Hide_right_side_bar&quot; class=&quot;externalLink&quot;&gt;http://tiddlywiki.org/wiki/How_To/Setting_Up_TiddlyWiki_As_a_Website#Hide_right_side_bar&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlywiki.org/wiki/Import&quot; href=&quot;http://tiddlywiki.org/wiki/Import&quot; class=&quot;externalLink&quot;&gt;http://tiddlywiki.org/wiki/Import&lt;/a&gt;&lt;br&gt;&lt;br&gt;go to &lt;a tiddlylink=&quot;SiteTitle&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SiteTitle&quot; href=&quot;http://karlarao.tiddlyspot.com#SiteTitle&quot; class=&quot;externalLink null&quot;&gt;SiteTitle&lt;/a&gt; tiddler then put this&lt;br&gt;&lt;pre&gt;Karl Arao'&amp;lt;&amp;lt;tiddler ToggleRightSidebar with: &quot;s&quot;&amp;gt;&amp;gt; TiddlyWiki
&lt;/pre&gt;&lt;br&gt;go to &lt;a tiddlylink=&quot;SiteSubtitle&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SiteSubtitle&quot; href=&quot;http://karlarao.tiddlyspot.com#SiteSubtitle&quot; class=&quot;externalLink null&quot;&gt;SiteSubtitle&lt;/a&gt; for subtitle &lt;br&gt;&lt;pre&gt;has moved to -&amp;gt; http://KARLARAO.WIKI 
&lt;/pre&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;3) Tag Cloud&lt;/span&gt;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;Just add this line on a Tiddler... enclose it with &lt;span&gt;&amp;lt;&amp;lt; ... &amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;cloud tags action:popup systemConfig systemPalette systemServer systemTheme &lt;a tiddlylink=&quot;TaskPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TaskPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#TaskPackage&quot; class=&quot;externalLink null&quot;&gt;TaskPackage&lt;/a&gt; &lt;a tiddlylink=&quot;TiddlyWiki&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TiddlyWiki&quot; href=&quot;http://karlarao.tiddlyspot.com#TiddlyWiki&quot; class=&quot;externalLink null&quot;&gt;TiddlyWiki&lt;/a&gt; &lt;a tiddlylink=&quot;TidIDEPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TidIDEPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#TidIDEPackage&quot; class=&quot;externalLink null&quot;&gt;TidIDEPackage&lt;/a&gt; transclusion &lt;a tiddlylink=&quot;ScrollbarPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#ScrollbarPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#ScrollbarPackage&quot; class=&quot;externalLink null&quot;&gt;ScrollbarPackage&lt;/a&gt; &lt;a tiddlylink=&quot;NavigationPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#NavigationPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#NavigationPackage&quot; class=&quot;externalLink null&quot;&gt;NavigationPackage&lt;/a&gt; &lt;a tiddlylink=&quot;MediaPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#MediaPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#MediaPackage&quot; class=&quot;externalLink null&quot;&gt;MediaPackage&lt;/a&gt; &lt;a tiddlylink=&quot;IconPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#IconPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#IconPackage&quot; class=&quot;externalLink null&quot;&gt;IconPackage&lt;/a&gt; &lt;a tiddlylink=&quot;DiscoveryPackage&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#DiscoveryPackage&quot; href=&quot;http://karlarao.tiddlyspot.com#DiscoveryPackage&quot; class=&quot;externalLink null&quot;&gt;DiscoveryPackage&lt;/a&gt; bookmarklet&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;4) Check out the following to edit the look and feel&lt;/span&gt;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;a tiddlylink=&quot;DefaultTiddlers&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#DefaultTiddlers&quot; href=&quot;http://karlarao.tiddlyspot.com#DefaultTiddlers&quot; class=&quot;externalLink null&quot;&gt;DefaultTiddlers&lt;/a&gt;&lt;br&gt;&lt;a tiddlylink=&quot;MainMenu&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#MainMenu&quot; href=&quot;http://karlarao.tiddlyspot.com#MainMenu&quot; class=&quot;externalLink null&quot;&gt;MainMenu&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;pre&gt;the default tiddlers
[[RSS &amp;amp; Search]] [[TagCloud]]
&lt;/pre&gt;&lt;pre&gt;the current main menu
[[About]] [[RSS &amp;amp; Search]] [[TagCloud]] [[Oracle]] [[.MOSNotes]] [[OraclePerformance]] [[Benchmark]] [[Capacity Planning]] [[Hardware and OS]] [[EngineeredSystems]] [[Exadata]] [[HA]] [[PerformanceTools]] [[Troubleshooting &amp;amp; Internals]] [[SQL Tuning]] [[EnterpriseManager]] [[DataWarehouse]] [[Linux]] [[CloudComputing]] [[CodeNinja]] [[etc..]]
&lt;/pre&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;5) Install Table of Contents plugin&lt;/span&gt; &lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;see this &lt;a target=&quot;_blank&quot; title=&quot;External link to https://groups.google.com/forum/#!topic/tiddlywiki/96ollIZcJMk&quot; href=&quot;https://groups.google.com/forum/#%21topic/tiddlywiki/96ollIZcJMk&quot; class=&quot;externalLink&quot;&gt;https://groups.google.com/forum/#!topic/tiddlywiki/96ollIZcJMk&lt;/a&gt;, and this for the source &lt;a target=&quot;_blank&quot; title=&quot;External link to http://devpad.tiddlyspot.com/#DcTableOfContentsPlugin&quot; href=&quot;http://devpad.tiddlyspot.com/#DcTableOfContentsPlugin&quot; class=&quot;externalLink&quot;&gt;http://devpad.tiddlyspot.com/#DcTableOfContentsPlugin&lt;/a&gt;&lt;br&gt;just reference it with&lt;br&gt;&lt;pre&gt;&amp;lt;&amp;lt;showtoc&amp;gt;&amp;gt;
&lt;/pre&gt;note that you can only do 5 levels deep. A to E, or 1 - 5&lt;br&gt;&lt;br&gt;&lt;h2&gt; &lt;span class=&quot;marked&quot;&gt;6) Setup RSS&lt;/span&gt; &lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/1lh6ER7.png&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 40%; height: 40%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/C1t0hrJ.png&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 30%; height: 30%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/iDhAFsS.png&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 30%; height: 30%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/Im7SJKC.png&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 30%; height: 30%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Some useful links on &lt;a tiddlylink=&quot;TiddlyWiki&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#TiddlyWiki&quot; href=&quot;http://karlarao.tiddlyspot.com#TiddlyWiki&quot; class=&quot;externalLink null&quot;&gt;TiddlyWiki&lt;/a&gt;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://jaybyjayfresh.com/2008/01/23/tiddlytemplating-using-tiddlywiki-to-create-webpages/&quot; href=&quot;http://jaybyjayfresh.com/2008/01/23/tiddlytemplating-using-tiddlywiki-to-create-webpages/&quot; class=&quot;externalLink&quot;&gt;http://jaybyjayfresh.com/2008/01/23/tiddlytemplating-using-tiddlywiki-to-create-webpages/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://faq.tiddlyspot.com/&quot; href=&quot;http://faq.tiddlyspot.com/&quot; class=&quot;externalLink&quot;&gt;http://faq.tiddlyspot.com/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.alisonsinclair.ca/blog/archives/29&quot; href=&quot;http://www.alisonsinclair.ca/blog/archives/29&quot; class=&quot;externalLink&quot;&gt;http://www.alisonsinclair.ca/blog/archives/29&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://en.wikipedia.org/wiki/TiddlyWiki&quot; href=&quot;http://en.wikipedia.org/wiki/TiddlyWiki&quot; class=&quot;externalLink&quot;&gt;http://en.wikipedia.org/wiki/TiddlyWiki&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://en.wikipedia.org/wiki/Personal_wiki&quot; href=&quot;http://en.wikipedia.org/wiki/Personal_wiki&quot; class=&quot;externalLink&quot;&gt;http://en.wikipedia.org/wiki/Personal_wiki&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://en.wikipedia.org/wiki/Getting_Things_Done&quot; href=&quot;http://en.wikipedia.org/wiki/Getting_Things_Done&quot; class=&quot;externalLink&quot;&gt;http://en.wikipedia.org/wiki/Getting_Things_Done&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://en.wikipedia.org/wiki/Comparison_of_wiki_software#cite_note-33&quot; href=&quot;http://en.wikipedia.org/wiki/Comparison_of_wiki_software#cite_note-33&quot; class=&quot;externalLink&quot;&gt;http://en.wikipedia.org/wiki/Comparison_of_wiki_software#cite_note-33&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://en.wikipedia.org/wiki/List_of_wiki_software&quot; href=&quot;http://en.wikipedia.org/wiki/List_of_wiki_software&quot; class=&quot;externalLink&quot;&gt;http://en.wikipedia.org/wiki/List_of_wiki_software&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlywiki.org/wiki/TiddlyWiki_Resources&quot; href=&quot;http://tiddlywiki.org/wiki/TiddlyWiki_Resources&quot; class=&quot;externalLink&quot;&gt;http://tiddlywiki.org/wiki/TiddlyWiki_Resources&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.giffmex.org/twfortherestofus.html&quot; href=&quot;http://www.giffmex.org/twfortherestofus.html&quot; class=&quot;externalLink&quot;&gt;http://www.giffmex.org/twfortherestofus.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlythemes.com/#Home&quot; href=&quot;http://tiddlythemes.com/#Home&quot; class=&quot;externalLink&quot;&gt;http://tiddlythemes.com/#Home&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlyspot.blogspot.com/2007/09/tiddlythemes-images-now-work-on-your.html&quot; href=&quot;http://tiddlyspot.blogspot.com/2007/09/tiddlythemes-images-now-work-on-your.html&quot; class=&quot;externalLink&quot;&gt;http://tiddlyspot.blogspot.com/2007/09/tiddlythemes-images-now-work-on-your.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlywiki.org/wiki/How_To/Setting_Up_TiddlyWiki_As_a_Website&quot; href=&quot;http://tiddlywiki.org/wiki/How_To/Setting_Up_TiddlyWiki_As_a_Website&quot; class=&quot;externalLink&quot;&gt;http://tiddlywiki.org/wiki/How_To/Setting_Up_TiddlyWiki_As_a_Website&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://parand.com/say/index.php/2006/01/06/howto-using-tiddlywiki/&quot; href=&quot;http://parand.com/say/index.php/2006/01/06/howto-using-tiddlywiki/&quot; class=&quot;externalLink&quot;&gt;http://parand.com/say/index.php/2006/01/06/howto-using-tiddlywiki/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.youtube.com/watch?v=sgQqP1_lZG4&quot; href=&quot;http://www.youtube.com/watch?v=sgQqP1_lZG4&quot; class=&quot;externalLink&quot;&gt;http://www.youtube.com/watch?v=sgQqP1_lZG4&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Some caveat on Linux/Windows and other browsers&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;br&gt;&lt;u&gt;&lt;strong&gt;Linux&lt;/strong&gt;&lt;/u&gt;&lt;br&gt;&lt;br&gt;For Linux, your only option is Firefox.. that's it. Even with tiddlysaver.jar and chrome trick, doesn't seem to work. &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;u&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/u&gt;&lt;br&gt;&lt;br&gt;For Windows, you can stay with Firefox.. but for netbooks that seems to be slow. Good news is, the tiddlysaver.jar is working ;) so you can use Google Chrome! but the Chrome can't save updates on the tiddlyspot site.. so you can use Firefox for end-of-day saving to the karlarao.tiddlyspot.com&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlywiki.org/wiki/How_To/Configure_your_browser_to_allow_saves_to_disk&quot; href=&quot;http://tiddlywiki.org/wiki/How_To/Configure_your_browser_to_allow_saves_to_disk&quot; class=&quot;externalLink&quot;&gt;http://tiddlywiki.org/wiki/How_To/Configure_your_browser_to_allow_saves_to_disk&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://tiddlywiki.org/wiki/Google_Chrome&quot; href=&quot;http://tiddlywiki.org/wiki/Google_Chrome&quot; class=&quot;externalLink&quot;&gt;http://tiddlywiki.org/wiki/Google_Chrome&lt;/a&gt; &amp;lt;&lt;span&gt;—&lt;/span&gt; doesn't seem to work!&lt;br&gt;&lt;br&gt;BTW, I tried Opera, Safari, IE.. they are all crap.. &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>.TiddlyWiki</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BTiddlyWiki%20setup%20hacks%5D%5D</link>
<pubDate>Thu, 22 Jun 2017 19:08:04 GMT</pubDate>

</item>
<item>
<title>run_awr merge</title>
<description>&lt;div class=&quot;dcTOC&quot;&gt;&lt;a class=&quot;toggleButton&quot; title=&quot;show/collapse table of contents&quot; href=&quot;javascript:;&quot;&gt;/* Table of Contents */&lt;/a&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' the full details ', event)&quot;&gt; the full details &lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' create ext table script and loading of data', event)&quot;&gt; create ext table script and loading of data&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' test case of merge vs minus', event)&quot;&gt; test case of merge vs minus&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' summary of the process/what needs to be done', event)&quot;&gt; summary of the process/what needs to be done&lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' the data needs to be named &quot; cpuwl_all.csv&quot;',=&quot;&quot; event)&quot;=&quot;&quot;&gt; the data needs to be named &quot;cpuwl_all.csv&quot;&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' bash file to remove the trash character', event)&quot;&gt; bash file to remove the trash character&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' control file to &quot; generate&quot;=&quot;&quot; the=&quot;&quot; create=&quot;&quot; external=&quot;&quot; table=&quot;&quot; command',=&quot;&quot; event)&quot;=&quot;&quot;&gt; control file to &quot;generate&quot; the create external table command&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' create/load the external table and data', event)&quot;&gt; create/load the external table and data&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' the log file', event)&quot;&gt; the log file&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' the bad file', event)&quot;&gt; the bad file&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' merge SQL ', event)&quot;&gt; merge SQL &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; the full details &lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h2&gt; create ext table script and loading of data&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;h2&gt; test case of merge vs minus&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;check out this git commit &lt;a target=&quot;_blank&quot; title=&quot;External link to https://github.com/karlarao/code_ninja/commits?author=karlarao&amp;amp;since=2016-11-02T04:00:00Z&amp;amp;until=2016-11-03T04:00:00Z&quot; href=&quot;https://github.com/karlarao/code_ninja/commits?author=karlarao&amp;amp;since=2016-11-02T04:00:00Z&amp;amp;until=2016-11-03T04:00:00Z&quot; class=&quot;externalLink&quot;&gt;https://github.com/karlarao/code_ninja/commits?author=karlarao&amp;amp;since=2016-11-02T04:00:00Z&amp;amp;until=2016-11-03T04:00:00Z&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; summary of the process/what needs to be done&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;br&gt;&lt;h2&gt; the data needs to be named &quot;cpuwl_all.csv&quot;&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;blockquote&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall 11503554 Sep 22 18:46 20160922_awr_cpuwl-tableau-irislte4-example.com.csv&lt;br&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall 11457611 Sep 27 13:43 20160927_awr_cpuwl-tableau-irislte2-example.com.csv&lt;br&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall 11130983 Oct 25 20:54 cpuwl_all.csv&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h2&gt; bash file to remove the trash character&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;blockquote&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall       39 Oct 25 20:47 sed.sh&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h2&gt; control file to &quot;generate&quot; the create external table command&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;blockquote&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall     1014 Oct 25 19:16 cpuwl.ctl&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h2&gt; create/load the external table and data&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;creation of the external table only needs to be done once, you don't have to drop and recreate every loading of new data. you'll just have to update the file where the external table is pointed at &lt;br&gt;&lt;blockquote&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall     4631 Oct 25 20:41 load_cpuwl.sql&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h2&gt; the log file&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;blockquote&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall     8784 Nov  2 16:39 cpuwl_all.log_xt&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h2&gt; the bad file&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;blockquote&gt;-rw-r&lt;strike&gt;r&lt;/strike&gt;. 1 oracle oinstall       97 Nov  2 16:39 cpuwl_all.bad&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; merge SQL &lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;pre&gt;
 +-- merge to main
 +MERGE INTO awr_cpuwl s1
 +USING awr_cpuwl_ext s0 
 +  ON (
 +        s1.INSTNAME = s0.INSTNAME
 +    AND s1.DB_ID    = s0.DB_ID
 +    AND s1.HOSTNAME = s0.HOSTNAME
 +    AND s1.ID       = s0.ID
 +    AND s1.TM       = s0.TM
 +    AND s1.INST     = s0.INST
 +  )
 +WHEN MATCHED THEN
 +  UPDATE SET 
 +    s1.DUR        = s0.DUR       ,
 +    s1.CPU        = s0.CPU       ,
 +    s1.LOADAVG    = s0.LOADAVG   ,
 +    s1.AAS_CPU    = s0.AAS_CPU   ,
 +    s1.RSRCMGRPCT = s0.RSRCMGRPCT,
 +    s1.OSCPUPCT   = s0.OSCPUPCT  ,
 +    s1.OSCPUSYS   = s0.OSCPUSYS  ,
 +    s1.OSCPUIO    = s0.OSCPUIO   
 +WHEN NOT MATCHED THEN 
 +  INSERT VALUES (
 +    s0.INSTNAME  ,    
 +    s0.DB_ID     ,
 +    s0.HOSTNAME  ,
 +    s0.ID        ,
 +    s0.TM        ,
 +    s0.INST      ,
 +  	s0.DUR       ,
 +    s0.CPU       ,
 +    s0.LOADAVG   ,
 +    s0.AAS_CPU   ,
 +    s0.RSRCMGRPCT,
 +    s0.OSCPUPCT  ,
 +    s0.OSCPUSYS  ,
 +    s0.OSCPUIO  );
&lt;/pre&gt;&lt;br&gt;</description>
<category>ASH masters, AWR masters</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Brun_awr%20merge%5D%5D</link>
<pubDate>Thu, 22 Jun 2017 18:41:00 GMT</pubDate>

</item>
<item>
<title>panel view in edb360</title>
<description>use this  &lt;a target=&quot;_blank&quot; title=&quot;External link to https://addons.mozilla.org/en-US/firefox/addon/tile-tabs/&quot; href=&quot;https://addons.mozilla.org/en-US/firefox/addon/tile-tabs/&quot; class=&quot;externalLink&quot;&gt;https://addons.mozilla.org/en-US/firefox/addon/tile-tabs/&lt;/a&gt;  and select &quot;All Tabs - Vertical Grid&quot; 	&lt;br&gt;&lt;br&gt;&lt;div class=&quot;dcTOC&quot;&gt;&lt;a class=&quot;toggleButton&quot; title=&quot;show/collapse table of contents&quot; href=&quot;javascript:;&quot;&gt;/* Table of Contents */&lt;/a&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' From the super high level there's a workload spike on the week of 12th to 16th June', event)&quot;&gt; From the super high level there's a workload spike on the week of 12th to 16th June&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' That period is a CPU spike for the whole week', event)&quot;&gt; That period is a CPU spike for the whole week&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' Panel view of ASH by Wait Class by Instance ', event)&quot;&gt; Panel view of ASH by Wait Class by Instance &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' Panel view of time series SQL_ID by Instance  ', event)&quot;&gt; Panel view of time series SQL_ID by Instance  &lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; From the super high level there's a workload spike on the week of 12th to 16th June&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;img src=&quot;http://i.imgur.com/wafvNqi.jpg&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 90%; height: 90%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; That period is a CPU spike for the whole week&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;img src=&quot;http://i.imgur.com/d3zR7zG.jpg&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 90%; height: 90%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Panel view of ASH by Wait Class by Instance &lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;img src=&quot;http://i.imgur.com/q8TGNaT.jpg&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 90%; height: 90%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Panel view of time series &lt;a tiddlylink=&quot;SQL_ID&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SQL_ID&quot; href=&quot;http://karlarao.tiddlyspot.com#SQL_ID&quot; class=&quot;externalLink null&quot;&gt;SQL_ID&lt;/a&gt; by Instance  &lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;img src=&quot;http://i.imgur.com/Wu4CWYo.jpg&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 90%; height: 90%; cursor: move;&quot;&gt;</description>
<category>edb360</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bpanel%20view%20in%20edb360%5D%5D</link>
<pubDate>Thu, 22 Jun 2017 16:50:00 GMT</pubDate>

</item>
<item>
<title>RSS &amp; Search</title>
<description>&lt;span class=&quot;marked&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://feeds.feedburner.com/KarlAraoTiddlyWiki&quot; href=&quot;http://feeds.feedburner.com/KarlAraoTiddlyWiki&quot; class=&quot;externalLink&quot;&gt;http://feeds.feedburner.com/KarlAraoTiddlyWiki&lt;/a&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;marked&quot;&gt;&lt;u&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span tiddler=&quot;&quot; refresh=&quot;content&quot;&gt;&lt;/span&gt;&lt;span&gt;&lt;nowiki&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;hide right sidebar&quot; onmouseover=&quot;
	this.href='javascript:void(eval(decodeURIComponent(%22(function(){try{('
	+encodeURIComponent(encodeURIComponent(this.onclick))
	+')()}catch(e){alert(e.description?e.description:e.toString())}})()%22)))';&quot; onclick=&quot;
	var co=config.options;
	var opt='chkShowRightSidebar';
	var show=co[opt]=!co[opt];
	var sb=document.getElementById('sidebar');
	var da=document.getElementById('displayArea');
	if (sb) {
		sb.style.display=show?'block':'none';
		da.style.marginRight=show?'':'1em';
	}
	saveOptionCookie(opt);
	var labelShow=co.txtToggleRightSideBarLabelShow||'◄';
	var labelHide=co.txtToggleRightSideBarLabelHide||'►';
	if (this.innerHTML==labelShow||this.innerHTML==labelHide) 
		this.innerHTML=show?labelHide:labelShow;
	this.title=(show?'hide':'show')+' right sidebar';
	var sm=document.getElementById('storyMenu');
	if (sm) config.refreshers.content(sm);
	return false;
&quot;&gt;&amp;gt;SEARCH&amp;lt;&lt;/a&gt;&lt;/nowiki&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/u&gt;&lt;/span&gt; &lt;strong&gt;&amp;lt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt; click here to toggle on/off the search tab</description>
<link>http://karlarao.tiddlyspot.com#%5B%5BRSS%20%26%20Search%5D%5D</link>
<pubDate>Wed, 21 Jun 2017 23:15:00 GMT</pubDate>

</item>
<item>
<title>SiteSubtitle</title>
<description></description>
<link>http://karlarao.tiddlyspot.com#SiteSubtitle</link>
<pubDate>Wed, 21 Jun 2017 23:15:00 GMT</pubDate>

</item>
<item>
<title>UploadLog</title>
<description>&lt;table class=&quot;twtable&quot;&gt;&lt;tbody&gt;&lt;tr class=&quot;evenRow&quot;&gt;&lt;th align=&quot;center&quot;&gt;date&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;user&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;location&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;storeUrl&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;uploadDir&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;toFilename&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;backupdir&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;origin&lt;/th&gt;&lt;/tr&gt;&lt;tr class=&quot;oddRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;24/11/2014 13:48:33&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;evenRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;06/02/2015 08:52:59&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;oddRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;12/07/2015 23:28:58&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;evenRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;16/10/2015 12:38:58&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;oddRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;27/04/2016 12:41:15&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;evenRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;27/04/2016 12:50:08&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;oddRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;03/07/2016 00:28:04&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;evenRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;15/09/2016 01:18:38&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///Users/karl/Dropbox/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;oddRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;21/06/2017 18:43:56&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///H:/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///H:/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;evenRow&quot;&gt;&lt;td align=&quot;center&quot;&gt;21/06/2017 19:10:39&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a tiddlylink=&quot;KarlArao&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#KarlArao&quot; href=&quot;http://karlarao.tiddlyspot.com#KarlArao&quot; class=&quot;externalLink null&quot;&gt;KarlArao&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to file:///H:/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; href=&quot;file:///H:/Documents/KnowledgeFiles/InformationTechnology/TiddlyWiki/karlarao.html&quot; class=&quot;externalLink&quot;&gt;karlarao.html&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/store.cgi&quot; href=&quot;http://karlarao.tiddlyspot.com/store.cgi&quot; class=&quot;externalLink&quot;&gt;store.cgi&lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to  http://karlarao.tiddlyspot.com/index.html&quot; href=&quot;%20http://karlarao.tiddlyspot.com/index.html&quot; class=&quot;externalLink&quot;&gt;index.html &lt;/a&gt;&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;.&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;ok&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<link>http://karlarao.tiddlyspot.com#UploadLog</link>
<pubDate>Wed, 21 Jun 2017 23:11:00 GMT</pubDate>

</item>
<item>
<title>namecheap.com , dns propagation</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.namecheap.com/support/knowledgebase/article.aspx/9622/10/dns-propagation--explained&quot; href=&quot;https://www.namecheap.com/support/knowledgebase/article.aspx/9622/10/dns-propagation--explained&quot; class=&quot;externalLink&quot;&gt;https://www.namecheap.com/support/knowledgebase/article.aspx/9622/10/dns-propagation--explained&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.namecheap.com/support/live-chat/domains.aspx&quot; href=&quot;https://www.namecheap.com/support/live-chat/domains.aspx&quot; class=&quot;externalLink&quot;&gt;https://www.namecheap.com/support/live-chat/domains.aspx&lt;/a&gt;&lt;br&gt;kproxy.com</description>
<category>DNS</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bnamecheap.com%20%2C%20dns%20propagation%5D%5D</link>
<pubDate>Wed, 21 Jun 2017 22:19:00 GMT</pubDate>

</item>
<item>
<title>ANSI</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to http://modern-sql.com&quot; href=&quot;http://modern-sql.com&quot; class=&quot;externalLink&quot;&gt;http://modern-sql.com&lt;/a&gt;&lt;br&gt;</description>
<category>convert SQL99 to SQL ANSI JOIN and back</category>
<link>http://karlarao.tiddlyspot.com#ANSI</link>
<pubDate>Thu, 15 Jun 2017 15:54:00 GMT</pubDate>

</item>
<item>
<title>postgresql source code 2</title>
<description>&lt;div class=&quot;dcTOC&quot;&gt;&lt;a class=&quot;toggleButton&quot; title=&quot;show/collapse table of contents&quot; href=&quot;javascript:;&quot;&gt;/* Table of Contents */&lt;/a&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' hi', event)&quot;&gt; hi&lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' hello', event)&quot;&gt; hello&lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' how are you', event)&quot;&gt; how are you&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; hi&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h2&gt; hello&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;&lt;h3&gt; how are you&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h3&gt;&lt;br&gt;&lt;pre&gt;
/*-------------------------------------------------------------------------
 *
 * fe-exec.c
 *	  functions related to sending a query down to the backend
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-exec.c
 *
 *-------------------------------------------------------------------------
 */
#include &quot;postgres_fe.h&quot;

#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

#include &quot;libpq-fe.h&quot;
#include &quot;libpq-int.h&quot;

#include &quot;mb/pg_wchar.h&quot;

#ifdef WIN32
#include &quot;win32.h&quot;
#else
#include &amp;lt;unistd.h&amp;gt;
#endif

/* keep this in same order as ExecStatusType in libpq-fe.h */
char	   *const pgresStatus[] = {
	&quot;PGRES_EMPTY_QUERY&quot;,
	&quot;PGRES_COMMAND_OK&quot;,
	&quot;PGRES_TUPLES_OK&quot;,
	&quot;PGRES_COPY_OUT&quot;,
	&quot;PGRES_COPY_IN&quot;,
	&quot;PGRES_BAD_RESPONSE&quot;,
	&quot;PGRES_NONFATAL_ERROR&quot;,
	&quot;PGRES_FATAL_ERROR&quot;,
	&quot;PGRES_COPY_BOTH&quot;,
	&quot;PGRES_SINGLE_TUPLE&quot;
};

/*
 * static state needed by PQescapeString and PQescapeBytea; initialize to
 * values that result in backward-compatible behavior
 */
static int	static_client_encoding = PG_SQL_ASCII;
static bool static_std_strings = false;


static PGEvent *dupEvents(PGEvent *events, int count);
static bool pqAddTuple(PGresult *res, PGresAttValue *tup);
static bool PQsendQueryStart(PGconn *conn);
static int PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat);
static void parseInput(PGconn *conn);
static PGresult *getCopyResult(PGconn *conn, ExecStatusType copytype);
static bool PQexecStart(PGconn *conn);
static PGresult *PQexecFinish(PGconn *conn);
static int PQsendDescribe(PGconn *conn, char desc_type,
			   const char *desc_target);
static int	check_field_number(const PGresult *res, int field_num);


/* ----------------
 * Space management for PGresult.
 *
 * Formerly, libpq did a separate malloc() for each field of each tuple
 * returned by a query.  This was remarkably expensive --- malloc/free
 * consumed a sizable part of the application's runtime.  And there is
 * no real need to keep track of the fields separately, since they will
 * all be freed together when the PGresult is released.  So now, we grab
 * large blocks of storage from malloc and allocate space for query data
 * within these blocks, using a trivially simple allocator.  This reduces
 * the number of malloc/free calls dramatically, and it also avoids
 * fragmentation of the malloc storage arena.
 * The PGresult structure itself is still malloc'd separately.  We could
 * combine it with the first allocation block, but that would waste space
 * for the common case that no extra storage is actually needed (that is,
 * the SQL command did not return tuples).
 *
 * We also malloc the top-level array of tuple pointers separately, because
 * we need to be able to enlarge it via realloc, and our trivial space
 * allocator doesn't handle that effectively.  (Too bad the FE/BE protocol
 * doesn't tell us up front how many tuples will be returned.)
 * All other subsidiary storage for a PGresult is kept in PGresult_data blocks
 * of size PGRESULT_DATA_BLOCKSIZE.  The overhead at the start of each block
 * is just a link to the next one, if any.  Free-space management info is
 * kept in the owning PGresult.
 * A query returning a small amount of data will thus require three malloc
 * calls: one for the PGresult, one for the tuples pointer array, and one
 * PGresult_data block.
 *
 * Only the most recently allocated PGresult_data block is a candidate to
 * have more stuff added to it --- any extra space left over in older blocks
 * is wasted.  We could be smarter and search the whole chain, but the point
 * here is to be simple and fast.  Typical applications do not keep a PGresult
 * around very long anyway, so some wasted space within one is not a problem.
 *
 * Tuning constants for the space allocator are:
 * PGRESULT_DATA_BLOCKSIZE: size of a standard allocation block, in bytes
 * PGRESULT_ALIGN_BOUNDARY: assumed alignment requirement for binary data
 * PGRESULT_SEP_ALLOC_THRESHOLD: objects bigger than this are given separate
 *	 blocks, instead of being crammed into a regular allocation block.
 * Requirements for correct function are:
 * PGRESULT_ALIGN_BOUNDARY must be a multiple of the alignment requirements
 *		of all machine data types.  (Currently this is set from configure
 *		tests, so it should be OK automatically.)
 * PGRESULT_SEP_ALLOC_THRESHOLD + PGRESULT_BLOCK_OVERHEAD &amp;lt;=
 *			PGRESULT_DATA_BLOCKSIZE
 *		pqResultAlloc assumes an object smaller than the threshold will fit
 *		in a new block.
 * The amount of space wasted at the end of a block could be as much as
 * PGRESULT_SEP_ALLOC_THRESHOLD, so it doesn't pay to make that too large.
 * ----------------
 */

#define PGRESULT_DATA_BLOCKSIZE		2048
#define PGRESULT_ALIGN_BOUNDARY		MAXIMUM_ALIGNOF		/* from configure */
#define PGRESULT_BLOCK_OVERHEAD		Max(sizeof(PGresult_data), PGRESULT_ALIGN_BOUNDARY)
#define PGRESULT_SEP_ALLOC_THRESHOLD	(PGRESULT_DATA_BLOCKSIZE / 2)


/*
 * PQmakeEmptyPGresult
 *	 returns a newly allocated, initialized PGresult with given status.
 *	 If conn is not NULL and status indicates an error, the conn's
 *	 errorMessage is copied.  Also, any PGEvents are copied from the conn.
 */
PGresult *
PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status)
{
	PGresult   *result;

	result = (PGresult *) malloc(sizeof(PGresult));
	if (!result)
		return NULL;

	result-&amp;gt;ntups = 0;
	result-&amp;gt;numAttributes = 0;
	result-&amp;gt;attDescs = NULL;
	result-&amp;gt;tuples = NULL;
	result-&amp;gt;tupArrSize = 0;
	result-&amp;gt;numParameters = 0;
	result-&amp;gt;paramDescs = NULL;
	result-&amp;gt;resultStatus = status;
	result-&amp;gt;cmdStatus[0] = '\0';
	result-&amp;gt;binary = 0;
	result-&amp;gt;events = NULL;
	result-&amp;gt;nEvents = 0;
	result-&amp;gt;errMsg = NULL;
	result-&amp;gt;errFields = NULL;
	result-&amp;gt;errQuery = NULL;
	result-&amp;gt;null_field[0] = '\0';
	result-&amp;gt;curBlock = NULL;
	result-&amp;gt;curOffset = 0;
	result-&amp;gt;spaceLeft = 0;

	if (conn)
	{
		/* copy connection data we might need for operations on PGresult */
		result-&amp;gt;noticeHooks = conn-&amp;gt;noticeHooks;
		result-&amp;gt;client_encoding = conn-&amp;gt;client_encoding;

		/* consider copying conn's errorMessage */
		switch (status)
		{
			case PGRES_EMPTY_QUERY:
			case PGRES_COMMAND_OK:
			case PGRES_TUPLES_OK:
			case PGRES_COPY_OUT:
			case PGRES_COPY_IN:
			case PGRES_COPY_BOTH:
			case PGRES_SINGLE_TUPLE:
				/* non-error cases */
				break;
			default:
				pqSetResultError(result, conn-&amp;gt;errorMessage.data);
				break;
		}

		/* copy events last; result must be valid if we need to PQclear */
		if (conn-&amp;gt;nEvents &amp;gt; 0)
		{
			result-&amp;gt;events = dupEvents(conn-&amp;gt;events, conn-&amp;gt;nEvents);
			if (!result-&amp;gt;events)
			{
				PQclear(result);
				return NULL;
			}
			result-&amp;gt;nEvents = conn-&amp;gt;nEvents;
		}
	}
	else
	{
		/* defaults... */
		result-&amp;gt;noticeHooks.noticeRec = NULL;
		result-&amp;gt;noticeHooks.noticeRecArg = NULL;
		result-&amp;gt;noticeHooks.noticeProc = NULL;
		result-&amp;gt;noticeHooks.noticeProcArg = NULL;
		result-&amp;gt;client_encoding = PG_SQL_ASCII;
	}

	return result;
}

/*
 * PQsetResultAttrs
 *
 * Set the attributes for a given result.  This function fails if there are
 * already attributes contained in the provided result.  The call is
 * ignored if numAttributes is zero or attDescs is NULL.  If the
 * function fails, it returns zero.  If the function succeeds, it
 * returns a non-zero value.
 */
int
PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs)
{
	int			i;

	/* If attrs already exist, they cannot be overwritten. */
	if (!res || res-&amp;gt;numAttributes &amp;gt; 0)
		return FALSE;

	/* ignore no-op request */
	if (numAttributes &amp;lt;= 0 || !attDescs)
		return TRUE;

	res-&amp;gt;attDescs = (PGresAttDesc *)
		PQresultAlloc(res, numAttributes * sizeof(PGresAttDesc));

	if (!res-&amp;gt;attDescs)
		return FALSE;

	res-&amp;gt;numAttributes = numAttributes;
	memcpy(res-&amp;gt;attDescs, attDescs, numAttributes * sizeof(PGresAttDesc));

	/* deep-copy the attribute names, and determine format */
	res-&amp;gt;binary = 1;
	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (res-&amp;gt;attDescs[i].name)
			res-&amp;gt;attDescs[i].name = pqResultStrdup(res, res-&amp;gt;attDescs[i].name);
		else
			res-&amp;gt;attDescs[i].name = res-&amp;gt;null_field;

		if (!res-&amp;gt;attDescs[i].name)
			return FALSE;

		if (res-&amp;gt;attDescs[i].format == 0)
			res-&amp;gt;binary = 0;
	}

	return TRUE;
}

/*
 * PQcopyResult
 *
 * Returns a deep copy of the provided 'src' PGresult, which cannot be NULL.
 * The 'flags' argument controls which portions of the result will or will
 * NOT be copied.  The created result is always put into the
 * PGRES_TUPLES_OK status.  The source result error message is not copied,
 * although cmdStatus is.
 *
 * To set custom attributes, use PQsetResultAttrs.  That function requires
 * that there are no attrs contained in the result, so to use that
 * function you cannot use the PG_COPYRES_ATTRS or PG_COPYRES_TUPLES
 * options with this function.
 *
 * Options:
 *	 PG_COPYRES_ATTRS - Copy the source result's attributes
 *
 *	 PG_COPYRES_TUPLES - Copy the source result's tuples.  This implies
 *	 copying the attrs, seeing how the attrs are needed by the tuples.
 *
 *	 PG_COPYRES_EVENTS - Copy the source result's events.
 *
 *	 PG_COPYRES_NOTICEHOOKS - Copy the source result's notice hooks.
 */
PGresult *
PQcopyResult(const PGresult *src, int flags)
{
	PGresult   *dest;
	int			i;

	if (!src)
		return NULL;

	dest = PQmakeEmptyPGresult(NULL, PGRES_TUPLES_OK);
	if (!dest)
		return NULL;

	/* Always copy these over.  Is cmdStatus really useful here? */
	dest-&amp;gt;client_encoding = src-&amp;gt;client_encoding;
	strcpy(dest-&amp;gt;cmdStatus, src-&amp;gt;cmdStatus);

	/* Wants attrs? */
	if (flags &amp;amp; (PG_COPYRES_ATTRS | PG_COPYRES_TUPLES))
	{
		if (!PQsetResultAttrs(dest, src-&amp;gt;numAttributes, src-&amp;gt;attDescs))
		{
			PQclear(dest);
			return NULL;
		}
	}

	/* Wants to copy tuples? */
	if (flags &amp;amp; PG_COPYRES_TUPLES)
	{
		int			tup,
					field;

		for (tup = 0; tup &amp;lt; src-&amp;gt;ntups; tup++)
		{
			for (field = 0; field &amp;lt; src-&amp;gt;numAttributes; field++)
			{
				if (!PQsetvalue(dest, tup, field,
								src-&amp;gt;tuples[tup][field].value,
								src-&amp;gt;tuples[tup][field].len))
				{
					PQclear(dest);
					return NULL;
				}
			}
		}
	}

	/* Wants to copy notice hooks? */
	if (flags &amp;amp; PG_COPYRES_NOTICEHOOKS)
		dest-&amp;gt;noticeHooks = src-&amp;gt;noticeHooks;

	/* Wants to copy PGEvents? */
	if ((flags &amp;amp; PG_COPYRES_EVENTS) &amp;amp;&amp;amp; src-&amp;gt;nEvents &amp;gt; 0)
	{
		dest-&amp;gt;events = dupEvents(src-&amp;gt;events, src-&amp;gt;nEvents);
		if (!dest-&amp;gt;events)
		{
			PQclear(dest);
			return NULL;
		}
		dest-&amp;gt;nEvents = src-&amp;gt;nEvents;
	}

	/* Okay, trigger PGEVT_RESULTCOPY event */
	for (i = 0; i &amp;lt; dest-&amp;gt;nEvents; i++)
	{
		if (src-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultCopy evt;

			evt.src = src;
			evt.dest = dest;
			if (!dest-&amp;gt;events[i].proc(PGEVT_RESULTCOPY, &amp;amp;evt,
									  dest-&amp;gt;events[i].passThrough))
			{
				PQclear(dest);
				return NULL;
			}
			dest-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return dest;
}

/*
 * Copy an array of PGEvents (with no extra space for more).
 * Does not duplicate the event instance data, sets this to NULL.
 * Also, the resultInitialized flags are all cleared.
 */
static PGEvent *
dupEvents(PGEvent *events, int count)
{
	PGEvent    *newEvents;
	int			i;

	if (!events || count &amp;lt;= 0)
		return NULL;

	newEvents = (PGEvent *) malloc(count * sizeof(PGEvent));
	if (!newEvents)
		return NULL;

	for (i = 0; i &amp;lt; count; i++)
	{
		newEvents[i].proc = events[i].proc;
		newEvents[i].passThrough = events[i].passThrough;
		newEvents[i].data = NULL;
		newEvents[i].resultInitialized = FALSE;
		newEvents[i].name = strdup(events[i].name);
		if (!newEvents[i].name)
		{
			while (--i &amp;gt;= 0)
				free(newEvents[i].name);
			free(newEvents);
			return NULL;
		}
	}

	return newEvents;
}


/*
 * Sets the value for a tuple field.  The tup_num must be less than or
 * equal to PQntuples(res).  If it is equal, a new tuple is created and
 * added to the result.
 * Returns a non-zero value for success and zero for failure.
 */
int
PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len)
{
	PGresAttValue *attval;

	if (!check_field_number(res, field_num))
		return FALSE;

	/* Invalid tup_num, must be &amp;lt;= ntups */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt; res-&amp;gt;ntups)
		return FALSE;

	/* need to allocate a new tuple? */
	if (tup_num == res-&amp;gt;ntups)
	{
		PGresAttValue *tup;
		int			i;

		tup = (PGresAttValue *)
			pqResultAlloc(res, res-&amp;gt;numAttributes * sizeof(PGresAttValue),
						  TRUE);

		if (!tup)
			return FALSE;

		/* initialize each column to NULL */
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
		{
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}

		/* add it to the array */
		if (!pqAddTuple(res, tup))
			return FALSE;
	}

	attval = &amp;amp;res-&amp;gt;tuples[tup_num][field_num];

	/* treat either NULL_LEN or NULL value pointer as a NULL field */
	if (len == NULL_LEN || value == NULL)
	{
		attval-&amp;gt;len = NULL_LEN;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else if (len &amp;lt;= 0)
	{
		attval-&amp;gt;len = 0;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else
	{
		attval-&amp;gt;value = (char *) pqResultAlloc(res, len + 1, TRUE);
		if (!attval-&amp;gt;value)
			return FALSE;
		attval-&amp;gt;len = len;
		memcpy(attval-&amp;gt;value, value, len);
		attval-&amp;gt;value[len] = '\0';
	}

	return TRUE;
}

/*
 * pqResultAlloc - exported routine to allocate local storage in a PGresult.
 *
 * We force all such allocations to be maxaligned, since we don't know
 * whether the value might be binary.
 */
void *
PQresultAlloc(PGresult *res, size_t nBytes)
{
	return pqResultAlloc(res, nBytes, TRUE);
}

/*
 * pqResultAlloc -
 *		Allocate subsidiary storage for a PGresult.
 *
 * nBytes is the amount of space needed for the object.
 * If isBinary is true, we assume that we need to align the object on
 * a machine allocation boundary.
 * If isBinary is false, we assume the object is a char string and can
 * be allocated on any byte boundary.
 */
void *
pqResultAlloc(PGresult *res, size_t nBytes, bool isBinary)
{
	char	   *space;
	PGresult_data *block;

	if (!res)
		return NULL;

	if (nBytes &amp;lt;= 0)
		return res-&amp;gt;null_field;

	/*
	 * If alignment is needed, round up the current position to an alignment
	 * boundary.
	 */
	if (isBinary)
	{
		int			offset = res-&amp;gt;curOffset % PGRESULT_ALIGN_BOUNDARY;

		if (offset)
		{
			res-&amp;gt;curOffset += PGRESULT_ALIGN_BOUNDARY - offset;
			res-&amp;gt;spaceLeft -= PGRESULT_ALIGN_BOUNDARY - offset;
		}
	}

	/* If there's enough space in the current block, no problem. */
	if (nBytes &amp;lt;= (size_t) res-&amp;gt;spaceLeft)
	{
		space = res-&amp;gt;curBlock-&amp;gt;space + res-&amp;gt;curOffset;
		res-&amp;gt;curOffset += nBytes;
		res-&amp;gt;spaceLeft -= nBytes;
		return space;
	}

	/*
	 * If the requested object is very large, give it its own block; this
	 * avoids wasting what might be most of the current block to start a new
	 * block.  (We'd have to special-case requests bigger than the block size
	 * anyway.)  The object is always given binary alignment in this case.
	 */
	if (nBytes &amp;gt;= PGRESULT_SEP_ALLOC_THRESHOLD)
	{
		block = (PGresult_data *) malloc(nBytes + PGRESULT_BLOCK_OVERHEAD);
		if (!block)
			return NULL;
		space = block-&amp;gt;space + PGRESULT_BLOCK_OVERHEAD;
		if (res-&amp;gt;curBlock)
		{
			/*
			 * Tuck special block below the active block, so that we don't
			 * have to waste the free space in the active block.
			 */
			block-&amp;gt;next = res-&amp;gt;curBlock-&amp;gt;next;
			res-&amp;gt;curBlock-&amp;gt;next = block;
		}
		else
		{
			/* Must set up the new block as the first active block. */
			block-&amp;gt;next = NULL;
			res-&amp;gt;curBlock = block;
			res-&amp;gt;spaceLeft = 0; /* be sure it's marked full */
		}
		return space;
	}

	/* Otherwise, start a new block. */
	block = (PGresult_data *) malloc(PGRESULT_DATA_BLOCKSIZE);
	if (!block)
		return NULL;
	block-&amp;gt;next = res-&amp;gt;curBlock;
	res-&amp;gt;curBlock = block;
	if (isBinary)
	{
		/* object needs full alignment */
		res-&amp;gt;curOffset = PGRESULT_BLOCK_OVERHEAD;
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - PGRESULT_BLOCK_OVERHEAD;
	}
	else
	{
		/* we can cram it right after the overhead pointer */
		res-&amp;gt;curOffset = sizeof(PGresult_data);
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - sizeof(PGresult_data);
	}

	space = block-&amp;gt;space + res-&amp;gt;curOffset;
	res-&amp;gt;curOffset += nBytes;
	res-&amp;gt;spaceLeft -= nBytes;
	return space;
}

/*
 * pqResultStrdup -
 *		Like strdup, but the space is subsidiary PGresult space.
 */
char *
pqResultStrdup(PGresult *res, const char *str)
{
	char	   *space = (char *) pqResultAlloc(res, strlen(str) + 1, FALSE);

	if (space)
		strcpy(space, str);
	return space;
}

/*
 * pqSetResultError -
 *		assign a new error message to a PGresult
 */
void
pqSetResultError(PGresult *res, const char *msg)
{
	if (!res)
		return;
	if (msg &amp;amp;&amp;amp; *msg)
		res-&amp;gt;errMsg = pqResultStrdup(res, msg);
	else
		res-&amp;gt;errMsg = NULL;
}

/*
 * pqCatenateResultError -
 *		concatenate a new error message to the one already in a PGresult
 */
void
pqCatenateResultError(PGresult *res, const char *msg)
{
	PQExpBufferData errorBuf;

	if (!res || !msg)
		return;
	initPQExpBuffer(&amp;amp;errorBuf);
	if (res-&amp;gt;errMsg)
		appendPQExpBufferStr(&amp;amp;errorBuf, res-&amp;gt;errMsg);
	appendPQExpBufferStr(&amp;amp;errorBuf, msg);
	pqSetResultError(res, errorBuf.data);
	termPQExpBuffer(&amp;amp;errorBuf);
}

/*
 * PQclear -
 *	  free's the memory associated with a PGresult
 */
void
PQclear(PGresult *res)
{
	PGresult_data *block;
	int			i;

	if (!res)
		return;

	for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
	{
		/* only send DESTROY to successfully-initialized event procs */
		if (res-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultDestroy evt;

			evt.result = res;
			(void) res-&amp;gt;events[i].proc(PGEVT_RESULTDESTROY, &amp;amp;evt,
									   res-&amp;gt;events[i].passThrough);
		}
		free(res-&amp;gt;events[i].name);
	}

	if (res-&amp;gt;events)
		free(res-&amp;gt;events);

	/* Free all the subsidiary blocks */
	while ((block = res-&amp;gt;curBlock) != NULL)
	{
		res-&amp;gt;curBlock = block-&amp;gt;next;
		free(block);
	}

	/* Free the top-level tuple pointer array */
	if (res-&amp;gt;tuples)
		free(res-&amp;gt;tuples);

	/* zero out the pointer fields to catch programming errors */
	res-&amp;gt;attDescs = NULL;
	res-&amp;gt;tuples = NULL;
	res-&amp;gt;paramDescs = NULL;
	res-&amp;gt;errFields = NULL;
	res-&amp;gt;events = NULL;
	res-&amp;gt;nEvents = 0;
	/* res-&amp;gt;curBlock was zeroed out earlier */

	/* Free the PGresult structure itself */
	free(res);
}

/*
 * Handy subroutine to deallocate any partially constructed async result.
 *
 * Any &quot;next&quot; result gets cleared too.
 */
void
pqClearAsyncResult(PGconn *conn)
{
	if (conn-&amp;gt;result)
		PQclear(conn-&amp;gt;result);
	conn-&amp;gt;result = NULL;
	if (conn-&amp;gt;next_result)
		PQclear(conn-&amp;gt;next_result);
	conn-&amp;gt;next_result = NULL;
}

/*
 * This subroutine deletes any existing async result, sets conn-&amp;gt;result
 * to a PGresult with status PGRES_FATAL_ERROR, and stores the current
 * contents of conn-&amp;gt;errorMessage into that result.  It differs from a
 * plain call on PQmakeEmptyPGresult() in that if there is already an
 * async result with status PGRES_FATAL_ERROR, the current error message
 * is APPENDED to the old error message instead of replacing it.  This
 * behavior lets us report multiple error conditions properly, if necessary.
 * (An example where this is needed is when the backend sends an 'E' message
 * and immediately closes the connection --- we want to report both the
 * backend error and the connection closure error.)
 */
void
pqSaveErrorResult(PGconn *conn)
{
	/*
	 * If no old async result, just let PQmakeEmptyPGresult make one. Likewise
	 * if old result is not an error message.
	 */
	if (conn-&amp;gt;result == NULL ||
		conn-&amp;gt;result-&amp;gt;resultStatus != PGRES_FATAL_ERROR ||
		conn-&amp;gt;result-&amp;gt;errMsg == NULL)
	{
		pqClearAsyncResult(conn);
		conn-&amp;gt;result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	}
	else
	{
		/* Else, concatenate error message to existing async result. */
		pqCatenateResultError(conn-&amp;gt;result, conn-&amp;gt;errorMessage.data);
	}
}

/*
 * This subroutine prepares an async result object for return to the caller.
 * If there is not already an async result object, build an error object
 * using whatever is in conn-&amp;gt;errorMessage.  In any case, clear the async
 * result storage and make sure PQerrorMessage will agree with the result's
 * error string.
 */
PGresult *
pqPrepareAsyncResult(PGconn *conn)
{
	PGresult   *res;

	/*
	 * conn-&amp;gt;result is the PGresult to return.  If it is NULL (which probably
	 * shouldn't happen) we assume there is an appropriate error message in
	 * conn-&amp;gt;errorMessage.
	 */
	res = conn-&amp;gt;result;
	if (!res)
		res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	else
	{
		/*
		 * Make sure PQerrorMessage agrees with result; it could be different
		 * if we have concatenated messages.
		 */
		resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
		appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage,
							 PQresultErrorMessage(res));
	}

	/*
	 * Replace conn-&amp;gt;result with next_result, if any.  In the normal case
	 * there isn't a next result and we're just dropping ownership of the
	 * current result.  In single-row mode this restores the situation to what
	 * it was before we created the current single-row result.
	 */
	conn-&amp;gt;result = conn-&amp;gt;next_result;
	conn-&amp;gt;next_result = NULL;

	return res;
}

/*
 * pqInternalNotice - produce an internally-generated notice message
 *
 * A format string and optional arguments can be passed.  Note that we do
 * libpq_gettext() here, so callers need not.
 *
 * The supplied text is taken as primary message (ie., it should not include
 * a trailing newline, and should not be more than one line).
 */
void
pqInternalNotice(const PGNoticeHooks *hooks, const char *fmt,...)
{
	char		msgBuf[1024];
	va_list		args;
	PGresult   *res;

	if (hooks-&amp;gt;noticeRec == NULL)
		return;					/* nobody home to receive notice? */

	/* Format the message */
	va_start(args, fmt);
	vsnprintf(msgBuf, sizeof(msgBuf), libpq_gettext(fmt), args);
	va_end(args);
	msgBuf[sizeof(msgBuf) - 1] = '\0';	/* make real sure it's terminated */

	/* Make a PGresult to pass to the notice receiver */
	res = PQmakeEmptyPGresult(NULL, PGRES_NONFATAL_ERROR);
	if (!res)
		return;
	res-&amp;gt;noticeHooks = *hooks;

	/*
	 * Set up fields of notice.
	 */
	pqSaveMessageField(res, PG_DIAG_MESSAGE_PRIMARY, msgBuf);
	pqSaveMessageField(res, PG_DIAG_SEVERITY, libpq_gettext(&quot;NOTICE&quot;));
	pqSaveMessageField(res, PG_DIAG_SEVERITY_NONLOCALIZED, &quot;NOTICE&quot;);
	/* XXX should provide a SQLSTATE too? */

	/*
	 * Result text is always just the primary message + newline. If we can't
	 * allocate it, don't bother invoking the receiver.
	 */
	res-&amp;gt;errMsg = (char *) pqResultAlloc(res, strlen(msgBuf) + 2, FALSE);
	if (res-&amp;gt;errMsg)
	{
		sprintf(res-&amp;gt;errMsg, &quot;%s\n&quot;, msgBuf);

		/*
		 * Pass to receiver, then free it.
		 */
		(*res-&amp;gt;noticeHooks.noticeRec) (res-&amp;gt;noticeHooks.noticeRecArg, res);
	}
	PQclear(res);
}

/*
 * pqAddTuple
 *	  add a row pointer to the PGresult structure, growing it if necessary
 *	  Returns TRUE if OK, FALSE if not enough memory to add the row
 */
static bool
pqAddTuple(PGresult *res, PGresAttValue *tup)
{
	if (res-&amp;gt;ntups &amp;gt;= res-&amp;gt;tupArrSize)
	{
		/*
		 * Try to grow the array.
		 *
		 * We can use realloc because shallow copying of the structure is
		 * okay. Note that the first time through, res-&amp;gt;tuples is NULL. While
		 * ANSI says that realloc() should act like malloc() in that case,
		 * some old C libraries (like SunOS 4.1.x) coredump instead. On
		 * failure realloc is supposed to return NULL without damaging the
		 * existing allocation. Note that the positions beyond res-&amp;gt;ntups are
		 * garbage, not necessarily NULL.
		 */
		int			newSize = (res-&amp;gt;tupArrSize &amp;gt; 0) ? res-&amp;gt;tupArrSize * 2 : 128;
		PGresAttValue **newTuples;

		if (res-&amp;gt;tuples == NULL)
			newTuples = (PGresAttValue **)
				malloc(newSize * sizeof(PGresAttValue *));
		else
			newTuples = (PGresAttValue **)
				realloc(res-&amp;gt;tuples, newSize * sizeof(PGresAttValue *));
		if (!newTuples)
			return FALSE;		/* malloc or realloc failed */
		res-&amp;gt;tupArrSize = newSize;
		res-&amp;gt;tuples = newTuples;
	}
	res-&amp;gt;tuples[res-&amp;gt;ntups] = tup;
	res-&amp;gt;ntups++;
	return TRUE;
}

/*
 * pqSaveMessageField - save one field of an error or notice message
 */
void
pqSaveMessageField(PGresult *res, char code, const char *value)
{
	PGMessageField *pfield;

	pfield = (PGMessageField *)
		pqResultAlloc(res,
					  offsetof(PGMessageField, contents) +
					  strlen(value) + 1,
					  TRUE);
	if (!pfield)
		return;					/* out of memory? */
	pfield-&amp;gt;code = code;
	strcpy(pfield-&amp;gt;contents, value);
	pfield-&amp;gt;next = res-&amp;gt;errFields;
	res-&amp;gt;errFields = pfield;
}

/*
 * pqSaveParameterStatus - remember parameter status sent by backend
 */
void
pqSaveParameterStatus(PGconn *conn, const char *name, const char *value)
{
	pgParameterStatus *pstatus;
	pgParameterStatus *prev;

	if (conn-&amp;gt;Pfdebug)
		fprintf(conn-&amp;gt;Pfdebug, &quot;pqSaveParameterStatus: '%s' = '%s'\n&quot;,
				name, value);

	/*
	 * Forget any old information about the parameter
	 */
	for (pstatus = conn-&amp;gt;pstatus, prev = NULL;
		 pstatus != NULL;
		 prev = pstatus, pstatus = pstatus-&amp;gt;next)
	{
		if (strcmp(pstatus-&amp;gt;name, name) == 0)
		{
			if (prev)
				prev-&amp;gt;next = pstatus-&amp;gt;next;
			else
				conn-&amp;gt;pstatus = pstatus-&amp;gt;next;
			free(pstatus);		/* frees name and value strings too */
			break;
		}
	}

	/*
	 * Store new info as a single malloc block
	 */
	pstatus = (pgParameterStatus *) malloc(sizeof(pgParameterStatus) +
										   strlen(name) +strlen(value) + 2);
	if (pstatus)
	{
		char	   *ptr;

		ptr = ((char *) pstatus) + sizeof(pgParameterStatus);
		pstatus-&amp;gt;name = ptr;
		strcpy(ptr, name);
		ptr += strlen(name) + 1;
		pstatus-&amp;gt;value = ptr;
		strcpy(ptr, value);
		pstatus-&amp;gt;next = conn-&amp;gt;pstatus;
		conn-&amp;gt;pstatus = pstatus;
	}

	/*
	 * Special hacks: remember client_encoding and
	 * standard_conforming_strings, and convert server version to a numeric
	 * form.  We keep the first two of these in static variables as well, so
	 * that PQescapeString and PQescapeBytea can behave somewhat sanely (at
	 * least in single-connection-using programs).
	 */
	if (strcmp(name, &quot;client_encoding&quot;) == 0)
	{
		conn-&amp;gt;client_encoding = pg_char_to_encoding(value);
		/* if we don't recognize the encoding name, fall back to SQL_ASCII */
		if (conn-&amp;gt;client_encoding &amp;lt; 0)
			conn-&amp;gt;client_encoding = PG_SQL_ASCII;
		static_client_encoding = conn-&amp;gt;client_encoding;
	}
	else if (strcmp(name, &quot;standard_conforming_strings&quot;) == 0)
	{
		conn-&amp;gt;std_strings = (strcmp(value, &quot;on&quot;) == 0);
		static_std_strings = conn-&amp;gt;std_strings;
	}
	else if (strcmp(name, &quot;server_version&quot;) == 0)
	{
		int			cnt;
		int			vmaj,
					vmin,
					vrev;

		cnt = sscanf(value, &quot;%d.%d.%d&quot;, &amp;amp;vmaj, &amp;amp;vmin, &amp;amp;vrev);

		if (cnt == 3)
		{
			/* old style, e.g. 9.6.1 */
			conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100 + vrev;
		}
		else if (cnt == 2)
		{
			if (vmaj &amp;gt;= 10)
			{
				/* new style, e.g. 10.1 */
				conn-&amp;gt;sversion = 100 * 100 * vmaj + vmin;
			}
			else
			{
				/* old style without minor version, e.g. 9.6devel */
				conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100;
			}
		}
		else if (cnt == 1)
		{
			/* new style without minor version, e.g. 10devel */
			conn-&amp;gt;sversion = 100 * 100 * vmaj;
		}
		else
			conn-&amp;gt;sversion = 0; /* unknown */
	}
}


/*
 * pqRowProcessor
 *	  Add the received row to the current async result (conn-&amp;gt;result).
 *	  Returns 1 if OK, 0 if error occurred.
 *
 * On error, *errmsgp can be set to an error string to be returned.
 * If it is left NULL, the error is presumed to be &quot;out of memory&quot;.
 *
 * In single-row mode, we create a new result holding just the current row,
 * stashing the previous result in conn-&amp;gt;next_result so that it becomes
 * active again after pqPrepareAsyncResult().  This allows the result metadata
 * (column descriptions) to be carried forward to each result row.
 */
int
pqRowProcessor(PGconn *conn, const char **errmsgp)
{
	PGresult   *res = conn-&amp;gt;result;
	int			nfields = res-&amp;gt;numAttributes;
	const PGdataValue *columns = conn-&amp;gt;rowBuf;
	PGresAttValue *tup;
	int			i;

	/*
	 * In single-row mode, make a new PGresult that will hold just this one
	 * row; the original conn-&amp;gt;result is left unchanged so that it can be used
	 * again as the template for future rows.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Copy everything that should be in the result at this point */
		res = PQcopyResult(res,
						   PG_COPYRES_ATTRS | PG_COPYRES_EVENTS |
						   PG_COPYRES_NOTICEHOOKS);
		if (!res)
			return 0;
	}

	/*
	 * Basically we just allocate space in the PGresult for each field and
	 * copy the data over.
	 *
	 * Note: on malloc failure, we return 0 leaving *errmsgp still NULL, which
	 * caller will take to mean &quot;out of memory&quot;.  This is preferable to trying
	 * to set up such a message here, because evidently there's not enough
	 * memory for gettext() to do anything.
	 */
	tup = (PGresAttValue *)
		pqResultAlloc(res, nfields * sizeof(PGresAttValue), TRUE);
	if (tup == NULL)
		goto fail;

	for (i = 0; i &amp;lt; nfields; i++)
	{
		int			clen = columns[i].len;

		if (clen &amp;lt; 0)
		{
			/* null field */
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}
		else
		{
			bool		isbinary = (res-&amp;gt;attDescs[i].format != 0);
			char	   *val;

			val = (char *) pqResultAlloc(res, clen + 1, isbinary);
			if (val == NULL)
				goto fail;

			/* copy and zero-terminate the data (even if it's binary) */
			memcpy(val, columns[i].value, clen);
			val[clen] = '\0';

			tup[i].len = clen;
			tup[i].value = val;
		}
	}

	/* And add the tuple to the PGresult's tuple array */
	if (!pqAddTuple(res, tup))
		goto fail;

	/*
	 * Success.  In single-row mode, make the result available to the client
	 * immediately.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Change result status to special single-row value */
		res-&amp;gt;resultStatus = PGRES_SINGLE_TUPLE;
		/* Stash old result for re-use later */
		conn-&amp;gt;next_result = conn-&amp;gt;result;
		conn-&amp;gt;result = res;
		/* And mark the result ready to return */
		conn-&amp;gt;asyncStatus = PGASYNC_READY;
	}

	return 1;

fail:
	/* release locally allocated PGresult, if we made one */
	if (res != conn-&amp;gt;result)
		PQclear(res);
	return 0;
}


/*
 * PQsendQuery
 *	 Submit a query, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendQuery(PGconn *conn, const char *query)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the argument */
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}

	/* construct the outgoing Query message */
	if (pqPutMsgStart('Q', false, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* remember we are using simple query protocol */
	conn-&amp;gt;queryclass = PGQUERY_SIMPLE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;
}

/*
 * PQsendQueryParams
 *		Like PQsendQuery, but use protocol 3.0 so we can pass parameters
 */
int
PQsendQueryParams(PGconn *conn,
				  const char *command,
				  int nParams,
				  const Oid *paramTypes,
				  const char *const * paramValues,
				  const int *paramLengths,
				  const int *paramFormats,
				  int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!command)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   command,
						   &quot;&quot;,	/* use unnamed statement */
						   nParams,
						   paramTypes,
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * PQsendPrepare
 *	 Submit a Parse message, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendPrepare(PGconn *conn,
			  const char *stmtName, const char *query,
			  int nParams, const Oid *paramTypes)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Parse message */
	if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0)
		goto sendFailed;

	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
	{
		int			i;

		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing just a Parse */
	conn-&amp;gt;queryclass = PGQUERY_PREPARE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQsendQueryPrepared
 *		Like PQsendQuery, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
int
PQsendQueryPrepared(PGconn *conn,
					const char *stmtName,
					int nParams,
					const char *const * paramValues,
					const int *paramLengths,
					const int *paramFormats,
					int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   NULL,	/* no command to parse */
						   stmtName,
						   nParams,
						   NULL,	/* no param types */
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * Common startup code for PQsendQuery and sibling routines
 */
static bool
PQsendQueryStart(PGconn *conn)
{
	if (!conn)
		return false;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Don't try to send if we know there's no live connection. */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no connection to the server\n&quot;));
		return false;
	}
	/* Can't send while already busy, either. */
	if (conn-&amp;gt;asyncStatus != PGASYNC_IDLE)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;another command is already in progress\n&quot;));
		return false;
	}

	/* initialize async result-accumulation state */
	pqClearAsyncResult(conn);

	/* reset single-row processing mode */
	conn-&amp;gt;singleRowMode = false;

	/* ready to send command message */
	return true;
}

/*
 * PQsendQueryGuts
 *		Common code for protocol-3.0 query sending
 *		PQsendQueryStart should be done already
 *
 * command may be NULL to indicate we use an already-prepared statement
 */
static int
PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat)
{
	int			i;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/*
	 * We will send Parse (if needed), Bind, Describe Portal, Execute, Sync,
	 * using specified statement name and the unnamed portal.
	 */

	if (command)
	{
		/* construct the Parse message */
		if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
			pqPuts(stmtName, conn) &amp;lt; 0 ||
			pqPuts(command, conn) &amp;lt; 0)
			goto sendFailed;
		if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
		{
			if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
				goto sendFailed;
			for (i = 0; i &amp;lt; nParams; i++)
			{
				if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
					goto sendFailed;
			}
		}
		else
		{
			if (pqPutInt(0, 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
		if (pqPutMsgEnd(conn) &amp;lt; 0)
			goto sendFailed;
	}

	/* Construct the Bind message */
	if (pqPutMsgStart('B', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameter formats */
	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramFormats)
	{
		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramFormats[i], 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}

	if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameters */
	for (i = 0; i &amp;lt; nParams; i++)
	{
		if (paramValues &amp;amp;&amp;amp; paramValues[i])
		{
			int			nbytes;

			if (paramFormats &amp;amp;&amp;amp; paramFormats[i] != 0)
			{
				/* binary parameter */
				if (paramLengths)
					nbytes = paramLengths[i];
				else
				{
					printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
									  libpq_gettext(&quot;length must be given for binary parameter\n&quot;));
					goto sendFailed;
				}
			}
			else
			{
				/* text parameter, do not use paramLengths */
				nbytes = strlen(paramValues[i]);
			}
			if (pqPutInt(nbytes, 4, conn) &amp;lt; 0 ||
				pqPutnchar(paramValues[i], nbytes, conn) &amp;lt; 0)
				goto sendFailed;
		}
		else
		{
			/* take the param as NULL */
			if (pqPutInt(-1, 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	if (pqPutInt(1, 2, conn) &amp;lt; 0 ||
		pqPutInt(resultFormat, 2, conn))
		goto sendFailed;
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Describe Portal message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc('P', conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Execute message */
	if (pqPutMsgStart('E', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutInt(0, 4, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are using extended query protocol */
	conn-&amp;gt;queryclass = PGQUERY_EXTENDED;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	if (command)
		conn-&amp;gt;last_query = strdup(command);
	else
		conn-&amp;gt;last_query = NULL;

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * pqHandleSendFailure: try to clean up after failure to send command.
 *
 * Primarily, what we want to accomplish here is to process any ERROR or
 * NOTICE messages that the backend might have sent just before it died.
 * Since we're in IDLE state, all such messages will get sent to the notice
 * processor.
 *
 * NOTE: this routine should only be called in PGASYNC_IDLE state.
 */
void
pqHandleSendFailure(PGconn *conn)
{
	/*
	 * Accept and parse any available input data, ignoring I/O errors.  Note
	 * that if pqReadData decides the backend has closed the channel, it will
	 * close our side of the socket --- that's just what we want here.
	 */
	while (pqReadData(conn) &amp;gt; 0)
		parseInput(conn);

	/*
	 * Be sure to parse available input messages even if we read no data.
	 * (Note: calling parseInput within the above loop isn't really necessary,
	 * but it prevents buffer bloat if there's a lot of data available.)
	 */
	parseInput(conn);
}

/*
 * Select row-by-row processing mode
 */
int
PQsetSingleRowMode(PGconn *conn)
{
	/*
	 * Only allow setting the flag when we have launched a query and not yet
	 * received any results.
	 */
	if (!conn)
		return 0;
	if (conn-&amp;gt;asyncStatus != PGASYNC_BUSY)
		return 0;
	if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE &amp;amp;&amp;amp;
		conn-&amp;gt;queryclass != PGQUERY_EXTENDED)
		return 0;
	if (conn-&amp;gt;result)
		return 0;

	/* OK, set flag */
	conn-&amp;gt;singleRowMode = true;
	return 1;
}

/*
 * Consume any available input from the backend
 * 0 return: some kind of trouble
 * 1 return: no problem
 */
int
PQconsumeInput(PGconn *conn)
{
	if (!conn)
		return 0;

	/*
	 * for non-blocking connections try to flush the send-queue, otherwise we
	 * may never get a response for something that may not have already been
	 * sent because it's in our write buffer!
	 */
	if (pqIsnonblocking(conn))
	{
		if (pqFlush(conn) &amp;lt; 0)
			return 0;
	}

	/*
	 * Load more data, if available. We do this no matter what state we are
	 * in, since we are probably getting called because the application wants
	 * to get rid of a read-select condition. Note that we will NOT block
	 * waiting for more input.
	 */
	if (pqReadData(conn) &amp;lt; 0)
		return 0;

	/* Parsing of the data waits till later. */
	return 1;
}


/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */
static void
parseInput(PGconn *conn)
{
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		pqParseInput3(conn);
	else
		pqParseInput2(conn);
}

/*
 * PQisBusy
 *	 Return TRUE if PQgetResult would block waiting for input.
 */

int
PQisBusy(PGconn *conn)
{
	if (!conn)
		return FALSE;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* PQgetResult will return immediately in all states except BUSY. */
	return conn-&amp;gt;asyncStatus == PGASYNC_BUSY;
}


/*
 * PQgetResult
 *	  Get the next PGresult produced by a query.  Returns NULL if no
 *	  query work remains or an error has occurred (e.g. out of
 *	  memory).
 */

PGresult *
PQgetResult(PGconn *conn)
{
	PGresult   *res;

	if (!conn)
		return NULL;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* If not ready to return something, block until we are. */
	while (conn-&amp;gt;asyncStatus == PGASYNC_BUSY)
	{
		int			flushResult;

		/*
		 * If data remains unsent, send it.  Else we might be waiting for the
		 * result of a command the backend hasn't even got yet.
		 */
		while ((flushResult = pqFlush(conn)) &amp;gt; 0)
		{
			if (pqWait(FALSE, TRUE, conn))
			{
				flushResult = -1;
				break;
			}
		}

		/* Wait for some more data, and load it. */
		if (flushResult ||
			pqWait(TRUE, FALSE, conn) ||
			pqReadData(conn) &amp;lt; 0)
		{
			/*
			 * conn-&amp;gt;errorMessage has been set by pqWait or pqReadData. We
			 * want to append it to any already-received error message.
			 */
			pqSaveErrorResult(conn);
			conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
			return pqPrepareAsyncResult(conn);
		}

		/* Parse it. */
		parseInput(conn);
	}

	/* Return the appropriate thing. */
	switch (conn-&amp;gt;asyncStatus)
	{
		case PGASYNC_IDLE:
			res = NULL;			/* query is complete */
			break;
		case PGASYNC_READY:
			res = pqPrepareAsyncResult(conn);
			/* Set the state back to BUSY, allowing parsing to proceed. */
			conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
			break;
		case PGASYNC_COPY_IN:
			res = getCopyResult(conn, PGRES_COPY_IN);
			break;
		case PGASYNC_COPY_OUT:
			res = getCopyResult(conn, PGRES_COPY_OUT);
			break;
		case PGASYNC_COPY_BOTH:
			res = getCopyResult(conn, PGRES_COPY_BOTH);
			break;
		default:
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;unexpected asyncStatus: %d\n&quot;),
							  (int) conn-&amp;gt;asyncStatus);
			res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
			break;
	}

	if (res)
	{
		int			i;

		for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
		{
			PGEventResultCreate evt;

			evt.conn = conn;
			evt.result = res;
			if (!res-&amp;gt;events[i].proc(PGEVT_RESULTCREATE, &amp;amp;evt,
									 res-&amp;gt;events[i].passThrough))
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
								  libpq_gettext(&quot;PGEventProc \&quot;%s\&quot; failed during PGEVT_RESULTCREATE event\n&quot;),
								  res-&amp;gt;events[i].name);
				pqSetResultError(res, conn-&amp;gt;errorMessage.data);
				res-&amp;gt;resultStatus = PGRES_FATAL_ERROR;
				break;
			}
			res-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return res;
}

/*
 * getCopyResult
 *	  Helper for PQgetResult: generate result for COPY-in-progress cases
 */
static PGresult *
getCopyResult(PGconn *conn, ExecStatusType copytype)
{
	/*
	 * If the server connection has been lost, don't pretend everything is
	 * hunky-dory; instead return a PGRES_FATAL_ERROR result, and reset the
	 * asyncStatus to idle (corresponding to what we'd do if we'd detected I/O
	 * error in the earlier steps in PQgetResult).  The text returned in the
	 * result is whatever is in conn-&amp;gt;errorMessage; we hope that was filled
	 * with something relevant when the lost connection was detected.
	 */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		pqSaveErrorResult(conn);
		conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
		return pqPrepareAsyncResult(conn);
	}

	/* If we have an async result for the COPY, return that */
	if (conn-&amp;gt;result &amp;amp;&amp;amp; conn-&amp;gt;result-&amp;gt;resultStatus == copytype)
		return pqPrepareAsyncResult(conn);

	/* Otherwise, invent a suitable PGresult */
	return PQmakeEmptyPGresult(conn, copytype);
}


/*
 * PQexec
 *	  send a query to the backend and package up the result in a PGresult
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQexec(PGconn *conn, const char *query)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQuery(conn, query))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecParams
 *		Like PQexec, but use protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecParams(PGconn *conn,
			 const char *command,
			 int nParams,
			 const Oid *paramTypes,
			 const char *const * paramValues,
			 const int *paramLengths,
			 const int *paramFormats,
			 int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryParams(conn, command,
						   nParams, paramTypes, paramValues, paramLengths,
						   paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQprepare
 *	  Creates a prepared statement by issuing a v3.0 parse message.
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQprepare(PGconn *conn,
		  const char *stmtName, const char *query,
		  int nParams, const Oid *paramTypes)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendPrepare(conn, stmtName, query, nParams, paramTypes))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecPrepared
 *		Like PQexec, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecPrepared(PGconn *conn,
			   const char *stmtName,
			   int nParams,
			   const char *const * paramValues,
			   const int *paramLengths,
			   const int *paramFormats,
			   int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryPrepared(conn, stmtName,
							 nParams, paramValues, paramLengths,
							 paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * Common code for PQexec and sibling routines: prepare to send command
 */
static bool
PQexecStart(PGconn *conn)
{
	PGresult   *result;

	if (!conn)
		return false;

	/*
	 * Silently discard any prior query result that application didn't eat.
	 * This is probably poor design, but it's here for backward compatibility.
	 */
	while ((result = PQgetResult(conn)) != NULL)
	{
		ExecStatusType resultStatus = result-&amp;gt;resultStatus;

		PQclear(result);		/* only need its status */
		if (resultStatus == PGRES_COPY_IN)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/* In protocol 3, we can get out of a COPY IN state */
				if (PQputCopyEnd(conn,
						 libpq_gettext(&quot;COPY terminated by new PQexec&quot;)) &amp;lt; 0)
					return false;
				/* keep waiting to swallow the copy's failure message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;COPY IN state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_OUT)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/*
				 * In protocol 3, we can get out of a COPY OUT state: we just
				 * switch back to BUSY and allow the remaining COPY data to be
				 * dropped on the floor.
				 */
				conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
				/* keep waiting to swallow the copy's completion message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				 libpq_gettext(&quot;COPY OUT state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_BOTH)
		{
			/* We don't allow PQexec during COPY BOTH */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
					 libpq_gettext(&quot;PQexec not allowed during COPY BOTH\n&quot;));
			return false;
		}
		/* check for loss of connection, too */
		if (conn-&amp;gt;status == CONNECTION_BAD)
			return false;
	}

	/* OK to send a command */
	return true;
}

/*
 * Common code for PQexec and sibling routines: wait for command result
 */
static PGresult *
PQexecFinish(PGconn *conn)
{
	PGresult   *result;
	PGresult   *lastResult;

	/*
	 * For backwards compatibility, return the last result if there are more
	 * than one --- but merge error messages if we get more than one error
	 * result.
	 *
	 * We have to stop if we see copy in/out/both, however. We will resume
	 * parsing after application performs the data transfer.
	 *
	 * Also stop if the connection is lost (else we'll loop infinitely).
	 */
	lastResult = NULL;
	while ((result = PQgetResult(conn)) != NULL)
	{
		if (lastResult)
		{
			if (lastResult-&amp;gt;resultStatus == PGRES_FATAL_ERROR &amp;amp;&amp;amp;
				result-&amp;gt;resultStatus == PGRES_FATAL_ERROR)
			{
				pqCatenateResultError(lastResult, result-&amp;gt;errMsg);
				PQclear(result);
				result = lastResult;

				/*
				 * Make sure PQerrorMessage agrees with concatenated result
				 */
				resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
				appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage, result-&amp;gt;errMsg);
			}
			else
				PQclear(lastResult);
		}
		lastResult = result;
		if (result-&amp;gt;resultStatus == PGRES_COPY_IN ||
			result-&amp;gt;resultStatus == PGRES_COPY_OUT ||
			result-&amp;gt;resultStatus == PGRES_COPY_BOTH ||
			conn-&amp;gt;status == CONNECTION_BAD)
			break;
	}

	return lastResult;
}

/*
 * PQdescribePrepared
 *	  Obtain information about a previously prepared statement
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).  On success, the PGresult contains status
 * PGRES_COMMAND_OK, and its parameter and column-heading fields describe
 * the statement's inputs and outputs respectively.
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQdescribePrepared(PGconn *conn, const char *stmt)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'S', stmt))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQdescribePortal
 *	  Obtain information about a previously created portal
 *
 * This is much like PQdescribePrepared, except that no parameter info is
 * returned.  Note that at the moment, libpq doesn't really expose portals
 * to the client; but this can be used with a portal created by a SQL
 * DECLARE CURSOR command.
 */
PGresult *
PQdescribePortal(PGconn *conn, const char *portal)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'P', portal))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQsendDescribePrepared
 *	 Submit a Describe Statement command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePrepared(PGconn *conn, const char *stmt)
{
	return PQsendDescribe(conn, 'S', stmt);
}

/*
 * PQsendDescribePortal
 *	 Submit a Describe Portal command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePortal(PGconn *conn, const char *portal)
{
	return PQsendDescribe(conn, 'P', portal);
}

/*
 * PQsendDescribe
 *	 Common code to send a Describe command
 *
 * Available options for desc_type are
 *	 'S' to describe a prepared statement; or
 *	 'P' to describe a portal.
 * Returns 1 on success and 0 on failure.
 */
static int
PQsendDescribe(PGconn *conn, char desc_type, const char *desc_target)
{
	/* Treat null desc_target as empty string */
	if (!desc_target)
		desc_target = &quot;&quot;;

	if (!PQsendQueryStart(conn))
		return 0;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Describe message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc(desc_type, conn) &amp;lt; 0 ||
		pqPuts(desc_target, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing a Describe */
	conn-&amp;gt;queryclass = PGQUERY_DESCRIBE;

	/* reset last-query string (not relevant now) */
	if (conn-&amp;gt;last_query)
	{
		free(conn-&amp;gt;last_query);
		conn-&amp;gt;last_query = NULL;
	}

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQnotifies
 *	  returns a PGnotify* structure of the latest async notification
 * that has not yet been handled
 *
 * returns NULL, if there is currently
 * no unhandled async notification from the backend
 *
 * the CALLER is responsible for FREE'ing the structure returned
 */
PGnotify *
PQnotifies(PGconn *conn)
{
	PGnotify   *event;

	if (!conn)
		return NULL;

	/* Parse any available data to see if we can extract NOTIFY messages. */
	parseInput(conn);

	event = conn-&amp;gt;notifyHead;
	if (event)
	{
		conn-&amp;gt;notifyHead = event-&amp;gt;next;
		if (!conn-&amp;gt;notifyHead)
			conn-&amp;gt;notifyTail = NULL;
		event-&amp;gt;next = NULL;		/* don't let app see the internal state */
	}
	return event;
}

/*
 * PQputCopyData - send some data to the backend during COPY IN or COPY BOTH
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyData(PGconn *conn, const char *buffer, int nbytes)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Process any NOTICE or NOTIFY messages that might be pending in the
	 * input buffer.  Since the server might generate many notices during the
	 * COPY, we want to clean those out reasonably promptly to prevent
	 * indefinite expansion of the input buffer.  (Note: the actual read of
	 * input data into the input buffer happens down inside pqSendSome, but
	 * it's not authorized to get rid of the data again.)
	 */
	parseInput(conn);

	if (nbytes &amp;gt; 0)
	{
		/*
		 * Try to flush any previously sent data in preference to growing the
		 * output buffer.  If we can't enlarge the buffer enough to hold the
		 * data, return 0 in the nonblock case, else hard error. (For
		 * simplicity, always assume 5 bytes of overhead even in protocol 2.0
		 * case.)
		 */
		if ((conn-&amp;gt;outBufSize - conn-&amp;gt;outCount - 5) &amp;lt; nbytes)
		{
			if (pqFlush(conn) &amp;lt; 0)
				return -1;
			if (pqCheckOutBufferSpace(conn-&amp;gt;outCount + 5 + (size_t) nbytes,
									  conn))
				return pqIsnonblocking(conn) ? 0 : -1;
		}
		/* Send the data (too simple to delegate to fe-protocol files) */
		if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		{
			if (pqPutMsgStart('d', false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	return 1;
}

/*
 * PQputCopyEnd - send EOF indication to the backend during COPY IN
 *
 * After calling this, use PQgetResult() to check command completion status.
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyEnd(PGconn *conn, const char *errormsg)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Send the COPY END indicator.  This is simple enough that we don't
	 * bother delegating it to the fe-protocol files.
	 */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
	{
		if (errormsg)
		{
			/* Send COPY FAIL */
			if (pqPutMsgStart('f', false, conn) &amp;lt; 0 ||
				pqPuts(errormsg, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			/* Send COPY DONE */
			if (pqPutMsgStart('c', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}

		/*
		 * If we sent the COPY command in extended-query mode, we must issue a
		 * Sync as well.
		 */
		if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE)
		{
			if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	else
	{
		if (errormsg)
		{
			/* Oops, no way to do this in 2.0 */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
			return -1;
		}
		else
		{
			/* Send old-style end-of-data marker */
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(&quot;\\.\n&quot;, 3, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}

	/* Return to active duty */
	if (conn-&amp;gt;asyncStatus == PGASYNC_COPY_BOTH)
		conn-&amp;gt;asyncStatus = PGASYNC_COPY_OUT;
	else
		conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Try to flush data */
	if (pqFlush(conn) &amp;lt; 0)
		return -1;

	return 1;
}

/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 * or COPY BOTH
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &amp;gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */
int
PQgetCopyData(PGconn *conn, char **buffer, int async)
{
	*buffer = NULL;				/* for all failure cases */
	if (!conn)
		return -2;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_OUT &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -2;
	}
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetCopyData3(conn, buffer, async);
	else
		return pqGetCopyData2(conn, buffer, async);
}

/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * Chiefly here so that applications can use &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * and read the output string.  Returns a null-terminated string in s.
 *
 * XXX this routine is now deprecated, because it can't handle binary data.
 * If called during a COPY BINARY we return EOF.
 *
 * PQgetline reads up to maxlen-1 characters (like fgets(3)) but strips
 * the terminating \n (like gets(3)).
 *
 * CAUTION: the caller is responsible for detecting the end-of-copy signal
 * (a line containing just &quot;\.&quot;) when using this routine.
 *
 * RETURNS:
 *		EOF if error (eg, invalid arguments are given)
 *		0 if EOL is reached (i.e., \n has been read)
 *				(this is required for backward-compatibility -- this
 *				 routine used to always return EOF or 0, assuming that
 *				 the line ended within maxlen bytes.)
 *		1 in other cases (i.e., the buffer was filled before \n is reached)
 */
int
PQgetline(PGconn *conn, char *s, int maxlen)
{
	if (!s || maxlen &amp;lt;= 0)
		return EOF;
	*s = '\0';
	/* maxlen must be at least 3 to hold the \. terminator! */
	if (maxlen &amp;lt; 3)
		return EOF;

	if (!conn)
		return EOF;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetline3(conn, s, maxlen);
	else
		return pqGetline2(conn, s, maxlen);
}

/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * This routine is for applications that want to do &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * asynchronously, that is without blocking.  Having issued the COPY command
 * and gotten a PGRES_COPY_OUT response, the app should call PQconsumeInput
 * and this routine until the end-of-data signal is detected.  Unlike
 * PQgetline, this routine takes responsibility for detecting end-of-data.
 *
 * On each call, PQgetlineAsync will return data if a complete data row
 * is available in libpq's input buffer.  Otherwise, no data is returned
 * until the rest of the row arrives.
 *
 * If -1 is returned, the end-of-data signal has been recognized (and removed
 * from libpq's input buffer).  The caller *must* next call PQendcopy and
 * then return to normal processing.
 *
 * RETURNS:
 *	 -1    if the end-of-copy-data marker has been recognized
 *	 0	   if no data is available
 *	 &amp;gt;0    the number of bytes returned.
 *
 * The data returned will not extend beyond a data-row boundary.  If possible
 * a whole row will be returned at one time.  But if the buffer offered by
 * the caller is too small to hold a row sent by the backend, then a partial
 * data row will be returned.  In text mode this can be detected by testing
 * whether the last returned byte is '\n' or not.
 *
 * The returned data is *not* null-terminated.
 */

int
PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)
{
	if (!conn)
		return -1;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetlineAsync3(conn, buffer, bufsize);
	else
		return pqGetlineAsync2(conn, buffer, bufsize);
}

/*
 * PQputline -- sends a string to the backend during COPY IN.
 * Returns 0 if OK, EOF if not.
 *
 * This is deprecated primarily because the return convention doesn't allow
 * caller to tell the difference between a hard error and a nonblock-mode
 * send failure.
 */
int
PQputline(PGconn *conn, const char *s)
{
	return PQputnbytes(conn, s, strlen(s));
}

/*
 * PQputnbytes -- like PQputline, but buffer need not be null-terminated.
 * Returns 0 if OK, EOF if not.
 */
int
PQputnbytes(PGconn *conn, const char *buffer, int nbytes)
{
	if (PQputCopyData(conn, buffer, nbytes) &amp;gt; 0)
		return 0;
	else
		return EOF;
}

/*
 * PQendcopy
 *		After completing the data transfer portion of a copy in/out,
 *		the application must call this routine to finish the command protocol.
 *
 * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult
 * to get the transfer status.  Note however that when using 2.0 protocol,
 * recovering from a copy failure often requires a PQreset.  PQendcopy will
 * take care of that, PQgetResult won't.
 *
 * RETURNS:
 *		0 on success
 *		1 on failure
 */
int
PQendcopy(PGconn *conn)
{
	if (!conn)
		return 0;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqEndcopy3(conn);
	else
		return pqEndcopy2(conn);
}


/* ----------------
 *		PQfn -	Send a function call to the POSTGRES backend.
 *
 *		conn			: backend connection
 *		fnid			: OID of function to be called
 *		result_buf		: pointer to result buffer
 *		result_len		: actual length of result is returned here
 *		result_is_int	: If the result is an integer, this must be 1,
 *						  otherwise this should be 0
 *		args			: pointer to an array of function arguments
 *						  (each has length, if integer, and value/pointer)
 *		nargs			: # of arguments in args array.
 *
 * RETURNS
 *		PGresult with status = PGRES_COMMAND_OK if successful.
 *			*result_len is &amp;gt; 0 if there is a return value, 0 if not.
 *		PGresult with status = PGRES_FATAL_ERROR if backend returns an error.
 *		NULL on communications failure.  conn-&amp;gt;errorMessage will be set.
 * ----------------
 */

PGresult *
PQfn(PGconn *conn,
	 int fnid,
	 int *result_buf,
	 int *result_len,
	 int result_is_int,
	 const PQArgBlock *args,
	 int nargs)
{
	*result_len = 0;

	if (!conn)
		return NULL;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	if (conn-&amp;gt;sock == PGINVALID_SOCKET || conn-&amp;gt;asyncStatus != PGASYNC_IDLE ||
		conn-&amp;gt;result != NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;connection in wrong state\n&quot;));
		return NULL;
	}

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqFunctionCall3(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
	else
		return pqFunctionCall2(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
}


/* ====== accessor funcs for PGresult ======== */

ExecStatusType
PQresultStatus(const PGresult *res)
{
	if (!res)
		return PGRES_FATAL_ERROR;
	return res-&amp;gt;resultStatus;
}

char *
PQresStatus(ExecStatusType status)
{
	if ((unsigned int) status &amp;gt;= sizeof pgresStatus / sizeof pgresStatus[0])
		return libpq_gettext(&quot;invalid ExecStatusType code&quot;);
	return pgresStatus[status];
}

char *
PQresultErrorMessage(const PGresult *res)
{
	if (!res || !res-&amp;gt;errMsg)
		return &quot;&quot;;
	return res-&amp;gt;errMsg;
}

char *
PQresultVerboseErrorMessage(const PGresult *res,
							PGVerbosity verbosity,
							PGContextVisibility show_context)
{
	PQExpBufferData workBuf;

	/*
	 * Because the caller is expected to free the result string, we must
	 * strdup any constant result.  We use plain strdup and document that
	 * callers should expect NULL if out-of-memory.
	 */
	if (!res ||
		(res-&amp;gt;resultStatus != PGRES_FATAL_ERROR &amp;amp;&amp;amp;
		 res-&amp;gt;resultStatus != PGRES_NONFATAL_ERROR))
		return strdup(libpq_gettext(&quot;PGresult is not an error result\n&quot;));

	initPQExpBuffer(&amp;amp;workBuf);

	/*
	 * Currently, we pass this off to fe-protocol3.c in all cases; it will
	 * behave reasonably sanely with an error reported by fe-protocol2.c as
	 * well.  If necessary, we could record the protocol version in PGresults
	 * so as to be able to invoke a version-specific message formatter, but
	 * for now there's no need.
	 */
	pqBuildErrorMessage3(&amp;amp;workBuf, res, verbosity, show_context);

	/* If insufficient memory to format the message, fail cleanly */
	if (PQExpBufferDataBroken(workBuf))
	{
		termPQExpBuffer(&amp;amp;workBuf);
		return strdup(libpq_gettext(&quot;out of memory\n&quot;));
	}

	return workBuf.data;
}

char *
PQresultErrorField(const PGresult *res, int fieldcode)
{
	PGMessageField *pfield;

	if (!res)
		return NULL;
	for (pfield = res-&amp;gt;errFields; pfield != NULL; pfield = pfield-&amp;gt;next)
	{
		if (pfield-&amp;gt;code == fieldcode)
			return pfield-&amp;gt;contents;
	}
	return NULL;
}

int
PQntuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;ntups;
}

int
PQnfields(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numAttributes;
}

int
PQbinaryTuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;binary;
}

/*
 * Helper routines to range-check field numbers and tuple numbers.
 * Return TRUE if OK, FALSE if not
 */

static int
check_field_number(const PGresult *res, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_tuple_field_number(const PGresult *res,
						 int tup_num, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt;= res-&amp;gt;ntups)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;row number %d is out of range 0..%d&quot;,
						 tup_num, res-&amp;gt;ntups - 1);
		return FALSE;
	}
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_param_number(const PGresult *res, int param_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (param_num &amp;lt; 0 || param_num &amp;gt;= res-&amp;gt;numParameters)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;parameter number %d is out of range 0..%d&quot;,
						 param_num, res-&amp;gt;numParameters - 1);
		return FALSE;
	}

	return TRUE;
}

/*
 * returns NULL if the field_num is invalid
 */
char *
PQfname(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return NULL;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].name;
	else
		return NULL;
}

/*
 * PQfnumber: find column number given column name
 *
 * The column name is parsed as if it were in a SQL statement, including
 * case-folding and double-quote processing.  But note a possible gotcha:
 * downcasing in the frontend might follow different locale rules than
 * downcasing in the backend...
 *
 * Returns -1 if no match.  In the present backend it is also possible
 * to have multiple matches, in which case the first one is found.
 */
int
PQfnumber(const PGresult *res, const char *field_name)
{
	char	   *field_case;
	bool		in_quotes;
	bool		all_lower = true;
	const char *iptr;
	char	   *optr;
	int			i;

	if (!res)
		return -1;

	/*
	 * Note: it is correct to reject a zero-length input string; the proper
	 * input to match a zero-length field name would be &quot;&quot;.
	 */
	if (field_name == NULL ||
		field_name[0] == '\0' ||
		res-&amp;gt;attDescs == NULL)
		return -1;

	/*
	 * Check if we can avoid the strdup() and related work because the
	 * passed-in string wouldn't be changed before we do the check anyway.
	 */
	for (iptr = field_name; *iptr; iptr++)
	{
		char		c = *iptr;

		if (c == '&quot;' || c != pg_tolower((unsigned char) c))
		{
			all_lower = false;
			break;
		}
	}

	if (all_lower)
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
			if (strcmp(field_name, res-&amp;gt;attDescs[i].name) == 0)
				return i;

	/* Fall through to the normal check if that didn't work out. */

	/*
	 * Note: this code will not reject partially quoted strings, eg
	 * foo&quot;BAR&quot;foo will become fooBARfoo when it probably ought to be an error
	 * condition.
	 */
	field_case = strdup(field_name);
	if (field_case == NULL)
		return -1;				/* grotty */

	in_quotes = false;
	optr = field_case;
	for (iptr = field_case; *iptr; iptr++)
	{
		char		c = *iptr;

		if (in_quotes)
		{
			if (c == '&quot;')
			{
				if (iptr[1] == '&quot;')
				{
					/* doubled quotes become a single quote */
					*optr++ = '&quot;';
					iptr++;
				}
				else
					in_quotes = false;
			}
			else
				*optr++ = c;
		}
		else if (c == '&quot;')
			in_quotes = true;
		else
		{
			c = pg_tolower((unsigned char) c);
			*optr++ = c;
		}
	}
	*optr = '\0';

	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (strcmp(field_case, res-&amp;gt;attDescs[i].name) == 0)
		{
			free(field_case);
			return i;
		}
	}
	free(field_case);
	return -1;
}

Oid
PQftable(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].tableid;
	else
		return InvalidOid;
}

int
PQftablecol(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].columnid;
	else
		return 0;
}

int
PQfformat(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].format;
	else
		return 0;
}

Oid
PQftype(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typid;
	else
		return InvalidOid;
}

int
PQfsize(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typlen;
	else
		return 0;
}

int
PQfmod(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].atttypmod;
	else
		return 0;
}

char *
PQcmdStatus(PGresult *res)
{
	if (!res)
		return NULL;
	return res-&amp;gt;cmdStatus;
}

/*
 * PQoidStatus -
 *	if the last command was an INSERT, return the oid string
 *	if not, return &quot;&quot;
 */
char *
PQoidStatus(const PGresult *res)
{
	/*
	 * This must be enough to hold the result. Don't laugh, this is better
	 * than what this function used to do.
	 */
	static char buf[24];

	size_t		len;

	if (!res || strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0)
		return &quot;&quot;;

	len = strspn(res-&amp;gt;cmdStatus + 7, &quot;0123456789&quot;);
	if (len &amp;gt; sizeof(buf) - 1)
		len = sizeof(buf) - 1;
	memcpy(buf, res-&amp;gt;cmdStatus + 7, len);
	buf[len] = '\0';

	return buf;
}

/*
 * PQoidValue -
 *	a perhaps preferable form of the above which just returns
 *	an Oid type
 */
Oid
PQoidValue(const PGresult *res)
{
	char	   *endptr = NULL;
	unsigned long result;

	if (!res ||
		strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0 ||
		res-&amp;gt;cmdStatus[7] &amp;lt; '0' ||
		res-&amp;gt;cmdStatus[7] &amp;gt; '9')
		return InvalidOid;

	result = strtoul(res-&amp;gt;cmdStatus + 7, &amp;amp;endptr, 10);

	if (!endptr || (*endptr != ' ' &amp;amp;&amp;amp; *endptr != '\0'))
		return InvalidOid;
	else
		return (Oid) result;
}


/*
 * PQcmdTuples -
 *	If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
 *	a string containing the number of inserted/affected tuples. If not,
 *	return &quot;&quot;.
 *
 *	XXX: this should probably return an int
 */
char *
PQcmdTuples(PGresult *res)
{
	char	   *p,
			   *c;

	if (!res)
		return &quot;&quot;;

	if (strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) == 0)
	{
		p = res-&amp;gt;cmdStatus + 7;
		/* INSERT: skip oid and space */
		while (*p &amp;amp;&amp;amp; *p != ' ')
			p++;
		if (*p == 0)
			goto interpret_error;		/* no space? */
		p++;
	}
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;SELECT &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;DELETE &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;UPDATE &quot;, 7) == 0)
		p = res-&amp;gt;cmdStatus + 7;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;FETCH &quot;, 6) == 0)
		p = res-&amp;gt;cmdStatus + 6;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;MOVE &quot;, 5) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;COPY &quot;, 5) == 0)
		p = res-&amp;gt;cmdStatus + 5;
	else
		return &quot;&quot;;

	/* check that we have an integer (at least one digit, nothing else) */
	for (c = p; *c; c++)
	{
		if (!isdigit((unsigned char) *c))
			goto interpret_error;
	}
	if (c == p)
		goto interpret_error;

	return p;

interpret_error:
	pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
					 &quot;could not interpret result from server: %s&quot;,
					 res-&amp;gt;cmdStatus);
	return &quot;&quot;;
}

/*
 * PQgetvalue:
 *	return the value of field 'field_num' of row 'tup_num'
 */
char *
PQgetvalue(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return NULL;
	return res-&amp;gt;tuples[tup_num][field_num].value;
}

/* PQgetlength:
 *	returns the actual length of a field value in bytes.
 */
int
PQgetlength(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 0;
	if (res-&amp;gt;tuples[tup_num][field_num].len != NULL_LEN)
		return res-&amp;gt;tuples[tup_num][field_num].len;
	else
		return 0;
}

/* PQgetisnull:
 *	returns the null status of a field value.
 */
int
PQgetisnull(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 1;				/* pretend it is null */
	if (res-&amp;gt;tuples[tup_num][field_num].len == NULL_LEN)
		return 1;
	else
		return 0;
}

/* PQnparams:
 *	returns the number of input parameters of a prepared statement.
 */
int
PQnparams(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numParameters;
}

/* PQparamtype:
 *	returns type Oid of the specified statement parameter.
 */
Oid
PQparamtype(const PGresult *res, int param_num)
{
	if (!check_param_number(res, param_num))
		return InvalidOid;
	if (res-&amp;gt;paramDescs)
		return res-&amp;gt;paramDescs[param_num].typid;
	else
		return InvalidOid;
}


/* PQsetnonblocking:
 *	sets the PGconn's database connection non-blocking if the arg is TRUE
 *	or makes it blocking if the arg is FALSE, this will not protect
 *	you from PQexec(), you'll only be safe when using the non-blocking API.
 *	Needs to be called only on a connected database connection.
 */
int
PQsetnonblocking(PGconn *conn, int arg)
{
	bool		barg;

	if (!conn || conn-&amp;gt;status == CONNECTION_BAD)
		return -1;

	barg = (arg ? TRUE : FALSE);

	/* early out if the socket is already in the state requested */
	if (barg == conn-&amp;gt;nonblocking)
		return 0;

	/*
	 * to guarantee constancy for flushing/query/result-polling behavior we
	 * need to flush the send queue at this point in order to guarantee proper
	 * behavior. this is ok because either they are making a transition _from_
	 * or _to_ blocking mode, either way we can block them.
	 */
	/* if we are going from blocking to non-blocking flush here */
	if (pqFlush(conn))
		return -1;

	conn-&amp;gt;nonblocking = barg;

	return 0;
}

/*
 * return the blocking status of the database connection
 *		TRUE == nonblocking, FALSE == blocking
 */
int
PQisnonblocking(const PGconn *conn)
{
	return pqIsnonblocking(conn);
}

/* libpq is thread-safe? */
int
PQisthreadsafe(void)
{
#ifdef ENABLE_THREAD_SAFETY
	return true;
#else
	return false;
#endif
}


/* try to force data out, really only useful for non-blocking users */
int
PQflush(PGconn *conn)
{
	return pqFlush(conn);
}


/*
 *		PQfreemem - safely frees memory allocated
 *
 * Needed mostly by Win32, unless multithreaded DLL (/MD in VC6)
 * Used for freeing memory from PQescapeByte()a/PQunescapeBytea()
 */
void
PQfreemem(void *ptr)
{
	free(ptr);
}

/*
 * PQfreeNotify - free's the memory associated with a PGnotify
 *
 * This function is here only for binary backward compatibility.
 * New code should use PQfreemem().  A macro will automatically map
 * calls to PQfreemem.  It should be removed in the future.  bjm 2003-03-24
 */

#undef PQfreeNotify
void		PQfreeNotify(PGnotify *notify);

void
PQfreeNotify(PGnotify *notify)
{
	PQfreemem(notify);
}


/*
 * Escaping arbitrary strings to get valid SQL literal strings.
 *
 * Replaces &quot;'&quot; with &quot;''&quot;, and if not std_strings, replaces &quot;\&quot; with &quot;\\&quot;.
 *
 * length is the length of the source string.  (Note: if a terminating NUL
 * is encountered sooner, PQescapeString stops short of &quot;length&quot;; the behavior
 * is thus rather like strncpy.)
 *
 * For safety the buffer at &quot;to&quot; must be at least 2*length + 1 bytes long.
 * A terminating NUL character is added to the output string, whether the
 * input is NUL-terminated or not.
 *
 * Returns the actual length of the output (not counting the terminating NUL).
 */
static size_t
PQescapeStringInternal(PGconn *conn,
					   char *to, const char *from, size_t length,
					   int *error,
					   int encoding, bool std_strings)
{
	const char *source = from;
	char	   *target = to;
	size_t		remaining = length;

	if (error)
		*error = 0;

	while (remaining &amp;gt; 0 &amp;amp;&amp;amp; *source != '\0')
	{
		char		c = *source;
		int			len;
		int			i;

		/* Fast path for plain ASCII */
		if (!IS_HIGHBIT_SET(c))
		{
			/* Apply quoting if needed */
			if (SQL_STR_DOUBLE(c, !std_strings))
				*target++ = c;
			/* Copy the character */
			*target++ = c;
			source++;
			remaining--;
			continue;
		}

		/* Slow path for possible multibyte characters */
		len = pg_encoding_mblen(encoding, source);

		/* Copy the character */
		for (i = 0; i &amp;lt; len; i++)
		{
			if (remaining == 0 || *source == '\0')
				break;
			*target++ = *source++;
			remaining--;
		}

		/*
		 * If we hit premature end of string (ie, incomplete multibyte
		 * character), try to pad out to the correct length with spaces. We
		 * may not be able to pad completely, but we will always be able to
		 * insert at least one pad space (since we'd not have quoted a
		 * multibyte character).  This should be enough to make a string that
		 * the server will error out on.
		 */
		if (i &amp;lt; len)
		{
			if (error)
				*error = 1;
			if (conn)
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
			for (; i &amp;lt; len; i++)
			{
				if (((size_t) (target - to)) / 2 &amp;gt;= length)
					break;
				*target++ = ' ';
			}
			break;
		}
	}

	/* Write the terminating NUL character. */
	*target = '\0';

	return target - to;
}

size_t
PQescapeStringConn(PGconn *conn,
				   char *to, const char *from, size_t length,
				   int *error)
{
	if (!conn)
	{
		/* force empty-string result */
		*to = '\0';
		if (error)
			*error = 1;
		return 0;
	}
	return PQescapeStringInternal(conn, to, from, length, error,
								  conn-&amp;gt;client_encoding,
								  conn-&amp;gt;std_strings);
}

size_t
PQescapeString(char *to, const char *from, size_t length)
{
	return PQescapeStringInternal(NULL, to, from, length, NULL,
								  static_client_encoding,
								  static_std_strings);
}


/*
 * Escape arbitrary strings.  If as_ident is true, we escape the result
 * as an identifier; if false, as a literal.  The result is returned in
 * a newly allocated buffer.  If we fail due to an encoding violation or out
 * of memory condition, we return NULL, storing an error message into conn.
 */
static char *
PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
{
	const char *s;
	char	   *result;
	char	   *rp;
	int			num_quotes = 0; /* single or double, depending on as_ident */
	int			num_backslashes = 0;
	int			input_len;
	int			result_size;
	char		quote_char = as_ident ? '&quot;' : '\'';

	/* We must have a connection, else fail immediately. */
	if (!conn)
		return NULL;

	/* Scan the string for characters that must be escaped. */
	for (s = str; (s - str) &amp;lt; len &amp;amp;&amp;amp; *s != '\0'; ++s)
	{
		if (*s == quote_char)
			++num_quotes;
		else if (*s == '\\')
			++num_backslashes;
		else if (IS_HIGHBIT_SET(*s))
		{
			int			charlen;

			/* Slow path for possible multibyte characters */
			charlen = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

			/* Multibyte character overruns allowable length. */
			if ((s - str) + charlen &amp;gt; len || memchr(s, 0, charlen) != NULL)
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
				return NULL;
			}

			/* Adjust s, bearing in mind that for loop will increment it. */
			s += charlen - 1;
		}
	}

	/* Allocate output buffer. */
	input_len = s - str;
	result_size = input_len + num_quotes + 3;	/* two quotes, plus a NUL */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
		result_size += num_backslashes + 2;
	result = rp = (char *) malloc(result_size);
	if (rp == NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	/*
	 * If we are escaping a literal that contains backslashes, we use the
	 * escape string syntax so that the result is correct under either value
	 * of standard_conforming_strings.  We also emit a leading space in this
	 * case, to guard against the possibility that the result might be
	 * interpolated immediately following an identifier.
	 */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
	{
		*rp++ = ' ';
		*rp++ = 'E';
	}

	/* Opening quote. */
	*rp++ = quote_char;

	/*
	 * Use fast path if possible.
	 *
	 * We've already verified that the input string is well-formed in the
	 * current encoding.  If it contains no quotes and, in the case of
	 * literal-escaping, no backslashes, then we can just copy it directly to
	 * the output buffer, adding the necessary quotes.
	 *
	 * If not, we must rescan the input and process each character
	 * individually.
	 */
	if (num_quotes == 0 &amp;amp;&amp;amp; (num_backslashes == 0 || as_ident))
	{
		memcpy(rp, str, input_len);
		rp += input_len;
	}
	else
	{
		for (s = str; s - str &amp;lt; input_len; ++s)
		{
			if (*s == quote_char || (!as_ident &amp;amp;&amp;amp; *s == '\\'))
			{
				*rp++ = *s;
				*rp++ = *s;
			}
			else if (!IS_HIGHBIT_SET(*s))
				*rp++ = *s;
			else
			{
				int			i = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

				while (1)
				{
					*rp++ = *s;
					if (--i == 0)
						break;
					++s;		/* for loop will provide the final increment */
				}
			}
		}
	}

	/* Closing quote and terminating NUL. */
	*rp++ = quote_char;
	*rp = '\0';

	return result;
}

char *
PQescapeLiteral(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, false);
}

char *
PQescapeIdentifier(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, true);
}

/* HEX encoding support for bytea */
static const char hextbl[] = &quot;0123456789abcdef&quot;;

static const int8 hexlookup[128] = {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static inline char
get_hex(char c)
{
	int			res = -1;

	if (c &amp;gt; 0 &amp;amp;&amp;amp; c &amp;lt; 127)
		res = hexlookup[(unsigned char) c];

	return (char) res;
}


/*
 *		PQescapeBytea	- converts from binary string to the
 *		minimal encoding necessary to include the string in an SQL
 *		INSERT statement with a bytea type column as the target.
 *
 *		We can use either hex or escape (traditional) encoding.
 *		In escape mode, the following transformations are applied:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == ''
 *		'\\' == ASCII 92 == \\
 *		anything &amp;lt; 0x20, or &amp;gt; 0x7e ---&amp;gt; \ooo
 *										(where ooo is an octal expression)
 *
 *		If not std_strings, all backslashes sent to the output are doubled.
 */
static unsigned char *
PQescapeByteaInternal(PGconn *conn,
					  const unsigned char *from, size_t from_length,
					  size_t *to_length, bool std_strings, bool use_hex)
{
	const unsigned char *vp;
	unsigned char *rp;
	unsigned char *result;
	size_t		i;
	size_t		len;
	size_t		bslash_len = (std_strings ? 1 : 2);

	/*
	 * empty string has 1 char ('\0')
	 */
	len = 1;

	if (use_hex)
	{
		len += bslash_len + 1 + 2 * from_length;
	}
	else
	{
		vp = from;
		for (i = from_length; i &amp;gt; 0; i--, vp++)
		{
			if (*vp &amp;lt; 0x20 || *vp &amp;gt; 0x7e)
				len += bslash_len + 3;
			else if (*vp == '\'')
				len += 2;
			else if (*vp == '\\')
				len += bslash_len + bslash_len;
			else
				len++;
		}
	}

	*to_length = len;
	rp = result = (unsigned char *) malloc(len);
	if (rp == NULL)
	{
		if (conn)
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	if (use_hex)
	{
		if (!std_strings)
			*rp++ = '\\';
		*rp++ = '\\';
		*rp++ = 'x';
	}

	vp = from;
	for (i = from_length; i &amp;gt; 0; i--, vp++)
	{
		unsigned char c = *vp;

		if (use_hex)
		{
			*rp++ = hextbl[(c &amp;gt;&amp;gt; 4) &amp;amp; 0xF];
			*rp++ = hextbl[c &amp;amp; 0xF];
		}
		else if (c &amp;lt; 0x20 || c &amp;gt; 0x7e)
		{
			if (!std_strings)
				*rp++ = '\\';
			*rp++ = '\\';
			*rp++ = (c &amp;gt;&amp;gt; 6) + '0';
			*rp++ = ((c &amp;gt;&amp;gt; 3) &amp;amp; 07) + '0';
			*rp++ = (c &amp;amp; 07) + '0';
		}
		else if (c == '\'')
		{
			*rp++ = '\'';
			*rp++ = '\'';
		}
		else if (c == '\\')
		{
			if (!std_strings)
			{
				*rp++ = '\\';
				*rp++ = '\\';
			}
			*rp++ = '\\';
			*rp++ = '\\';
		}
		else
			*rp++ = c;
	}
	*rp = '\0';

	return result;
}

unsigned char *
PQescapeByteaConn(PGconn *conn,
				  const unsigned char *from, size_t from_length,
				  size_t *to_length)
{
	if (!conn)
		return NULL;
	return PQescapeByteaInternal(conn, from, from_length, to_length,
								 conn-&amp;gt;std_strings,
								 (conn-&amp;gt;sversion &amp;gt;= 90000));
}

unsigned char *
PQescapeBytea(const unsigned char *from, size_t from_length, size_t *to_length)
{
	return PQescapeByteaInternal(NULL, from, from_length, to_length,
								 static_std_strings,
								 false /* can't use hex */ );
}


#define ISFIRSTOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '3')
#define ISOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '7')
#define OCTVAL(CH) ((CH) - '0')

/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer (or NULL on error), and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function PQfreemem.
 *
 *		The following transformations are made:
 *		\\	 == ASCII 92 == \
 *		\ooo == a byte whose value = ooo (ooo is an octal number)
 *		\x	 == x (x is any character not matched by the above transformations)
 */
unsigned char *
PQunescapeBytea(const unsigned char *strtext, size_t *retbuflen)
{
	size_t		strtextlen,
				buflen;
	unsigned char *buffer,
			   *tmpbuf;
	size_t		i,
				j;

	if (strtext == NULL)
		return NULL;

	strtextlen = strlen((const char *) strtext);

	if (strtext[0] == '\\' &amp;amp;&amp;amp; strtext[1] == 'x')
	{
		const unsigned char *s;
		unsigned char *p;

		buflen = (strtextlen - 2) / 2;
		/* Avoid unportable malloc(0) */
		buffer = (unsigned char *) malloc(buflen &amp;gt; 0 ? buflen : 1);
		if (buffer == NULL)
			return NULL;

		s = strtext + 2;
		p = buffer;
		while (*s)
		{
			char		v1,
						v2;

			/*
			 * Bad input is silently ignored.  Note that this includes
			 * whitespace between hex pairs, which is allowed by byteain.
			 */
			v1 = get_hex(*s++);
			if (!*s || v1 == (char) -1)
				continue;
			v2 = get_hex(*s++);
			if (v2 != (char) -1)
				*p++ = (v1 &amp;lt;&amp;lt; 4) | v2;
		}

		buflen = p - buffer;
	}
	else
	{
		/*
		 * Length of input is max length of output, but add one to avoid
		 * unportable malloc(0) if input is zero-length.
		 */
		buffer = (unsigned char *) malloc(strtextlen + 1);
		if (buffer == NULL)
			return NULL;

		for (i = j = 0; i &amp;lt; strtextlen;)
		{
			switch (strtext[i])
			{
				case '\\':
					i++;
					if (strtext[i] == '\\')
						buffer[j++] = strtext[i++];
					else
					{
						if ((ISFIRSTOCTDIGIT(strtext[i])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 1])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 2])))
						{
							int			byte;

							byte = OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							buffer[j++] = byte;
						}
					}

					/*
					 * Note: if we see '\' followed by something that isn't a
					 * recognized escape sequence, we loop around having done
					 * nothing except advance i.  Therefore the something will
					 * be emitted as ordinary data on the next cycle. Corner
					 * case: '\' at end of string will just be discarded.
					 */
					break;

				default:
					buffer[j++] = strtext[i++];
					break;
			}
		}
		buflen = j;				/* buflen is the length of the dequoted data */
	}

	/* Shrink the buffer to be no larger than necessary */
	/* +1 avoids unportable behavior when buflen==0 */
	tmpbuf = realloc(buffer, buflen + 1);

	/* It would only be a very brain-dead realloc that could fail, but... */
	if (!tmpbuf)
	{
		free(buffer);
		return NULL;
	}

	*retbuflen = buflen;
	return tmpbuf;
}

&lt;/pre&gt;</description>
<link>http://karlarao.tiddlyspot.com#%5B%5Bpostgresql%20source%20code%202%5D%5D</link>
<pubDate>Tue, 13 Jun 2017 20:34:00 GMT</pubDate>

</item>
<item>
<title>postgre source code</title>
<description>&lt;pre&gt;/*-------------------------------------------------------------------------
 *
 * fe-exec.c
 *	  functions related to sending a query down to the backend
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-exec.c
 *
 *-------------------------------------------------------------------------
 */
#include &quot;postgres_fe.h&quot;

#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

#include &quot;libpq-fe.h&quot;
#include &quot;libpq-int.h&quot;

#include &quot;mb/pg_wchar.h&quot;

#ifdef WIN32
#include &quot;win32.h&quot;
#else
#include &amp;lt;unistd.h&amp;gt;
#endif

/* keep this in same order as ExecStatusType in libpq-fe.h */
char	   *const pgresStatus[] = {
	&quot;PGRES_EMPTY_QUERY&quot;,
	&quot;PGRES_COMMAND_OK&quot;,
	&quot;PGRES_TUPLES_OK&quot;,
	&quot;PGRES_COPY_OUT&quot;,
	&quot;PGRES_COPY_IN&quot;,
	&quot;PGRES_BAD_RESPONSE&quot;,
	&quot;PGRES_NONFATAL_ERROR&quot;,
	&quot;PGRES_FATAL_ERROR&quot;,
	&quot;PGRES_COPY_BOTH&quot;,
	&quot;PGRES_SINGLE_TUPLE&quot;
};

/*
 * static state needed by PQescapeString and PQescapeBytea; initialize to
 * values that result in backward-compatible behavior
 */
static int	static_client_encoding = PG_SQL_ASCII;
static bool static_std_strings = false;


static PGEvent *dupEvents(PGEvent *events, int count);
static bool pqAddTuple(PGresult *res, PGresAttValue *tup);
static bool PQsendQueryStart(PGconn *conn);
static int PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat);
static void parseInput(PGconn *conn);
static PGresult *getCopyResult(PGconn *conn, ExecStatusType copytype);
static bool PQexecStart(PGconn *conn);
static PGresult *PQexecFinish(PGconn *conn);
static int PQsendDescribe(PGconn *conn, char desc_type,
			   const char *desc_target);
static int	check_field_number(const PGresult *res, int field_num);


/* ----------------
 * Space management for PGresult.
 *
 * Formerly, libpq did a separate malloc() for each field of each tuple
 * returned by a query.  This was remarkably expensive --- malloc/free
 * consumed a sizable part of the application's runtime.  And there is
 * no real need to keep track of the fields separately, since they will
 * all be freed together when the PGresult is released.  So now, we grab
 * large blocks of storage from malloc and allocate space for query data
 * within these blocks, using a trivially simple allocator.  This reduces
 * the number of malloc/free calls dramatically, and it also avoids
 * fragmentation of the malloc storage arena.
 * The PGresult structure itself is still malloc'd separately.  We could
 * combine it with the first allocation block, but that would waste space
 * for the common case that no extra storage is actually needed (that is,
 * the SQL command did not return tuples).
 *
 * We also malloc the top-level array of tuple pointers separately, because
 * we need to be able to enlarge it via realloc, and our trivial space
 * allocator doesn't handle that effectively.  (Too bad the FE/BE protocol
 * doesn't tell us up front how many tuples will be returned.)
 * All other subsidiary storage for a PGresult is kept in PGresult_data blocks
 * of size PGRESULT_DATA_BLOCKSIZE.  The overhead at the start of each block
 * is just a link to the next one, if any.  Free-space management info is
 * kept in the owning PGresult.
 * A query returning a small amount of data will thus require three malloc
 * calls: one for the PGresult, one for the tuples pointer array, and one
 * PGresult_data block.
 *
 * Only the most recently allocated PGresult_data block is a candidate to
 * have more stuff added to it --- any extra space left over in older blocks
 * is wasted.  We could be smarter and search the whole chain, but the point
 * here is to be simple and fast.  Typical applications do not keep a PGresult
 * around very long anyway, so some wasted space within one is not a problem.
 *
 * Tuning constants for the space allocator are:
 * PGRESULT_DATA_BLOCKSIZE: size of a standard allocation block, in bytes
 * PGRESULT_ALIGN_BOUNDARY: assumed alignment requirement for binary data
 * PGRESULT_SEP_ALLOC_THRESHOLD: objects bigger than this are given separate
 *	 blocks, instead of being crammed into a regular allocation block.
 * Requirements for correct function are:
 * PGRESULT_ALIGN_BOUNDARY must be a multiple of the alignment requirements
 *		of all machine data types.  (Currently this is set from configure
 *		tests, so it should be OK automatically.)
 * PGRESULT_SEP_ALLOC_THRESHOLD + PGRESULT_BLOCK_OVERHEAD &amp;lt;=
 *			PGRESULT_DATA_BLOCKSIZE
 *		pqResultAlloc assumes an object smaller than the threshold will fit
 *		in a new block.
 * The amount of space wasted at the end of a block could be as much as
 * PGRESULT_SEP_ALLOC_THRESHOLD, so it doesn't pay to make that too large.
 * ----------------
 */

#define PGRESULT_DATA_BLOCKSIZE		2048
#define PGRESULT_ALIGN_BOUNDARY		MAXIMUM_ALIGNOF		/* from configure */
#define PGRESULT_BLOCK_OVERHEAD		Max(sizeof(PGresult_data), PGRESULT_ALIGN_BOUNDARY)
#define PGRESULT_SEP_ALLOC_THRESHOLD	(PGRESULT_DATA_BLOCKSIZE / 2)


/*
 * PQmakeEmptyPGresult
 *	 returns a newly allocated, initialized PGresult with given status.
 *	 If conn is not NULL and status indicates an error, the conn's
 *	 errorMessage is copied.  Also, any PGEvents are copied from the conn.
 */
PGresult *
PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status)
{
	PGresult   *result;

	result = (PGresult *) malloc(sizeof(PGresult));
	if (!result)
		return NULL;

	result-&amp;gt;ntups = 0;
	result-&amp;gt;numAttributes = 0;
	result-&amp;gt;attDescs = NULL;
	result-&amp;gt;tuples = NULL;
	result-&amp;gt;tupArrSize = 0;
	result-&amp;gt;numParameters = 0;
	result-&amp;gt;paramDescs = NULL;
	result-&amp;gt;resultStatus = status;
	result-&amp;gt;cmdStatus[0] = '\0';
	result-&amp;gt;binary = 0;
	result-&amp;gt;events = NULL;
	result-&amp;gt;nEvents = 0;
	result-&amp;gt;errMsg = NULL;
	result-&amp;gt;errFields = NULL;
	result-&amp;gt;errQuery = NULL;
	result-&amp;gt;null_field[0] = '\0';
	result-&amp;gt;curBlock = NULL;
	result-&amp;gt;curOffset = 0;
	result-&amp;gt;spaceLeft = 0;

	if (conn)
	{
		/* copy connection data we might need for operations on PGresult */
		result-&amp;gt;noticeHooks = conn-&amp;gt;noticeHooks;
		result-&amp;gt;client_encoding = conn-&amp;gt;client_encoding;

		/* consider copying conn's errorMessage */
		switch (status)
		{
			case PGRES_EMPTY_QUERY:
			case PGRES_COMMAND_OK:
			case PGRES_TUPLES_OK:
			case PGRES_COPY_OUT:
			case PGRES_COPY_IN:
			case PGRES_COPY_BOTH:
			case PGRES_SINGLE_TUPLE:
				/* non-error cases */
				break;
			default:
				pqSetResultError(result, conn-&amp;gt;errorMessage.data);
				break;
		}

		/* copy events last; result must be valid if we need to PQclear */
		if (conn-&amp;gt;nEvents &amp;gt; 0)
		{
			result-&amp;gt;events = dupEvents(conn-&amp;gt;events, conn-&amp;gt;nEvents);
			if (!result-&amp;gt;events)
			{
				PQclear(result);
				return NULL;
			}
			result-&amp;gt;nEvents = conn-&amp;gt;nEvents;
		}
	}
	else
	{
		/* defaults... */
		result-&amp;gt;noticeHooks.noticeRec = NULL;
		result-&amp;gt;noticeHooks.noticeRecArg = NULL;
		result-&amp;gt;noticeHooks.noticeProc = NULL;
		result-&amp;gt;noticeHooks.noticeProcArg = NULL;
		result-&amp;gt;client_encoding = PG_SQL_ASCII;
	}

	return result;
}

/*
 * PQsetResultAttrs
 *
 * Set the attributes for a given result.  This function fails if there are
 * already attributes contained in the provided result.  The call is
 * ignored if numAttributes is zero or attDescs is NULL.  If the
 * function fails, it returns zero.  If the function succeeds, it
 * returns a non-zero value.
 */
int
PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs)
{
	int			i;

	/* If attrs already exist, they cannot be overwritten. */
	if (!res || res-&amp;gt;numAttributes &amp;gt; 0)
		return FALSE;

	/* ignore no-op request */
	if (numAttributes &amp;lt;= 0 || !attDescs)
		return TRUE;

	res-&amp;gt;attDescs = (PGresAttDesc *)
		PQresultAlloc(res, numAttributes * sizeof(PGresAttDesc));

	if (!res-&amp;gt;attDescs)
		return FALSE;

	res-&amp;gt;numAttributes = numAttributes;
	memcpy(res-&amp;gt;attDescs, attDescs, numAttributes * sizeof(PGresAttDesc));

	/* deep-copy the attribute names, and determine format */
	res-&amp;gt;binary = 1;
	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (res-&amp;gt;attDescs[i].name)
			res-&amp;gt;attDescs[i].name = pqResultStrdup(res, res-&amp;gt;attDescs[i].name);
		else
			res-&amp;gt;attDescs[i].name = res-&amp;gt;null_field;

		if (!res-&amp;gt;attDescs[i].name)
			return FALSE;

		if (res-&amp;gt;attDescs[i].format == 0)
			res-&amp;gt;binary = 0;
	}

	return TRUE;
}

/*
 * PQcopyResult
 *
 * Returns a deep copy of the provided 'src' PGresult, which cannot be NULL.
 * The 'flags' argument controls which portions of the result will or will
 * NOT be copied.  The created result is always put into the
 * PGRES_TUPLES_OK status.  The source result error message is not copied,
 * although cmdStatus is.
 *
 * To set custom attributes, use PQsetResultAttrs.  That function requires
 * that there are no attrs contained in the result, so to use that
 * function you cannot use the PG_COPYRES_ATTRS or PG_COPYRES_TUPLES
 * options with this function.
 *
 * Options:
 *	 PG_COPYRES_ATTRS - Copy the source result's attributes
 *
 *	 PG_COPYRES_TUPLES - Copy the source result's tuples.  This implies
 *	 copying the attrs, seeing how the attrs are needed by the tuples.
 *
 *	 PG_COPYRES_EVENTS - Copy the source result's events.
 *
 *	 PG_COPYRES_NOTICEHOOKS - Copy the source result's notice hooks.
 */
PGresult *
PQcopyResult(const PGresult *src, int flags)
{
	PGresult   *dest;
	int			i;

	if (!src)
		return NULL;

	dest = PQmakeEmptyPGresult(NULL, PGRES_TUPLES_OK);
	if (!dest)
		return NULL;

	/* Always copy these over.  Is cmdStatus really useful here? */
	dest-&amp;gt;client_encoding = src-&amp;gt;client_encoding;
	strcpy(dest-&amp;gt;cmdStatus, src-&amp;gt;cmdStatus);

	/* Wants attrs? */
	if (flags &amp;amp; (PG_COPYRES_ATTRS | PG_COPYRES_TUPLES))
	{
		if (!PQsetResultAttrs(dest, src-&amp;gt;numAttributes, src-&amp;gt;attDescs))
		{
			PQclear(dest);
			return NULL;
		}
	}

	/* Wants to copy tuples? */
	if (flags &amp;amp; PG_COPYRES_TUPLES)
	{
		int			tup,
					field;

		for (tup = 0; tup &amp;lt; src-&amp;gt;ntups; tup++)
		{
			for (field = 0; field &amp;lt; src-&amp;gt;numAttributes; field++)
			{
				if (!PQsetvalue(dest, tup, field,
								src-&amp;gt;tuples[tup][field].value,
								src-&amp;gt;tuples[tup][field].len))
				{
					PQclear(dest);
					return NULL;
				}
			}
		}
	}

	/* Wants to copy notice hooks? */
	if (flags &amp;amp; PG_COPYRES_NOTICEHOOKS)
		dest-&amp;gt;noticeHooks = src-&amp;gt;noticeHooks;

	/* Wants to copy PGEvents? */
	if ((flags &amp;amp; PG_COPYRES_EVENTS) &amp;amp;&amp;amp; src-&amp;gt;nEvents &amp;gt; 0)
	{
		dest-&amp;gt;events = dupEvents(src-&amp;gt;events, src-&amp;gt;nEvents);
		if (!dest-&amp;gt;events)
		{
			PQclear(dest);
			return NULL;
		}
		dest-&amp;gt;nEvents = src-&amp;gt;nEvents;
	}

	/* Okay, trigger PGEVT_RESULTCOPY event */
	for (i = 0; i &amp;lt; dest-&amp;gt;nEvents; i++)
	{
		if (src-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultCopy evt;

			evt.src = src;
			evt.dest = dest;
			if (!dest-&amp;gt;events[i].proc(PGEVT_RESULTCOPY, &amp;amp;evt,
									  dest-&amp;gt;events[i].passThrough))
			{
				PQclear(dest);
				return NULL;
			}
			dest-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return dest;
}

/*
 * Copy an array of PGEvents (with no extra space for more).
 * Does not duplicate the event instance data, sets this to NULL.
 * Also, the resultInitialized flags are all cleared.
 */
static PGEvent *
dupEvents(PGEvent *events, int count)
{
	PGEvent    *newEvents;
	int			i;

	if (!events || count &amp;lt;= 0)
		return NULL;

	newEvents = (PGEvent *) malloc(count * sizeof(PGEvent));
	if (!newEvents)
		return NULL;

	for (i = 0; i &amp;lt; count; i++)
	{
		newEvents[i].proc = events[i].proc;
		newEvents[i].passThrough = events[i].passThrough;
		newEvents[i].data = NULL;
		newEvents[i].resultInitialized = FALSE;
		newEvents[i].name = strdup(events[i].name);
		if (!newEvents[i].name)
		{
			while (--i &amp;gt;= 0)
				free(newEvents[i].name);
			free(newEvents);
			return NULL;
		}
	}

	return newEvents;
}


/*
 * Sets the value for a tuple field.  The tup_num must be less than or
 * equal to PQntuples(res).  If it is equal, a new tuple is created and
 * added to the result.
 * Returns a non-zero value for success and zero for failure.
 */
int
PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len)
{
	PGresAttValue *attval;

	if (!check_field_number(res, field_num))
		return FALSE;

	/* Invalid tup_num, must be &amp;lt;= ntups */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt; res-&amp;gt;ntups)
		return FALSE;

	/* need to allocate a new tuple? */
	if (tup_num == res-&amp;gt;ntups)
	{
		PGresAttValue *tup;
		int			i;

		tup = (PGresAttValue *)
			pqResultAlloc(res, res-&amp;gt;numAttributes * sizeof(PGresAttValue),
						  TRUE);

		if (!tup)
			return FALSE;

		/* initialize each column to NULL */
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
		{
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}

		/* add it to the array */
		if (!pqAddTuple(res, tup))
			return FALSE;
	}

	attval = &amp;amp;res-&amp;gt;tuples[tup_num][field_num];

	/* treat either NULL_LEN or NULL value pointer as a NULL field */
	if (len == NULL_LEN || value == NULL)
	{
		attval-&amp;gt;len = NULL_LEN;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else if (len &amp;lt;= 0)
	{
		attval-&amp;gt;len = 0;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else
	{
		attval-&amp;gt;value = (char *) pqResultAlloc(res, len + 1, TRUE);
		if (!attval-&amp;gt;value)
			return FALSE;
		attval-&amp;gt;len = len;
		memcpy(attval-&amp;gt;value, value, len);
		attval-&amp;gt;value[len] = '\0';
	}

	return TRUE;
}

/*
 * pqResultAlloc - exported routine to allocate local storage in a PGresult.
 *
 * We force all such allocations to be maxaligned, since we don't know
 * whether the value might be binary.
 */
void *
PQresultAlloc(PGresult *res, size_t nBytes)
{
	return pqResultAlloc(res, nBytes, TRUE);
}

/*
 * pqResultAlloc -
 *		Allocate subsidiary storage for a PGresult.
 *
 * nBytes is the amount of space needed for the object.
 * If isBinary is true, we assume that we need to align the object on
 * a machine allocation boundary.
 * If isBinary is false, we assume the object is a char string and can
 * be allocated on any byte boundary.
 */
void *
pqResultAlloc(PGresult *res, size_t nBytes, bool isBinary)
{
	char	   *space;
	PGresult_data *block;

	if (!res)
		return NULL;

	if (nBytes &amp;lt;= 0)
		return res-&amp;gt;null_field;

	/*
	 * If alignment is needed, round up the current position to an alignment
	 * boundary.
	 */
	if (isBinary)
	{
		int			offset = res-&amp;gt;curOffset % PGRESULT_ALIGN_BOUNDARY;

		if (offset)
		{
			res-&amp;gt;curOffset += PGRESULT_ALIGN_BOUNDARY - offset;
			res-&amp;gt;spaceLeft -= PGRESULT_ALIGN_BOUNDARY - offset;
		}
	}

	/* If there's enough space in the current block, no problem. */
	if (nBytes &amp;lt;= (size_t) res-&amp;gt;spaceLeft)
	{
		space = res-&amp;gt;curBlock-&amp;gt;space + res-&amp;gt;curOffset;
		res-&amp;gt;curOffset += nBytes;
		res-&amp;gt;spaceLeft -= nBytes;
		return space;
	}

	/*
	 * If the requested object is very large, give it its own block; this
	 * avoids wasting what might be most of the current block to start a new
	 * block.  (We'd have to special-case requests bigger than the block size
	 * anyway.)  The object is always given binary alignment in this case.
	 */
	if (nBytes &amp;gt;= PGRESULT_SEP_ALLOC_THRESHOLD)
	{
		block = (PGresult_data *) malloc(nBytes + PGRESULT_BLOCK_OVERHEAD);
		if (!block)
			return NULL;
		space = block-&amp;gt;space + PGRESULT_BLOCK_OVERHEAD;
		if (res-&amp;gt;curBlock)
		{
			/*
			 * Tuck special block below the active block, so that we don't
			 * have to waste the free space in the active block.
			 */
			block-&amp;gt;next = res-&amp;gt;curBlock-&amp;gt;next;
			res-&amp;gt;curBlock-&amp;gt;next = block;
		}
		else
		{
			/* Must set up the new block as the first active block. */
			block-&amp;gt;next = NULL;
			res-&amp;gt;curBlock = block;
			res-&amp;gt;spaceLeft = 0; /* be sure it's marked full */
		}
		return space;
	}

	/* Otherwise, start a new block. */
	block = (PGresult_data *) malloc(PGRESULT_DATA_BLOCKSIZE);
	if (!block)
		return NULL;
	block-&amp;gt;next = res-&amp;gt;curBlock;
	res-&amp;gt;curBlock = block;
	if (isBinary)
	{
		/* object needs full alignment */
		res-&amp;gt;curOffset = PGRESULT_BLOCK_OVERHEAD;
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - PGRESULT_BLOCK_OVERHEAD;
	}
	else
	{
		/* we can cram it right after the overhead pointer */
		res-&amp;gt;curOffset = sizeof(PGresult_data);
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - sizeof(PGresult_data);
	}

	space = block-&amp;gt;space + res-&amp;gt;curOffset;
	res-&amp;gt;curOffset += nBytes;
	res-&amp;gt;spaceLeft -= nBytes;
	return space;
}

/*
 * pqResultStrdup -
 *		Like strdup, but the space is subsidiary PGresult space.
 */
char *
pqResultStrdup(PGresult *res, const char *str)
{
	char	   *space = (char *) pqResultAlloc(res, strlen(str) + 1, FALSE);

	if (space)
		strcpy(space, str);
	return space;
}

/*
 * pqSetResultError -
 *		assign a new error message to a PGresult
 */
void
pqSetResultError(PGresult *res, const char *msg)
{
	if (!res)
		return;
	if (msg &amp;amp;&amp;amp; *msg)
		res-&amp;gt;errMsg = pqResultStrdup(res, msg);
	else
		res-&amp;gt;errMsg = NULL;
}

/*
 * pqCatenateResultError -
 *		concatenate a new error message to the one already in a PGresult
 */
void
pqCatenateResultError(PGresult *res, const char *msg)
{
	PQExpBufferData errorBuf;

	if (!res || !msg)
		return;
	initPQExpBuffer(&amp;amp;errorBuf);
	if (res-&amp;gt;errMsg)
		appendPQExpBufferStr(&amp;amp;errorBuf, res-&amp;gt;errMsg);
	appendPQExpBufferStr(&amp;amp;errorBuf, msg);
	pqSetResultError(res, errorBuf.data);
	termPQExpBuffer(&amp;amp;errorBuf);
}

/*
 * PQclear -
 *	  free's the memory associated with a PGresult
 */
void
PQclear(PGresult *res)
{
	PGresult_data *block;
	int			i;

	if (!res)
		return;

	for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
	{
		/* only send DESTROY to successfully-initialized event procs */
		if (res-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultDestroy evt;

			evt.result = res;
			(void) res-&amp;gt;events[i].proc(PGEVT_RESULTDESTROY, &amp;amp;evt,
									   res-&amp;gt;events[i].passThrough);
		}
		free(res-&amp;gt;events[i].name);
	}

	if (res-&amp;gt;events)
		free(res-&amp;gt;events);

	/* Free all the subsidiary blocks */
	while ((block = res-&amp;gt;curBlock) != NULL)
	{
		res-&amp;gt;curBlock = block-&amp;gt;next;
		free(block);
	}

	/* Free the top-level tuple pointer array */
	if (res-&amp;gt;tuples)
		free(res-&amp;gt;tuples);

	/* zero out the pointer fields to catch programming errors */
	res-&amp;gt;attDescs = NULL;
	res-&amp;gt;tuples = NULL;
	res-&amp;gt;paramDescs = NULL;
	res-&amp;gt;errFields = NULL;
	res-&amp;gt;events = NULL;
	res-&amp;gt;nEvents = 0;
	/* res-&amp;gt;curBlock was zeroed out earlier */

	/* Free the PGresult structure itself */
	free(res);
}

/*
 * Handy subroutine to deallocate any partially constructed async result.
 *
 * Any &quot;next&quot; result gets cleared too.
 */
void
pqClearAsyncResult(PGconn *conn)
{
	if (conn-&amp;gt;result)
		PQclear(conn-&amp;gt;result);
	conn-&amp;gt;result = NULL;
	if (conn-&amp;gt;next_result)
		PQclear(conn-&amp;gt;next_result);
	conn-&amp;gt;next_result = NULL;
}

/*
 * This subroutine deletes any existing async result, sets conn-&amp;gt;result
 * to a PGresult with status PGRES_FATAL_ERROR, and stores the current
 * contents of conn-&amp;gt;errorMessage into that result.  It differs from a
 * plain call on PQmakeEmptyPGresult() in that if there is already an
 * async result with status PGRES_FATAL_ERROR, the current error message
 * is APPENDED to the old error message instead of replacing it.  This
 * behavior lets us report multiple error conditions properly, if necessary.
 * (An example where this is needed is when the backend sends an 'E' message
 * and immediately closes the connection --- we want to report both the
 * backend error and the connection closure error.)
 */
void
pqSaveErrorResult(PGconn *conn)
{
	/*
	 * If no old async result, just let PQmakeEmptyPGresult make one. Likewise
	 * if old result is not an error message.
	 */
	if (conn-&amp;gt;result == NULL ||
		conn-&amp;gt;result-&amp;gt;resultStatus != PGRES_FATAL_ERROR ||
		conn-&amp;gt;result-&amp;gt;errMsg == NULL)
	{
		pqClearAsyncResult(conn);
		conn-&amp;gt;result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	}
	else
	{
		/* Else, concatenate error message to existing async result. */
		pqCatenateResultError(conn-&amp;gt;result, conn-&amp;gt;errorMessage.data);
	}
}

/*
 * This subroutine prepares an async result object for return to the caller.
 * If there is not already an async result object, build an error object
 * using whatever is in conn-&amp;gt;errorMessage.  In any case, clear the async
 * result storage and make sure PQerrorMessage will agree with the result's
 * error string.
 */
PGresult *
pqPrepareAsyncResult(PGconn *conn)
{
	PGresult   *res;

	/*
	 * conn-&amp;gt;result is the PGresult to return.  If it is NULL (which probably
	 * shouldn't happen) we assume there is an appropriate error message in
	 * conn-&amp;gt;errorMessage.
	 */
	res = conn-&amp;gt;result;
	if (!res)
		res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	else
	{
		/*
		 * Make sure PQerrorMessage agrees with result; it could be different
		 * if we have concatenated messages.
		 */
		resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
		appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage,
							 PQresultErrorMessage(res));
	}

	/*
	 * Replace conn-&amp;gt;result with next_result, if any.  In the normal case
	 * there isn't a next result and we're just dropping ownership of the
	 * current result.  In single-row mode this restores the situation to what
	 * it was before we created the current single-row result.
	 */
	conn-&amp;gt;result = conn-&amp;gt;next_result;
	conn-&amp;gt;next_result = NULL;

	return res;
}

/*
 * pqInternalNotice - produce an internally-generated notice message
 *
 * A format string and optional arguments can be passed.  Note that we do
 * libpq_gettext() here, so callers need not.
 *
 * The supplied text is taken as primary message (ie., it should not include
 * a trailing newline, and should not be more than one line).
 */
void
pqInternalNotice(const PGNoticeHooks *hooks, const char *fmt,...)
{
	char		msgBuf[1024];
	va_list		args;
	PGresult   *res;

	if (hooks-&amp;gt;noticeRec == NULL)
		return;					/* nobody home to receive notice? */

	/* Format the message */
	va_start(args, fmt);
	vsnprintf(msgBuf, sizeof(msgBuf), libpq_gettext(fmt), args);
	va_end(args);
	msgBuf[sizeof(msgBuf) - 1] = '\0';	/* make real sure it's terminated */

	/* Make a PGresult to pass to the notice receiver */
	res = PQmakeEmptyPGresult(NULL, PGRES_NONFATAL_ERROR);
	if (!res)
		return;
	res-&amp;gt;noticeHooks = *hooks;

	/*
	 * Set up fields of notice.
	 */
	pqSaveMessageField(res, PG_DIAG_MESSAGE_PRIMARY, msgBuf);
	pqSaveMessageField(res, PG_DIAG_SEVERITY, libpq_gettext(&quot;NOTICE&quot;));
	pqSaveMessageField(res, PG_DIAG_SEVERITY_NONLOCALIZED, &quot;NOTICE&quot;);
	/* XXX should provide a SQLSTATE too? */

	/*
	 * Result text is always just the primary message + newline. If we can't
	 * allocate it, don't bother invoking the receiver.
	 */
	res-&amp;gt;errMsg = (char *) pqResultAlloc(res, strlen(msgBuf) + 2, FALSE);
	if (res-&amp;gt;errMsg)
	{
		sprintf(res-&amp;gt;errMsg, &quot;%s\n&quot;, msgBuf);

		/*
		 * Pass to receiver, then free it.
		 */
		(*res-&amp;gt;noticeHooks.noticeRec) (res-&amp;gt;noticeHooks.noticeRecArg, res);
	}
	PQclear(res);
}

/*
 * pqAddTuple
 *	  add a row pointer to the PGresult structure, growing it if necessary
 *	  Returns TRUE if OK, FALSE if not enough memory to add the row
 */
static bool
pqAddTuple(PGresult *res, PGresAttValue *tup)
{
	if (res-&amp;gt;ntups &amp;gt;= res-&amp;gt;tupArrSize)
	{
		/*
		 * Try to grow the array.
		 *
		 * We can use realloc because shallow copying of the structure is
		 * okay. Note that the first time through, res-&amp;gt;tuples is NULL. While
		 * ANSI says that realloc() should act like malloc() in that case,
		 * some old C libraries (like SunOS 4.1.x) coredump instead. On
		 * failure realloc is supposed to return NULL without damaging the
		 * existing allocation. Note that the positions beyond res-&amp;gt;ntups are
		 * garbage, not necessarily NULL.
		 */
		int			newSize = (res-&amp;gt;tupArrSize &amp;gt; 0) ? res-&amp;gt;tupArrSize * 2 : 128;
		PGresAttValue **newTuples;

		if (res-&amp;gt;tuples == NULL)
			newTuples = (PGresAttValue **)
				malloc(newSize * sizeof(PGresAttValue *));
		else
			newTuples = (PGresAttValue **)
				realloc(res-&amp;gt;tuples, newSize * sizeof(PGresAttValue *));
		if (!newTuples)
			return FALSE;		/* malloc or realloc failed */
		res-&amp;gt;tupArrSize = newSize;
		res-&amp;gt;tuples = newTuples;
	}
	res-&amp;gt;tuples[res-&amp;gt;ntups] = tup;
	res-&amp;gt;ntups++;
	return TRUE;
}

/*
 * pqSaveMessageField - save one field of an error or notice message
 */
void
pqSaveMessageField(PGresult *res, char code, const char *value)
{
	PGMessageField *pfield;

	pfield = (PGMessageField *)
		pqResultAlloc(res,
					  offsetof(PGMessageField, contents) +
					  strlen(value) + 1,
					  TRUE);
	if (!pfield)
		return;					/* out of memory? */
	pfield-&amp;gt;code = code;
	strcpy(pfield-&amp;gt;contents, value);
	pfield-&amp;gt;next = res-&amp;gt;errFields;
	res-&amp;gt;errFields = pfield;
}

/*
 * pqSaveParameterStatus - remember parameter status sent by backend
 */
void
pqSaveParameterStatus(PGconn *conn, const char *name, const char *value)
{
	pgParameterStatus *pstatus;
	pgParameterStatus *prev;

	if (conn-&amp;gt;Pfdebug)
		fprintf(conn-&amp;gt;Pfdebug, &quot;pqSaveParameterStatus: '%s' = '%s'\n&quot;,
				name, value);

	/*
	 * Forget any old information about the parameter
	 */
	for (pstatus = conn-&amp;gt;pstatus, prev = NULL;
		 pstatus != NULL;
		 prev = pstatus, pstatus = pstatus-&amp;gt;next)
	{
		if (strcmp(pstatus-&amp;gt;name, name) == 0)
		{
			if (prev)
				prev-&amp;gt;next = pstatus-&amp;gt;next;
			else
				conn-&amp;gt;pstatus = pstatus-&amp;gt;next;
			free(pstatus);		/* frees name and value strings too */
			break;
		}
	}

	/*
	 * Store new info as a single malloc block
	 */
	pstatus = (pgParameterStatus *) malloc(sizeof(pgParameterStatus) +
										   strlen(name) +strlen(value) + 2);
	if (pstatus)
	{
		char	   *ptr;

		ptr = ((char *) pstatus) + sizeof(pgParameterStatus);
		pstatus-&amp;gt;name = ptr;
		strcpy(ptr, name);
		ptr += strlen(name) + 1;
		pstatus-&amp;gt;value = ptr;
		strcpy(ptr, value);
		pstatus-&amp;gt;next = conn-&amp;gt;pstatus;
		conn-&amp;gt;pstatus = pstatus;
	}

	/*
	 * Special hacks: remember client_encoding and
	 * standard_conforming_strings, and convert server version to a numeric
	 * form.  We keep the first two of these in static variables as well, so
	 * that PQescapeString and PQescapeBytea can behave somewhat sanely (at
	 * least in single-connection-using programs).
	 */
	if (strcmp(name, &quot;client_encoding&quot;) == 0)
	{
		conn-&amp;gt;client_encoding = pg_char_to_encoding(value);
		/* if we don't recognize the encoding name, fall back to SQL_ASCII */
		if (conn-&amp;gt;client_encoding &amp;lt; 0)
			conn-&amp;gt;client_encoding = PG_SQL_ASCII;
		static_client_encoding = conn-&amp;gt;client_encoding;
	}
	else if (strcmp(name, &quot;standard_conforming_strings&quot;) == 0)
	{
		conn-&amp;gt;std_strings = (strcmp(value, &quot;on&quot;) == 0);
		static_std_strings = conn-&amp;gt;std_strings;
	}
	else if (strcmp(name, &quot;server_version&quot;) == 0)
	{
		int			cnt;
		int			vmaj,
					vmin,
					vrev;

		cnt = sscanf(value, &quot;%d.%d.%d&quot;, &amp;amp;vmaj, &amp;amp;vmin, &amp;amp;vrev);

		if (cnt == 3)
		{
			/* old style, e.g. 9.6.1 */
			conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100 + vrev;
		}
		else if (cnt == 2)
		{
			if (vmaj &amp;gt;= 10)
			{
				/* new style, e.g. 10.1 */
				conn-&amp;gt;sversion = 100 * 100 * vmaj + vmin;
			}
			else
			{
				/* old style without minor version, e.g. 9.6devel */
				conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100;
			}
		}
		else if (cnt == 1)
		{
			/* new style without minor version, e.g. 10devel */
			conn-&amp;gt;sversion = 100 * 100 * vmaj;
		}
		else
			conn-&amp;gt;sversion = 0; /* unknown */
	}
}


/*
 * pqRowProcessor
 *	  Add the received row to the current async result (conn-&amp;gt;result).
 *	  Returns 1 if OK, 0 if error occurred.
 *
 * On error, *errmsgp can be set to an error string to be returned.
 * If it is left NULL, the error is presumed to be &quot;out of memory&quot;.
 *
 * In single-row mode, we create a new result holding just the current row,
 * stashing the previous result in conn-&amp;gt;next_result so that it becomes
 * active again after pqPrepareAsyncResult().  This allows the result metadata
 * (column descriptions) to be carried forward to each result row.
 */
int
pqRowProcessor(PGconn *conn, const char **errmsgp)
{
	PGresult   *res = conn-&amp;gt;result;
	int			nfields = res-&amp;gt;numAttributes;
	const PGdataValue *columns = conn-&amp;gt;rowBuf;
	PGresAttValue *tup;
	int			i;

	/*
	 * In single-row mode, make a new PGresult that will hold just this one
	 * row; the original conn-&amp;gt;result is left unchanged so that it can be used
	 * again as the template for future rows.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Copy everything that should be in the result at this point */
		res = PQcopyResult(res,
						   PG_COPYRES_ATTRS | PG_COPYRES_EVENTS |
						   PG_COPYRES_NOTICEHOOKS);
		if (!res)
			return 0;
	}

	/*
	 * Basically we just allocate space in the PGresult for each field and
	 * copy the data over.
	 *
	 * Note: on malloc failure, we return 0 leaving *errmsgp still NULL, which
	 * caller will take to mean &quot;out of memory&quot;.  This is preferable to trying
	 * to set up such a message here, because evidently there's not enough
	 * memory for gettext() to do anything.
	 */
	tup = (PGresAttValue *)
		pqResultAlloc(res, nfields * sizeof(PGresAttValue), TRUE);
	if (tup == NULL)
		goto fail;

	for (i = 0; i &amp;lt; nfields; i++)
	{
		int			clen = columns[i].len;

		if (clen &amp;lt; 0)
		{
			/* null field */
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}
		else
		{
			bool		isbinary = (res-&amp;gt;attDescs[i].format != 0);
			char	   *val;

			val = (char *) pqResultAlloc(res, clen + 1, isbinary);
			if (val == NULL)
				goto fail;

			/* copy and zero-terminate the data (even if it's binary) */
			memcpy(val, columns[i].value, clen);
			val[clen] = '\0';

			tup[i].len = clen;
			tup[i].value = val;
		}
	}

	/* And add the tuple to the PGresult's tuple array */
	if (!pqAddTuple(res, tup))
		goto fail;

	/*
	 * Success.  In single-row mode, make the result available to the client
	 * immediately.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Change result status to special single-row value */
		res-&amp;gt;resultStatus = PGRES_SINGLE_TUPLE;
		/* Stash old result for re-use later */
		conn-&amp;gt;next_result = conn-&amp;gt;result;
		conn-&amp;gt;result = res;
		/* And mark the result ready to return */
		conn-&amp;gt;asyncStatus = PGASYNC_READY;
	}

	return 1;

fail:
	/* release locally allocated PGresult, if we made one */
	if (res != conn-&amp;gt;result)
		PQclear(res);
	return 0;
}


/*
 * PQsendQuery
 *	 Submit a query, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendQuery(PGconn *conn, const char *query)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the argument */
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}

	/* construct the outgoing Query message */
	if (pqPutMsgStart('Q', false, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* remember we are using simple query protocol */
	conn-&amp;gt;queryclass = PGQUERY_SIMPLE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;
}

/*
 * PQsendQueryParams
 *		Like PQsendQuery, but use protocol 3.0 so we can pass parameters
 */
int
PQsendQueryParams(PGconn *conn,
				  const char *command,
				  int nParams,
				  const Oid *paramTypes,
				  const char *const * paramValues,
				  const int *paramLengths,
				  const int *paramFormats,
				  int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!command)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   command,
						   &quot;&quot;,	/* use unnamed statement */
						   nParams,
						   paramTypes,
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * PQsendPrepare
 *	 Submit a Parse message, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendPrepare(PGconn *conn,
			  const char *stmtName, const char *query,
			  int nParams, const Oid *paramTypes)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Parse message */
	if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0)
		goto sendFailed;

	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
	{
		int			i;

		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing just a Parse */
	conn-&amp;gt;queryclass = PGQUERY_PREPARE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQsendQueryPrepared
 *		Like PQsendQuery, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
int
PQsendQueryPrepared(PGconn *conn,
					const char *stmtName,
					int nParams,
					const char *const * paramValues,
					const int *paramLengths,
					const int *paramFormats,
					int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   NULL,	/* no command to parse */
						   stmtName,
						   nParams,
						   NULL,	/* no param types */
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * Common startup code for PQsendQuery and sibling routines
 */
static bool
PQsendQueryStart(PGconn *conn)
{
	if (!conn)
		return false;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Don't try to send if we know there's no live connection. */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no connection to the server\n&quot;));
		return false;
	}
	/* Can't send while already busy, either. */
	if (conn-&amp;gt;asyncStatus != PGASYNC_IDLE)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;another command is already in progress\n&quot;));
		return false;
	}

	/* initialize async result-accumulation state */
	pqClearAsyncResult(conn);

	/* reset single-row processing mode */
	conn-&amp;gt;singleRowMode = false;

	/* ready to send command message */
	return true;
}

/*
 * PQsendQueryGuts
 *		Common code for protocol-3.0 query sending
 *		PQsendQueryStart should be done already
 *
 * command may be NULL to indicate we use an already-prepared statement
 */
static int
PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat)
{
	int			i;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/*
	 * We will send Parse (if needed), Bind, Describe Portal, Execute, Sync,
	 * using specified statement name and the unnamed portal.
	 */

	if (command)
	{
		/* construct the Parse message */
		if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
			pqPuts(stmtName, conn) &amp;lt; 0 ||
			pqPuts(command, conn) &amp;lt; 0)
			goto sendFailed;
		if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
		{
			if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
				goto sendFailed;
			for (i = 0; i &amp;lt; nParams; i++)
			{
				if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
					goto sendFailed;
			}
		}
		else
		{
			if (pqPutInt(0, 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
		if (pqPutMsgEnd(conn) &amp;lt; 0)
			goto sendFailed;
	}

	/* Construct the Bind message */
	if (pqPutMsgStart('B', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameter formats */
	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramFormats)
	{
		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramFormats[i], 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}

	if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameters */
	for (i = 0; i &amp;lt; nParams; i++)
	{
		if (paramValues &amp;amp;&amp;amp; paramValues[i])
		{
			int			nbytes;

			if (paramFormats &amp;amp;&amp;amp; paramFormats[i] != 0)
			{
				/* binary parameter */
				if (paramLengths)
					nbytes = paramLengths[i];
				else
				{
					printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
									  libpq_gettext(&quot;length must be given for binary parameter\n&quot;));
					goto sendFailed;
				}
			}
			else
			{
				/* text parameter, do not use paramLengths */
				nbytes = strlen(paramValues[i]);
			}
			if (pqPutInt(nbytes, 4, conn) &amp;lt; 0 ||
				pqPutnchar(paramValues[i], nbytes, conn) &amp;lt; 0)
				goto sendFailed;
		}
		else
		{
			/* take the param as NULL */
			if (pqPutInt(-1, 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	if (pqPutInt(1, 2, conn) &amp;lt; 0 ||
		pqPutInt(resultFormat, 2, conn))
		goto sendFailed;
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Describe Portal message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc('P', conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Execute message */
	if (pqPutMsgStart('E', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutInt(0, 4, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are using extended query protocol */
	conn-&amp;gt;queryclass = PGQUERY_EXTENDED;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	if (command)
		conn-&amp;gt;last_query = strdup(command);
	else
		conn-&amp;gt;last_query = NULL;

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * pqHandleSendFailure: try to clean up after failure to send command.
 *
 * Primarily, what we want to accomplish here is to process any ERROR or
 * NOTICE messages that the backend might have sent just before it died.
 * Since we're in IDLE state, all such messages will get sent to the notice
 * processor.
 *
 * NOTE: this routine should only be called in PGASYNC_IDLE state.
 */
void
pqHandleSendFailure(PGconn *conn)
{
	/*
	 * Accept and parse any available input data, ignoring I/O errors.  Note
	 * that if pqReadData decides the backend has closed the channel, it will
	 * close our side of the socket --- that's just what we want here.
	 */
	while (pqReadData(conn) &amp;gt; 0)
		parseInput(conn);

	/*
	 * Be sure to parse available input messages even if we read no data.
	 * (Note: calling parseInput within the above loop isn't really necessary,
	 * but it prevents buffer bloat if there's a lot of data available.)
	 */
	parseInput(conn);
}

/*
 * Select row-by-row processing mode
 */
int
PQsetSingleRowMode(PGconn *conn)
{
	/*
	 * Only allow setting the flag when we have launched a query and not yet
	 * received any results.
	 */
	if (!conn)
		return 0;
	if (conn-&amp;gt;asyncStatus != PGASYNC_BUSY)
		return 0;
	if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE &amp;amp;&amp;amp;
		conn-&amp;gt;queryclass != PGQUERY_EXTENDED)
		return 0;
	if (conn-&amp;gt;result)
		return 0;

	/* OK, set flag */
	conn-&amp;gt;singleRowMode = true;
	return 1;
}

/*
 * Consume any available input from the backend
 * 0 return: some kind of trouble
 * 1 return: no problem
 */
int
PQconsumeInput(PGconn *conn)
{
	if (!conn)
		return 0;

	/*
	 * for non-blocking connections try to flush the send-queue, otherwise we
	 * may never get a response for something that may not have already been
	 * sent because it's in our write buffer!
	 */
	if (pqIsnonblocking(conn))
	{
		if (pqFlush(conn) &amp;lt; 0)
			return 0;
	}

	/*
	 * Load more data, if available. We do this no matter what state we are
	 * in, since we are probably getting called because the application wants
	 * to get rid of a read-select condition. Note that we will NOT block
	 * waiting for more input.
	 */
	if (pqReadData(conn) &amp;lt; 0)
		return 0;

	/* Parsing of the data waits till later. */
	return 1;
}


/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */
static void
parseInput(PGconn *conn)
{
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		pqParseInput3(conn);
	else
		pqParseInput2(conn);
}

/*
 * PQisBusy
 *	 Return TRUE if PQgetResult would block waiting for input.
 */

int
PQisBusy(PGconn *conn)
{
	if (!conn)
		return FALSE;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* PQgetResult will return immediately in all states except BUSY. */
	return conn-&amp;gt;asyncStatus == PGASYNC_BUSY;
}


/*
 * PQgetResult
 *	  Get the next PGresult produced by a query.  Returns NULL if no
 *	  query work remains or an error has occurred (e.g. out of
 *	  memory).
 */

PGresult *
PQgetResult(PGconn *conn)
{
	PGresult   *res;

	if (!conn)
		return NULL;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* If not ready to return something, block until we are. */
	while (conn-&amp;gt;asyncStatus == PGASYNC_BUSY)
	{
		int			flushResult;

		/*
		 * If data remains unsent, send it.  Else we might be waiting for the
		 * result of a command the backend hasn't even got yet.
		 */
		while ((flushResult = pqFlush(conn)) &amp;gt; 0)
		{
			if (pqWait(FALSE, TRUE, conn))
			{
				flushResult = -1;
				break;
			}
		}

		/* Wait for some more data, and load it. */
		if (flushResult ||
			pqWait(TRUE, FALSE, conn) ||
			pqReadData(conn) &amp;lt; 0)
		{
			/*
			 * conn-&amp;gt;errorMessage has been set by pqWait or pqReadData. We
			 * want to append it to any already-received error message.
			 */
			pqSaveErrorResult(conn);
			conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
			return pqPrepareAsyncResult(conn);
		}

		/* Parse it. */
		parseInput(conn);
	}

	/* Return the appropriate thing. */
	switch (conn-&amp;gt;asyncStatus)
	{
		case PGASYNC_IDLE:
			res = NULL;			/* query is complete */
			break;
		case PGASYNC_READY:
			res = pqPrepareAsyncResult(conn);
			/* Set the state back to BUSY, allowing parsing to proceed. */
			conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
			break;
		case PGASYNC_COPY_IN:
			res = getCopyResult(conn, PGRES_COPY_IN);
			break;
		case PGASYNC_COPY_OUT:
			res = getCopyResult(conn, PGRES_COPY_OUT);
			break;
		case PGASYNC_COPY_BOTH:
			res = getCopyResult(conn, PGRES_COPY_BOTH);
			break;
		default:
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;unexpected asyncStatus: %d\n&quot;),
							  (int) conn-&amp;gt;asyncStatus);
			res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
			break;
	}

	if (res)
	{
		int			i;

		for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
		{
			PGEventResultCreate evt;

			evt.conn = conn;
			evt.result = res;
			if (!res-&amp;gt;events[i].proc(PGEVT_RESULTCREATE, &amp;amp;evt,
									 res-&amp;gt;events[i].passThrough))
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
								  libpq_gettext(&quot;PGEventProc \&quot;%s\&quot; failed during PGEVT_RESULTCREATE event\n&quot;),
								  res-&amp;gt;events[i].name);
				pqSetResultError(res, conn-&amp;gt;errorMessage.data);
				res-&amp;gt;resultStatus = PGRES_FATAL_ERROR;
				break;
			}
			res-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return res;
}

/*
 * getCopyResult
 *	  Helper for PQgetResult: generate result for COPY-in-progress cases
 */
static PGresult *
getCopyResult(PGconn *conn, ExecStatusType copytype)
{
	/*
	 * If the server connection has been lost, don't pretend everything is
	 * hunky-dory; instead return a PGRES_FATAL_ERROR result, and reset the
	 * asyncStatus to idle (corresponding to what we'd do if we'd detected I/O
	 * error in the earlier steps in PQgetResult).  The text returned in the
	 * result is whatever is in conn-&amp;gt;errorMessage; we hope that was filled
	 * with something relevant when the lost connection was detected.
	 */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		pqSaveErrorResult(conn);
		conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
		return pqPrepareAsyncResult(conn);
	}

	/* If we have an async result for the COPY, return that */
	if (conn-&amp;gt;result &amp;amp;&amp;amp; conn-&amp;gt;result-&amp;gt;resultStatus == copytype)
		return pqPrepareAsyncResult(conn);

	/* Otherwise, invent a suitable PGresult */
	return PQmakeEmptyPGresult(conn, copytype);
}


/*
 * PQexec
 *	  send a query to the backend and package up the result in a PGresult
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQexec(PGconn *conn, const char *query)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQuery(conn, query))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecParams
 *		Like PQexec, but use protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecParams(PGconn *conn,
			 const char *command,
			 int nParams,
			 const Oid *paramTypes,
			 const char *const * paramValues,
			 const int *paramLengths,
			 const int *paramFormats,
			 int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryParams(conn, command,
						   nParams, paramTypes, paramValues, paramLengths,
						   paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQprepare
 *	  Creates a prepared statement by issuing a v3.0 parse message.
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQprepare(PGconn *conn,
		  const char *stmtName, const char *query,
		  int nParams, const Oid *paramTypes)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendPrepare(conn, stmtName, query, nParams, paramTypes))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecPrepared
 *		Like PQexec, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecPrepared(PGconn *conn,
			   const char *stmtName,
			   int nParams,
			   const char *const * paramValues,
			   const int *paramLengths,
			   const int *paramFormats,
			   int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryPrepared(conn, stmtName,
							 nParams, paramValues, paramLengths,
							 paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * Common code for PQexec and sibling routines: prepare to send command
 */
static bool
PQexecStart(PGconn *conn)
{
	PGresult   *result;

	if (!conn)
		return false;

	/*
	 * Silently discard any prior query result that application didn't eat.
	 * This is probably poor design, but it's here for backward compatibility.
	 */
	while ((result = PQgetResult(conn)) != NULL)
	{
		ExecStatusType resultStatus = result-&amp;gt;resultStatus;

		PQclear(result);		/* only need its status */
		if (resultStatus == PGRES_COPY_IN)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/* In protocol 3, we can get out of a COPY IN state */
				if (PQputCopyEnd(conn,
						 libpq_gettext(&quot;COPY terminated by new PQexec&quot;)) &amp;lt; 0)
					return false;
				/* keep waiting to swallow the copy's failure message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;COPY IN state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_OUT)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/*
				 * In protocol 3, we can get out of a COPY OUT state: we just
				 * switch back to BUSY and allow the remaining COPY data to be
				 * dropped on the floor.
				 */
				conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
				/* keep waiting to swallow the copy's completion message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				 libpq_gettext(&quot;COPY OUT state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_BOTH)
		{
			/* We don't allow PQexec during COPY BOTH */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
					 libpq_gettext(&quot;PQexec not allowed during COPY BOTH\n&quot;));
			return false;
		}
		/* check for loss of connection, too */
		if (conn-&amp;gt;status == CONNECTION_BAD)
			return false;
	}

	/* OK to send a command */
	return true;
}

/*
 * Common code for PQexec and sibling routines: wait for command result
 */
static PGresult *
PQexecFinish(PGconn *conn)
{
	PGresult   *result;
	PGresult   *lastResult;

	/*
	 * For backwards compatibility, return the last result if there are more
	 * than one --- but merge error messages if we get more than one error
	 * result.
	 *
	 * We have to stop if we see copy in/out/both, however. We will resume
	 * parsing after application performs the data transfer.
	 *
	 * Also stop if the connection is lost (else we'll loop infinitely).
	 */
	lastResult = NULL;
	while ((result = PQgetResult(conn)) != NULL)
	{
		if (lastResult)
		{
			if (lastResult-&amp;gt;resultStatus == PGRES_FATAL_ERROR &amp;amp;&amp;amp;
				result-&amp;gt;resultStatus == PGRES_FATAL_ERROR)
			{
				pqCatenateResultError(lastResult, result-&amp;gt;errMsg);
				PQclear(result);
				result = lastResult;

				/*
				 * Make sure PQerrorMessage agrees with concatenated result
				 */
				resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
				appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage, result-&amp;gt;errMsg);
			}
			else
				PQclear(lastResult);
		}
		lastResult = result;
		if (result-&amp;gt;resultStatus == PGRES_COPY_IN ||
			result-&amp;gt;resultStatus == PGRES_COPY_OUT ||
			result-&amp;gt;resultStatus == PGRES_COPY_BOTH ||
			conn-&amp;gt;status == CONNECTION_BAD)
			break;
	}

	return lastResult;
}

/*
 * PQdescribePrepared
 *	  Obtain information about a previously prepared statement
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).  On success, the PGresult contains status
 * PGRES_COMMAND_OK, and its parameter and column-heading fields describe
 * the statement's inputs and outputs respectively.
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQdescribePrepared(PGconn *conn, const char *stmt)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'S', stmt))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQdescribePortal
 *	  Obtain information about a previously created portal
 *
 * This is much like PQdescribePrepared, except that no parameter info is
 * returned.  Note that at the moment, libpq doesn't really expose portals
 * to the client; but this can be used with a portal created by a SQL
 * DECLARE CURSOR command.
 */
PGresult *
PQdescribePortal(PGconn *conn, const char *portal)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'P', portal))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQsendDescribePrepared
 *	 Submit a Describe Statement command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePrepared(PGconn *conn, const char *stmt)
{
	return PQsendDescribe(conn, 'S', stmt);
}

/*
 * PQsendDescribePortal
 *	 Submit a Describe Portal command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePortal(PGconn *conn, const char *portal)
{
	return PQsendDescribe(conn, 'P', portal);
}

/*
 * PQsendDescribe
 *	 Common code to send a Describe command
 *
 * Available options for desc_type are
 *	 'S' to describe a prepared statement; or
 *	 'P' to describe a portal.
 * Returns 1 on success and 0 on failure.
 */
static int
PQsendDescribe(PGconn *conn, char desc_type, const char *desc_target)
{
	/* Treat null desc_target as empty string */
	if (!desc_target)
		desc_target = &quot;&quot;;

	if (!PQsendQueryStart(conn))
		return 0;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Describe message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc(desc_type, conn) &amp;lt; 0 ||
		pqPuts(desc_target, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing a Describe */
	conn-&amp;gt;queryclass = PGQUERY_DESCRIBE;

	/* reset last-query string (not relevant now) */
	if (conn-&amp;gt;last_query)
	{
		free(conn-&amp;gt;last_query);
		conn-&amp;gt;last_query = NULL;
	}

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQnotifies
 *	  returns a PGnotify* structure of the latest async notification
 * that has not yet been handled
 *
 * returns NULL, if there is currently
 * no unhandled async notification from the backend
 *
 * the CALLER is responsible for FREE'ing the structure returned
 */
PGnotify *
PQnotifies(PGconn *conn)
{
	PGnotify   *event;

	if (!conn)
		return NULL;

	/* Parse any available data to see if we can extract NOTIFY messages. */
	parseInput(conn);

	event = conn-&amp;gt;notifyHead;
	if (event)
	{
		conn-&amp;gt;notifyHead = event-&amp;gt;next;
		if (!conn-&amp;gt;notifyHead)
			conn-&amp;gt;notifyTail = NULL;
		event-&amp;gt;next = NULL;		/* don't let app see the internal state */
	}
	return event;
}

/*
 * PQputCopyData - send some data to the backend during COPY IN or COPY BOTH
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyData(PGconn *conn, const char *buffer, int nbytes)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Process any NOTICE or NOTIFY messages that might be pending in the
	 * input buffer.  Since the server might generate many notices during the
	 * COPY, we want to clean those out reasonably promptly to prevent
	 * indefinite expansion of the input buffer.  (Note: the actual read of
	 * input data into the input buffer happens down inside pqSendSome, but
	 * it's not authorized to get rid of the data again.)
	 */
	parseInput(conn);

	if (nbytes &amp;gt; 0)
	{
		/*
		 * Try to flush any previously sent data in preference to growing the
		 * output buffer.  If we can't enlarge the buffer enough to hold the
		 * data, return 0 in the nonblock case, else hard error. (For
		 * simplicity, always assume 5 bytes of overhead even in protocol 2.0
		 * case.)
		 */
		if ((conn-&amp;gt;outBufSize - conn-&amp;gt;outCount - 5) &amp;lt; nbytes)
		{
			if (pqFlush(conn) &amp;lt; 0)
				return -1;
			if (pqCheckOutBufferSpace(conn-&amp;gt;outCount + 5 + (size_t) nbytes,
									  conn))
				return pqIsnonblocking(conn) ? 0 : -1;
		}
		/* Send the data (too simple to delegate to fe-protocol files) */
		if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		{
			if (pqPutMsgStart('d', false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	return 1;
}

/*
 * PQputCopyEnd - send EOF indication to the backend during COPY IN
 *
 * After calling this, use PQgetResult() to check command completion status.
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyEnd(PGconn *conn, const char *errormsg)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Send the COPY END indicator.  This is simple enough that we don't
	 * bother delegating it to the fe-protocol files.
	 */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
	{
		if (errormsg)
		{
			/* Send COPY FAIL */
			if (pqPutMsgStart('f', false, conn) &amp;lt; 0 ||
				pqPuts(errormsg, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			/* Send COPY DONE */
			if (pqPutMsgStart('c', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}

		/*
		 * If we sent the COPY command in extended-query mode, we must issue a
		 * Sync as well.
		 */
		if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE)
		{
			if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	else
	{
		if (errormsg)
		{
			/* Oops, no way to do this in 2.0 */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
			return -1;
		}
		else
		{
			/* Send old-style end-of-data marker */
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(&quot;\\.\n&quot;, 3, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}

	/* Return to active duty */
	if (conn-&amp;gt;asyncStatus == PGASYNC_COPY_BOTH)
		conn-&amp;gt;asyncStatus = PGASYNC_COPY_OUT;
	else
		conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Try to flush data */
	if (pqFlush(conn) &amp;lt; 0)
		return -1;

	return 1;
}

/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 * or COPY BOTH
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &amp;gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */
int
PQgetCopyData(PGconn *conn, char **buffer, int async)
{
	*buffer = NULL;				/* for all failure cases */
	if (!conn)
		return -2;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_OUT &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -2;
	}
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetCopyData3(conn, buffer, async);
	else
		return pqGetCopyData2(conn, buffer, async);
}

/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * Chiefly here so that applications can use &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * and read the output string.  Returns a null-terminated string in s.
 *
 * XXX this routine is now deprecated, because it can't handle binary data.
 * If called during a COPY BINARY we return EOF.
 *
 * PQgetline reads up to maxlen-1 characters (like fgets(3)) but strips
 * the terminating \n (like gets(3)).
 *
 * CAUTION: the caller is responsible for detecting the end-of-copy signal
 * (a line containing just &quot;\.&quot;) when using this routine.
 *
 * RETURNS:
 *		EOF if error (eg, invalid arguments are given)
 *		0 if EOL is reached (i.e., \n has been read)
 *				(this is required for backward-compatibility -- this
 *				 routine used to always return EOF or 0, assuming that
 *				 the line ended within maxlen bytes.)
 *		1 in other cases (i.e., the buffer was filled before \n is reached)
 */
int
PQgetline(PGconn *conn, char *s, int maxlen)
{
	if (!s || maxlen &amp;lt;= 0)
		return EOF;
	*s = '\0';
	/* maxlen must be at least 3 to hold the \. terminator! */
	if (maxlen &amp;lt; 3)
		return EOF;

	if (!conn)
		return EOF;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetline3(conn, s, maxlen);
	else
		return pqGetline2(conn, s, maxlen);
}

/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * This routine is for applications that want to do &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * asynchronously, that is without blocking.  Having issued the COPY command
 * and gotten a PGRES_COPY_OUT response, the app should call PQconsumeInput
 * and this routine until the end-of-data signal is detected.  Unlike
 * PQgetline, this routine takes responsibility for detecting end-of-data.
 *
 * On each call, PQgetlineAsync will return data if a complete data row
 * is available in libpq's input buffer.  Otherwise, no data is returned
 * until the rest of the row arrives.
 *
 * If -1 is returned, the end-of-data signal has been recognized (and removed
 * from libpq's input buffer).  The caller *must* next call PQendcopy and
 * then return to normal processing.
 *
 * RETURNS:
 *	 -1    if the end-of-copy-data marker has been recognized
 *	 0	   if no data is available
 *	 &amp;gt;0    the number of bytes returned.
 *
 * The data returned will not extend beyond a data-row boundary.  If possible
 * a whole row will be returned at one time.  But if the buffer offered by
 * the caller is too small to hold a row sent by the backend, then a partial
 * data row will be returned.  In text mode this can be detected by testing
 * whether the last returned byte is '\n' or not.
 *
 * The returned data is *not* null-terminated.
 */

int
PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)
{
	if (!conn)
		return -1;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetlineAsync3(conn, buffer, bufsize);
	else
		return pqGetlineAsync2(conn, buffer, bufsize);
}

/*
 * PQputline -- sends a string to the backend during COPY IN.
 * Returns 0 if OK, EOF if not.
 *
 * This is deprecated primarily because the return convention doesn't allow
 * caller to tell the difference between a hard error and a nonblock-mode
 * send failure.
 */
int
PQputline(PGconn *conn, const char *s)
{
	return PQputnbytes(conn, s, strlen(s));
}

/*
 * PQputnbytes -- like PQputline, but buffer need not be null-terminated.
 * Returns 0 if OK, EOF if not.
 */
int
PQputnbytes(PGconn *conn, const char *buffer, int nbytes)
{
	if (PQputCopyData(conn, buffer, nbytes) &amp;gt; 0)
		return 0;
	else
		return EOF;
}

/*
 * PQendcopy
 *		After completing the data transfer portion of a copy in/out,
 *		the application must call this routine to finish the command protocol.
 *
 * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult
 * to get the transfer status.  Note however that when using 2.0 protocol,
 * recovering from a copy failure often requires a PQreset.  PQendcopy will
 * take care of that, PQgetResult won't.
 *
 * RETURNS:
 *		0 on success
 *		1 on failure
 */
int
PQendcopy(PGconn *conn)
{
	if (!conn)
		return 0;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqEndcopy3(conn);
	else
		return pqEndcopy2(conn);
}


/* ----------------
 *		PQfn -	Send a function call to the POSTGRES backend.
 *
 *		conn			: backend connection
 *		fnid			: OID of function to be called
 *		result_buf		: pointer to result buffer
 *		result_len		: actual length of result is returned here
 *		result_is_int	: If the result is an integer, this must be 1,
 *						  otherwise this should be 0
 *		args			: pointer to an array of function arguments
 *						  (each has length, if integer, and value/pointer)
 *		nargs			: # of arguments in args array.
 *
 * RETURNS
 *		PGresult with status = PGRES_COMMAND_OK if successful.
 *			*result_len is &amp;gt; 0 if there is a return value, 0 if not.
 *		PGresult with status = PGRES_FATAL_ERROR if backend returns an error.
 *		NULL on communications failure.  conn-&amp;gt;errorMessage will be set.
 * ----------------
 */

PGresult *
PQfn(PGconn *conn,
	 int fnid,
	 int *result_buf,
	 int *result_len,
	 int result_is_int,
	 const PQArgBlock *args,
	 int nargs)
{
	*result_len = 0;

	if (!conn)
		return NULL;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	if (conn-&amp;gt;sock == PGINVALID_SOCKET || conn-&amp;gt;asyncStatus != PGASYNC_IDLE ||
		conn-&amp;gt;result != NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;connection in wrong state\n&quot;));
		return NULL;
	}

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqFunctionCall3(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
	else
		return pqFunctionCall2(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
}


/* ====== accessor funcs for PGresult ======== */

ExecStatusType
PQresultStatus(const PGresult *res)
{
	if (!res)
		return PGRES_FATAL_ERROR;
	return res-&amp;gt;resultStatus;
}

char *
PQresStatus(ExecStatusType status)
{
	if ((unsigned int) status &amp;gt;= sizeof pgresStatus / sizeof pgresStatus[0])
		return libpq_gettext(&quot;invalid ExecStatusType code&quot;);
	return pgresStatus[status];
}

char *
PQresultErrorMessage(const PGresult *res)
{
	if (!res || !res-&amp;gt;errMsg)
		return &quot;&quot;;
	return res-&amp;gt;errMsg;
}

char *
PQresultVerboseErrorMessage(const PGresult *res,
							PGVerbosity verbosity,
							PGContextVisibility show_context)
{
	PQExpBufferData workBuf;

	/*
	 * Because the caller is expected to free the result string, we must
	 * strdup any constant result.  We use plain strdup and document that
	 * callers should expect NULL if out-of-memory.
	 */
	if (!res ||
		(res-&amp;gt;resultStatus != PGRES_FATAL_ERROR &amp;amp;&amp;amp;
		 res-&amp;gt;resultStatus != PGRES_NONFATAL_ERROR))
		return strdup(libpq_gettext(&quot;PGresult is not an error result\n&quot;));

	initPQExpBuffer(&amp;amp;workBuf);

	/*
	 * Currently, we pass this off to fe-protocol3.c in all cases; it will
	 * behave reasonably sanely with an error reported by fe-protocol2.c as
	 * well.  If necessary, we could record the protocol version in PGresults
	 * so as to be able to invoke a version-specific message formatter, but
	 * for now there's no need.
	 */
	pqBuildErrorMessage3(&amp;amp;workBuf, res, verbosity, show_context);

	/* If insufficient memory to format the message, fail cleanly */
	if (PQExpBufferDataBroken(workBuf))
	{
		termPQExpBuffer(&amp;amp;workBuf);
		return strdup(libpq_gettext(&quot;out of memory\n&quot;));
	}

	return workBuf.data;
}

char *
PQresultErrorField(const PGresult *res, int fieldcode)
{
	PGMessageField *pfield;

	if (!res)
		return NULL;
	for (pfield = res-&amp;gt;errFields; pfield != NULL; pfield = pfield-&amp;gt;next)
	{
		if (pfield-&amp;gt;code == fieldcode)
			return pfield-&amp;gt;contents;
	}
	return NULL;
}

int
PQntuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;ntups;
}

int
PQnfields(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numAttributes;
}

int
PQbinaryTuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;binary;
}

/*
 * Helper routines to range-check field numbers and tuple numbers.
 * Return TRUE if OK, FALSE if not
 */

static int
check_field_number(const PGresult *res, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_tuple_field_number(const PGresult *res,
						 int tup_num, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt;= res-&amp;gt;ntups)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;row number %d is out of range 0..%d&quot;,
						 tup_num, res-&amp;gt;ntups - 1);
		return FALSE;
	}
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_param_number(const PGresult *res, int param_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (param_num &amp;lt; 0 || param_num &amp;gt;= res-&amp;gt;numParameters)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;parameter number %d is out of range 0..%d&quot;,
						 param_num, res-&amp;gt;numParameters - 1);
		return FALSE;
	}

	return TRUE;
}

/*
 * returns NULL if the field_num is invalid
 */
char *
PQfname(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return NULL;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].name;
	else
		return NULL;
}

/*
 * PQfnumber: find column number given column name
 *
 * The column name is parsed as if it were in a SQL statement, including
 * case-folding and double-quote processing.  But note a possible gotcha:
 * downcasing in the frontend might follow different locale rules than
 * downcasing in the backend...
 *
 * Returns -1 if no match.  In the present backend it is also possible
 * to have multiple matches, in which case the first one is found.
 */
int
PQfnumber(const PGresult *res, const char *field_name)
{
	char	   *field_case;
	bool		in_quotes;
	bool		all_lower = true;
	const char *iptr;
	char	   *optr;
	int			i;

	if (!res)
		return -1;

	/*
	 * Note: it is correct to reject a zero-length input string; the proper
	 * input to match a zero-length field name would be &quot;&quot;.
	 */
	if (field_name == NULL ||
		field_name[0] == '\0' ||
		res-&amp;gt;attDescs == NULL)
		return -1;

	/*
	 * Check if we can avoid the strdup() and related work because the
	 * passed-in string wouldn't be changed before we do the check anyway.
	 */
	for (iptr = field_name; *iptr; iptr++)
	{
		char		c = *iptr;

		if (c == '&quot;' || c != pg_tolower((unsigned char) c))
		{
			all_lower = false;
			break;
		}
	}

	if (all_lower)
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
			if (strcmp(field_name, res-&amp;gt;attDescs[i].name) == 0)
				return i;

	/* Fall through to the normal check if that didn't work out. */

	/*
	 * Note: this code will not reject partially quoted strings, eg
	 * foo&quot;BAR&quot;foo will become fooBARfoo when it probably ought to be an error
	 * condition.
	 */
	field_case = strdup(field_name);
	if (field_case == NULL)
		return -1;				/* grotty */

	in_quotes = false;
	optr = field_case;
	for (iptr = field_case; *iptr; iptr++)
	{
		char		c = *iptr;

		if (in_quotes)
		{
			if (c == '&quot;')
			{
				if (iptr[1] == '&quot;')
				{
					/* doubled quotes become a single quote */
					*optr++ = '&quot;';
					iptr++;
				}
				else
					in_quotes = false;
			}
			else
				*optr++ = c;
		}
		else if (c == '&quot;')
			in_quotes = true;
		else
		{
			c = pg_tolower((unsigned char) c);
			*optr++ = c;
		}
	}
	*optr = '\0';

	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (strcmp(field_case, res-&amp;gt;attDescs[i].name) == 0)
		{
			free(field_case);
			return i;
		}
	}
	free(field_case);
	return -1;
}

Oid
PQftable(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].tableid;
	else
		return InvalidOid;
}

int
PQftablecol(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].columnid;
	else
		return 0;
}

int
PQfformat(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].format;
	else
		return 0;
}

Oid
PQftype(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typid;
	else
		return InvalidOid;
}

int
PQfsize(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typlen;
	else
		return 0;
}

int
PQfmod(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].atttypmod;
	else
		return 0;
}

char *
PQcmdStatus(PGresult *res)
{
	if (!res)
		return NULL;
	return res-&amp;gt;cmdStatus;
}

/*
 * PQoidStatus -
 *	if the last command was an INSERT, return the oid string
 *	if not, return &quot;&quot;
 */
char *
PQoidStatus(const PGresult *res)
{
	/*
	 * This must be enough to hold the result. Don't laugh, this is better
	 * than what this function used to do.
	 */
	static char buf[24];

	size_t		len;

	if (!res || strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0)
		return &quot;&quot;;

	len = strspn(res-&amp;gt;cmdStatus + 7, &quot;0123456789&quot;);
	if (len &amp;gt; sizeof(buf) - 1)
		len = sizeof(buf) - 1;
	memcpy(buf, res-&amp;gt;cmdStatus + 7, len);
	buf[len] = '\0';

	return buf;
}

/*
 * PQoidValue -
 *	a perhaps preferable form of the above which just returns
 *	an Oid type
 */
Oid
PQoidValue(const PGresult *res)
{
	char	   *endptr = NULL;
	unsigned long result;

	if (!res ||
		strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0 ||
		res-&amp;gt;cmdStatus[7] &amp;lt; '0' ||
		res-&amp;gt;cmdStatus[7] &amp;gt; '9')
		return InvalidOid;

	result = strtoul(res-&amp;gt;cmdStatus + 7, &amp;amp;endptr, 10);

	if (!endptr || (*endptr != ' ' &amp;amp;&amp;amp; *endptr != '\0'))
		return InvalidOid;
	else
		return (Oid) result;
}


/*
 * PQcmdTuples -
 *	If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
 *	a string containing the number of inserted/affected tuples. If not,
 *	return &quot;&quot;.
 *
 *	XXX: this should probably return an int
 */
char *
PQcmdTuples(PGresult *res)
{
	char	   *p,
			   *c;

	if (!res)
		return &quot;&quot;;

	if (strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) == 0)
	{
		p = res-&amp;gt;cmdStatus + 7;
		/* INSERT: skip oid and space */
		while (*p &amp;amp;&amp;amp; *p != ' ')
			p++;
		if (*p == 0)
			goto interpret_error;		/* no space? */
		p++;
	}
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;SELECT &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;DELETE &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;UPDATE &quot;, 7) == 0)
		p = res-&amp;gt;cmdStatus + 7;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;FETCH &quot;, 6) == 0)
		p = res-&amp;gt;cmdStatus + 6;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;MOVE &quot;, 5) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;COPY &quot;, 5) == 0)
		p = res-&amp;gt;cmdStatus + 5;
	else
		return &quot;&quot;;

	/* check that we have an integer (at least one digit, nothing else) */
	for (c = p; *c; c++)
	{
		if (!isdigit((unsigned char) *c))
			goto interpret_error;
	}
	if (c == p)
		goto interpret_error;

	return p;

interpret_error:
	pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
					 &quot;could not interpret result from server: %s&quot;,
					 res-&amp;gt;cmdStatus);
	return &quot;&quot;;
}

/*
 * PQgetvalue:
 *	return the value of field 'field_num' of row 'tup_num'
 */
char *
PQgetvalue(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return NULL;
	return res-&amp;gt;tuples[tup_num][field_num].value;
}

/* PQgetlength:
 *	returns the actual length of a field value in bytes.
 */
int
PQgetlength(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 0;
	if (res-&amp;gt;tuples[tup_num][field_num].len != NULL_LEN)
		return res-&amp;gt;tuples[tup_num][field_num].len;
	else
		return 0;
}

/* PQgetisnull:
 *	returns the null status of a field value.
 */
int
PQgetisnull(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 1;				/* pretend it is null */
	if (res-&amp;gt;tuples[tup_num][field_num].len == NULL_LEN)
		return 1;
	else
		return 0;
}

/* PQnparams:
 *	returns the number of input parameters of a prepared statement.
 */
int
PQnparams(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numParameters;
}

/* PQparamtype:
 *	returns type Oid of the specified statement parameter.
 */
Oid
PQparamtype(const PGresult *res, int param_num)
{
	if (!check_param_number(res, param_num))
		return InvalidOid;
	if (res-&amp;gt;paramDescs)
		return res-&amp;gt;paramDescs[param_num].typid;
	else
		return InvalidOid;
}


/* PQsetnonblocking:
 *	sets the PGconn's database connection non-blocking if the arg is TRUE
 *	or makes it blocking if the arg is FALSE, this will not protect
 *	you from PQexec(), you'll only be safe when using the non-blocking API.
 *	Needs to be called only on a connected database connection.
 */
int
PQsetnonblocking(PGconn *conn, int arg)
{
	bool		barg;

	if (!conn || conn-&amp;gt;status == CONNECTION_BAD)
		return -1;

	barg = (arg ? TRUE : FALSE);

	/* early out if the socket is already in the state requested */
	if (barg == conn-&amp;gt;nonblocking)
		return 0;

	/*
	 * to guarantee constancy for flushing/query/result-polling behavior we
	 * need to flush the send queue at this point in order to guarantee proper
	 * behavior. this is ok because either they are making a transition _from_
	 * or _to_ blocking mode, either way we can block them.
	 */
	/* if we are going from blocking to non-blocking flush here */
	if (pqFlush(conn))
		return -1;

	conn-&amp;gt;nonblocking = barg;

	return 0;
}

/*
 * return the blocking status of the database connection
 *		TRUE == nonblocking, FALSE == blocking
 */
int
PQisnonblocking(const PGconn *conn)
{
	return pqIsnonblocking(conn);
}

/* libpq is thread-safe? */
int
PQisthreadsafe(void)
{
#ifdef ENABLE_THREAD_SAFETY
	return true;
#else
	return false;
#endif
}


/* try to force data out, really only useful for non-blocking users */
int
PQflush(PGconn *conn)
{
	return pqFlush(conn);
}


/*
 *		PQfreemem - safely frees memory allocated
 *
 * Needed mostly by Win32, unless multithreaded DLL (/MD in VC6)
 * Used for freeing memory from PQescapeByte()a/PQunescapeBytea()
 */
void
PQfreemem(void *ptr)
{
	free(ptr);
}

/*
 * PQfreeNotify - free's the memory associated with a PGnotify
 *
 * This function is here only for binary backward compatibility.
 * New code should use PQfreemem().  A macro will automatically map
 * calls to PQfreemem.  It should be removed in the future.  bjm 2003-03-24
 */

#undef PQfreeNotify
void		PQfreeNotify(PGnotify *notify);

void
PQfreeNotify(PGnotify *notify)
{
	PQfreemem(notify);
}


/*
 * Escaping arbitrary strings to get valid SQL literal strings.
 *
 * Replaces &quot;'&quot; with &quot;''&quot;, and if not std_strings, replaces &quot;\&quot; with &quot;\\&quot;.
 *
 * length is the length of the source string.  (Note: if a terminating NUL
 * is encountered sooner, PQescapeString stops short of &quot;length&quot;; the behavior
 * is thus rather like strncpy.)
 *
 * For safety the buffer at &quot;to&quot; must be at least 2*length + 1 bytes long.
 * A terminating NUL character is added to the output string, whether the
 * input is NUL-terminated or not.
 *
 * Returns the actual length of the output (not counting the terminating NUL).
 */
static size_t
PQescapeStringInternal(PGconn *conn,
					   char *to, const char *from, size_t length,
					   int *error,
					   int encoding, bool std_strings)
{
	const char *source = from;
	char	   *target = to;
	size_t		remaining = length;

	if (error)
		*error = 0;

	while (remaining &amp;gt; 0 &amp;amp;&amp;amp; *source != '\0')
	{
		char		c = *source;
		int			len;
		int			i;

		/* Fast path for plain ASCII */
		if (!IS_HIGHBIT_SET(c))
		{
			/* Apply quoting if needed */
			if (SQL_STR_DOUBLE(c, !std_strings))
				*target++ = c;
			/* Copy the character */
			*target++ = c;
			source++;
			remaining--;
			continue;
		}

		/* Slow path for possible multibyte characters */
		len = pg_encoding_mblen(encoding, source);

		/* Copy the character */
		for (i = 0; i &amp;lt; len; i++)
		{
			if (remaining == 0 || *source == '\0')
				break;
			*target++ = *source++;
			remaining--;
		}

		/*
		 * If we hit premature end of string (ie, incomplete multibyte
		 * character), try to pad out to the correct length with spaces. We
		 * may not be able to pad completely, but we will always be able to
		 * insert at least one pad space (since we'd not have quoted a
		 * multibyte character).  This should be enough to make a string that
		 * the server will error out on.
		 */
		if (i &amp;lt; len)
		{
			if (error)
				*error = 1;
			if (conn)
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
			for (; i &amp;lt; len; i++)
			{
				if (((size_t) (target - to)) / 2 &amp;gt;= length)
					break;
				*target++ = ' ';
			}
			break;
		}
	}

	/* Write the terminating NUL character. */
	*target = '\0';

	return target - to;
}

size_t
PQescapeStringConn(PGconn *conn,
				   char *to, const char *from, size_t length,
				   int *error)
{
	if (!conn)
	{
		/* force empty-string result */
		*to = '\0';
		if (error)
			*error = 1;
		return 0;
	}
	return PQescapeStringInternal(conn, to, from, length, error,
								  conn-&amp;gt;client_encoding,
								  conn-&amp;gt;std_strings);
}

size_t
PQescapeString(char *to, const char *from, size_t length)
{
	return PQescapeStringInternal(NULL, to, from, length, NULL,
								  static_client_encoding,
								  static_std_strings);
}


/*
 * Escape arbitrary strings.  If as_ident is true, we escape the result
 * as an identifier; if false, as a literal.  The result is returned in
 * a newly allocated buffer.  If we fail due to an encoding violation or out
 * of memory condition, we return NULL, storing an error message into conn.
 */
static char *
PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
{
	const char *s;
	char	   *result;
	char	   *rp;
	int			num_quotes = 0; /* single or double, depending on as_ident */
	int			num_backslashes = 0;
	int			input_len;
	int			result_size;
	char		quote_char = as_ident ? '&quot;' : '\'';

	/* We must have a connection, else fail immediately. */
	if (!conn)
		return NULL;

	/* Scan the string for characters that must be escaped. */
	for (s = str; (s - str) &amp;lt; len &amp;amp;&amp;amp; *s != '\0'; ++s)
	{
		if (*s == quote_char)
			++num_quotes;
		else if (*s == '\\')
			++num_backslashes;
		else if (IS_HIGHBIT_SET(*s))
		{
			int			charlen;

			/* Slow path for possible multibyte characters */
			charlen = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

			/* Multibyte character overruns allowable length. */
			if ((s - str) + charlen &amp;gt; len || memchr(s, 0, charlen) != NULL)
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
				return NULL;
			}

			/* Adjust s, bearing in mind that for loop will increment it. */
			s += charlen - 1;
		}
	}

	/* Allocate output buffer. */
	input_len = s - str;
	result_size = input_len + num_quotes + 3;	/* two quotes, plus a NUL */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
		result_size += num_backslashes + 2;
	result = rp = (char *) malloc(result_size);
	if (rp == NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	/*
	 * If we are escaping a literal that contains backslashes, we use the
	 * escape string syntax so that the result is correct under either value
	 * of standard_conforming_strings.  We also emit a leading space in this
	 * case, to guard against the possibility that the result might be
	 * interpolated immediately following an identifier.
	 */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
	{
		*rp++ = ' ';
		*rp++ = 'E';
	}

	/* Opening quote. */
	*rp++ = quote_char;

	/*
	 * Use fast path if possible.
	 *
	 * We've already verified that the input string is well-formed in the
	 * current encoding.  If it contains no quotes and, in the case of
	 * literal-escaping, no backslashes, then we can just copy it directly to
	 * the output buffer, adding the necessary quotes.
	 *
	 * If not, we must rescan the input and process each character
	 * individually.
	 */
	if (num_quotes == 0 &amp;amp;&amp;amp; (num_backslashes == 0 || as_ident))
	{
		memcpy(rp, str, input_len);
		rp += input_len;
	}
	else
	{
		for (s = str; s - str &amp;lt; input_len; ++s)
		{
			if (*s == quote_char || (!as_ident &amp;amp;&amp;amp; *s == '\\'))
			{
				*rp++ = *s;
				*rp++ = *s;
			}
			else if (!IS_HIGHBIT_SET(*s))
				*rp++ = *s;
			else
			{
				int			i = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

				while (1)
				{
					*rp++ = *s;
					if (--i == 0)
						break;
					++s;		/* for loop will provide the final increment */
				}
			}
		}
	}

	/* Closing quote and terminating NUL. */
	*rp++ = quote_char;
	*rp = '\0';

	return result;
}

char *
PQescapeLiteral(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, false);
}

char *
PQescapeIdentifier(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, true);
}

/* HEX encoding support for bytea */
static const char hextbl[] = &quot;0123456789abcdef&quot;;

static const int8 hexlookup[128] = {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static inline char
get_hex(char c)
{
	int			res = -1;

	if (c &amp;gt; 0 &amp;amp;&amp;amp; c &amp;lt; 127)
		res = hexlookup[(unsigned char) c];

	return (char) res;
}


/*
 *		PQescapeBytea	- converts from binary string to the
 *		minimal encoding necessary to include the string in an SQL
 *		INSERT statement with a bytea type column as the target.
 *
 *		We can use either hex or escape (traditional) encoding.
 *		In escape mode, the following transformations are applied:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == ''
 *		'\\' == ASCII 92 == \\
 *		anything &amp;lt; 0x20, or &amp;gt; 0x7e ---&amp;gt; \ooo
 *										(where ooo is an octal expression)
 *
 *		If not std_strings, all backslashes sent to the output are doubled.
 */
static unsigned char *
PQescapeByteaInternal(PGconn *conn,
					  const unsigned char *from, size_t from_length,
					  size_t *to_length, bool std_strings, bool use_hex)
{
	const unsigned char *vp;
	unsigned char *rp;
	unsigned char *result;
	size_t		i;
	size_t		len;
	size_t		bslash_len = (std_strings ? 1 : 2);

	/*
	 * empty string has 1 char ('\0')
	 */
	len = 1;

	if (use_hex)
	{
		len += bslash_len + 1 + 2 * from_length;
	}
	else
	{
		vp = from;
		for (i = from_length; i &amp;gt; 0; i--, vp++)
		{
			if (*vp &amp;lt; 0x20 || *vp &amp;gt; 0x7e)
				len += bslash_len + 3;
			else if (*vp == '\'')
				len += 2;
			else if (*vp == '\\')
				len += bslash_len + bslash_len;
			else
				len++;
		}
	}

	*to_length = len;
	rp = result = (unsigned char *) malloc(len);
	if (rp == NULL)
	{
		if (conn)
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	if (use_hex)
	{
		if (!std_strings)
			*rp++ = '\\';
		*rp++ = '\\';
		*rp++ = 'x';
	}

	vp = from;
	for (i = from_length; i &amp;gt; 0; i--, vp++)
	{
		unsigned char c = *vp;

		if (use_hex)
		{
			*rp++ = hextbl[(c &amp;gt;&amp;gt; 4) &amp;amp; 0xF];
			*rp++ = hextbl[c &amp;amp; 0xF];
		}
		else if (c &amp;lt; 0x20 || c &amp;gt; 0x7e)
		{
			if (!std_strings)
				*rp++ = '\\';
			*rp++ = '\\';
			*rp++ = (c &amp;gt;&amp;gt; 6) + '0';
			*rp++ = ((c &amp;gt;&amp;gt; 3) &amp;amp; 07) + '0';
			*rp++ = (c &amp;amp; 07) + '0';
		}
		else if (c == '\'')
		{
			*rp++ = '\'';
			*rp++ = '\'';
		}
		else if (c == '\\')
		{
			if (!std_strings)
			{
				*rp++ = '\\';
				*rp++ = '\\';
			}
			*rp++ = '\\';
			*rp++ = '\\';
		}
		else
			*rp++ = c;
	}
	*rp = '\0';

	return result;
}

unsigned char *
PQescapeByteaConn(PGconn *conn,
				  const unsigned char *from, size_t from_length,
				  size_t *to_length)
{
	if (!conn)
		return NULL;
	return PQescapeByteaInternal(conn, from, from_length, to_length,
								 conn-&amp;gt;std_strings,
								 (conn-&amp;gt;sversion &amp;gt;= 90000));
}

unsigned char *
PQescapeBytea(const unsigned char *from, size_t from_length, size_t *to_length)
{
	return PQescapeByteaInternal(NULL, from, from_length, to_length,
								 static_std_strings,
								 false /* can't use hex */ );
}


#define ISFIRSTOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '3')
#define ISOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '7')
#define OCTVAL(CH) ((CH) - '0')

/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer (or NULL on error), and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function PQfreemem.
 *
 *		The following transformations are made:
 *		\\	 == ASCII 92 == \
 *		\ooo == a byte whose value = ooo (ooo is an octal number)
 *		\x	 == x (x is any character not matched by the above transformations)
 */
unsigned char *
PQunescapeBytea(const unsigned char *strtext, size_t *retbuflen)
{
	size_t		strtextlen,
				buflen;
	unsigned char *buffer,
			   *tmpbuf;
	size_t		i,
				j;

	if (strtext == NULL)
		return NULL;

	strtextlen = strlen((const char *) strtext);

	if (strtext[0] == '\\' &amp;amp;&amp;amp; strtext[1] == 'x')
	{
		const unsigned char *s;
		unsigned char *p;

		buflen = (strtextlen - 2) / 2;
		/* Avoid unportable malloc(0) */
		buffer = (unsigned char *) malloc(buflen &amp;gt; 0 ? buflen : 1);
		if (buffer == NULL)
			return NULL;

		s = strtext + 2;
		p = buffer;
		while (*s)
		{
			char		v1,
						v2;

			/*
			 * Bad input is silently ignored.  Note that this includes
			 * whitespace between hex pairs, which is allowed by byteain.
			 */
			v1 = get_hex(*s++);
			if (!*s || v1 == (char) -1)
				continue;
			v2 = get_hex(*s++);
			if (v2 != (char) -1)
				*p++ = (v1 &amp;lt;&amp;lt; 4) | v2;
		}

		buflen = p - buffer;
	}
	else
	{
		/*
		 * Length of input is max length of output, but add one to avoid
		 * unportable malloc(0) if input is zero-length.
		 */
		buffer = (unsigned char *) malloc(strtextlen + 1);
		if (buffer == NULL)
			return NULL;

		for (i = j = 0; i &amp;lt; strtextlen;)
		{
			switch (strtext[i])
			{
				case '\\':
					i++;
					if (strtext[i] == '\\')
						buffer[j++] = strtext[i++];
					else
					{
						if ((ISFIRSTOCTDIGIT(strtext[i])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 1])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 2])))
						{
							int			byte;

							byte = OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							buffer[j++] = byte;
						}
					}

					/*
					 * Note: if we see '\' followed by something that isn't a
					 * recognized escape sequence, we loop around having done
					 * nothing except advance i.  Therefore the something will
					 * be emitted as ordinary data on the next cycle. Corner
					 * case: '\' at end of string will just be discarded.
					 */
					break;

				default:
					buffer[j++] = strtext[i++];
					break;
			}
		}
		buflen = j;				/* buflen is the length of the dequoted data */
	}

	/* Shrink the buffer to be no larger than necessary */
	/* +1 avoids unportable behavior when buflen==0 */
	tmpbuf = realloc(buffer, buflen + 1);

	/* It would only be a very brain-dead realloc that could fail, but... */
	if (!tmpbuf)
	{
		free(buffer);
		return NULL;
	}

	*retbuflen = buflen;
	return tmpbuf;
}
&lt;/pre&gt;</description>
<category>Performance Hub report</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bpostgre%20source%20code%5D%5D</link>
<pubDate>Tue, 13 Jun 2017 20:31:00 GMT</pubDate>

</item>
<item>
<title>Performance Hub report</title>
<description>&lt;pre&gt;New interacUve report for analyzing AWR data 
* Performance Hub report generated from SQL*Plus  
* @$ORACLE_HOME/rdbms/admin/perfubrpt.sql 
* OR calling dbms_perf.report_perfub(….) function 
* Single view of DB performance 
* ADDM, SQL Tuning, Real-Time SQL Monitoring, ASH AnalyUcs  
* Switch between ASH analyUcs, workload view, ADDM findings and SQL monitoring seamlessly 
* Supports both real-Ume &amp;amp; historical mode 
* Historical view of SQL Monitoring reports 
&lt;/pre&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.oracle.com/technetwork/oem/db-mgmt/con8450-sqltuning-expertspanel-2338901.pdf&quot; href=&quot;http://www.oracle.com/technetwork/oem/db-mgmt/con8450-sqltuning-expertspanel-2338901.pdf&quot; class=&quot;externalLink&quot;&gt;http://www.oracle.com/technetwork/oem/db-mgmt/con8450-sqltuning-expertspanel-2338901.pdf&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;&lt;a tiddlylink=&quot;DBMS_PERF&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#DBMS_PERF&quot; href=&quot;http://karlarao.tiddlyspot.com#DBMS_PERF&quot; class=&quot;externalLink null&quot;&gt;DBMS_PERF&lt;/a&gt;&lt;/strong&gt; &lt;a target=&quot;_blank&quot; title=&quot;External link to http://docs.oracle.com/database/121/ARPLS/d_perf.htm#ARPLS75006&quot; href=&quot;http://docs.oracle.com/database/121/ARPLS/d_perf.htm#ARPLS75006&quot; class=&quot;externalLink&quot;&gt;http://docs.oracle.com/database/121/ARPLS/d_perf.htm#ARPLS75006&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Oracle Database 12c: EM Express Performance Hub&lt;/strong&gt; &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.oracle.com/technetwork/database/manageability/emx-perfhub-1970118.html&quot; href=&quot;http://www.oracle.com/technetwork/database/manageability/emx-perfhub-1970118.html&quot; class=&quot;externalLink&quot;&gt;http://www.oracle.com/technetwork/database/manageability/emx-perfhub-1970118.html&lt;/a&gt;&lt;br&gt;&lt;strong&gt;Oracle Database 12c: EM Express Active Reports&lt;/strong&gt; &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.oracle.com/technetwork/database/manageability/emx-activerep-1970119.html&quot; href=&quot;http://www.oracle.com/technetwork/database/manageability/emx-activerep-1970119.html&quot; class=&quot;externalLink&quot;&gt;http://www.oracle.com/technetwork/database/manageability/emx-activerep-1970119.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; usage&lt;/h1&gt;RDBMS 12.1.0.2 &amp;amp; Cell 12.1.2.1.0 exposes detailed Exadata statistics on historical perfhub report &lt;a target=&quot;_blank&quot; title=&quot;External link to https://twitter.com/karlarao/status/573025645254479872&quot; href=&quot;https://twitter.com/karlarao/status/573025645254479872&quot; class=&quot;externalLink&quot;&gt;https://twitter.com/karlarao/status/573025645254479872&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;pre&gt;
-- active
set pages 0 linesize 32767 trimspool on trim on long 1000000 longchunksize 10000000
spool perfhub_active.html
select dbms_perf.report_perfhub(is_realtime=&amp;gt;1,type=&amp;gt;'active') from dual;
spool off

-- historical
set pages 0 linesize 32767 trimspool on trim on long 1000000 longchunksize 10000000
spool perfhub_active2.html
select dbms_perf.report_perfhub(is_realtime=&amp;gt;0,type=&amp;gt;'active') from dual;
spool off

-- historical, without explicitly specifying the &quot;type&quot;
set pages 0 linesize 32767 trimspool on trim on long 1000000 longchunksize 10000000
spool perfhub_active3.html
select dbms_perf.report_perfhub(is_realtime=&amp;gt;0) from dual;
spool off

&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; 11.2.0.4 vs 12c &lt;/h1&gt;&lt;strong&gt;11204&lt;/strong&gt;&lt;br&gt;&lt;pre&gt;Specify the Report Type
~~~~~~~~~~~~~~~~~~~~~~~
Would you like an HTML report, or a plain text report?
Enter 'html' for an HTML report, or 'text' for plain text
Defaults to 'html'
Enter value for report_type: html
&lt;/pre&gt;&lt;strong&gt;12c&lt;/strong&gt;&lt;br&gt;&lt;pre&gt;Specify the Report Type
~~~~~~~~~~~~~~~~~~~~~~~
AWR reports can be generated in the following formats.  Please enter the
name of the format at the prompt.  Default value is 'html'.

'html'          HTML format (default)
'text'          Text format
'active-html'   Includes Performance Hub active report

Enter value for report_type: active-html
&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>PerformanceTools-Database</category>
<category>other scripts</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BPerformance%20Hub%20report%5D%5D</link>
<pubDate>Mon, 12 Jun 2017 10:46:00 GMT</pubDate>

</item>
<item>
<title>oracle retail/retek forecasting</title>
<description>Oracle retail demand forecasting &lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://docs.oracle.com/cd/E75759_01/rdf/pdf/1401/rdf-1401-02-fcug.pdf&quot; href=&quot;http://docs.oracle.com/cd/E75759_01/rdf/pdf/1401/rdf-1401-02-fcug.pdf&quot; class=&quot;externalLink&quot;&gt;http://docs.oracle.com/cd/E75759_01/rdf/pdf/1401/rdf-1401-02-fcug.pdf&lt;/a&gt;&lt;br&gt;&lt;br&gt;</description>
<category>R forecasting</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Boracle%20retail%2Fretek%20forecasting%5D%5D</link>
<pubDate>Fri, 09 Jun 2017 16:19:00 GMT</pubDate>

</item>
<item>
<title>CreatePerformanceTuningUser</title>
<description>&lt;pre&gt;
-- create user
create user alloc_app_perf identified by testalloc;

-- user sql
alter user &quot;alloc_app_perf&quot; default tablespace &quot;bas_data&quot; temporary tablespace &quot;temp&quot; account unlock ;

-- quotas
alter user &quot;alloc_app_perf&quot; quota unlimited on bas_data;

-- roles
grant alloc_app_r to alloc_app_perf;
grant select_catalog_role to alloc_app_perf;
grant resource to alloc_app_perf;
grant select any dictionary to alloc_app_perf;
grant advisor to alloc_app_perf;
grant create job to alloc_app_perf;
grant oem_monitor to alloc_app_perf;
grant administer any sql tuning set to alloc_app_perf;   
grant administer sql management object to alloc_app_perf; 
grant create any sql_profile to alloc_app_perf;
grant drop any sql_profile to alloc_app_perf;
grant alter any sql_profile to alloc_app_perf;   

-- execute  
grant execute on dbms_monitor to alloc_app_perf;
grant execute on dbms_application_info to alloc_app_perf;
grant execute on dbms_workload_repository to alloc_app_perf;
grant execute on dbms_xplan to alloc_app_perf;     
grant execute on dbms_sqltune to alloc_app_perf;
grant execute on sys.dbms_lock to alloc_app_perf;


&lt;/pre&gt;&lt;br&gt;&lt;br&gt;also create &lt;a tiddlylink=&quot;kill session procedure&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#kill session procedure&quot; href=&quot;http://karlarao.tiddlyspot.com#kill%20session%20procedure&quot; class=&quot;externalLink null&quot;&gt;kill session procedure&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>DatabaseHealthCheck</category>
<link>http://karlarao.tiddlyspot.com#CreatePerformanceTuningUser</link>
<pubDate>Thu, 08 Jun 2017 20:42:00 GMT</pubDate>

</item>
<item>
<title>kill session procedure</title>
<description>&lt;h1&gt; the script &lt;/h1&gt;&lt;blockquote&gt;&lt;pre&gt;create or replace procedure system.killsession (killsid IN VARCHAR2)
as
killserial   varchar2(20);
 
begin
killserial:='none';
select serial#
into killserial
from sys.v_$session
where sid = killsid;
 
execute immediate 'alter system kill session ''' || to_char (killsid) || ', ' || to_char (killserial) || ''' immediate' ;
 
EXCEPTION
WHEN NO_DATA_FOUND THEN
dbms_output.put_line('The SID ' || killsid || ' does not exist or cannot be killed');
 
end ;
&lt;/pre&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;h1&gt; the grant &lt;/h1&gt;&lt;pre&gt;grant alter system to system;
grant select on sys.v_$session to system;

grant execute on system.killsession to &amp;lt;user&amp;gt;;
&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; kill session &lt;/h1&gt;&lt;pre&gt;set serveroutput on
exec system.killsession ('35');
&lt;/pre&gt;&lt;br&gt;&lt;h1&gt; generate kill all commands&lt;/h1&gt;&lt;pre&gt;set pages 0
select /* kill all */ 'exec system.killsession ('''||sid||''');'
from v$session 
where username = 'ALLOC_APP_USER';
&lt;/pre&gt;&lt;br&gt;&lt;br&gt;also create &lt;a tiddlylink=&quot;CreatePerformanceTuningUser&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#CreatePerformanceTuningUser&quot; href=&quot;http://karlarao.tiddlyspot.com#CreatePerformanceTuningUser&quot; class=&quot;externalLink null&quot;&gt;CreatePerformanceTuningUser&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;reference&lt;/strong&gt; &lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://jhdba.wordpress.com/2009/08/18/procedure-to-kill-a-session/&quot; href=&quot;https://jhdba.wordpress.com/2009/08/18/procedure-to-kill-a-session/&quot; class=&quot;externalLink&quot;&gt;https://jhdba.wordpress.com/2009/08/18/procedure-to-kill-a-session/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>DatabaseHealthCheck</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bkill%20session%20procedure%5D%5D</link>
<pubDate>Thu, 08 Jun 2017 19:54:00 GMT</pubDate>

</item>
<item>
<title>Accenture Enkitec Courses</title>
<description>&lt;blockquote&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/curator/chanea-heard&quot; href=&quot;https://connectedlearning.accenture.com/curator/chanea-heard&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/curator/chanea-heard&lt;/a&gt;&lt;br&gt;Golden Gate Admin &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/learningboard/goldengate-administration&quot; href=&quot;https://connectedlearning.accenture.com/learningboard/goldengate-administration&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/learningboard/goldengate-administration&lt;/a&gt;&lt;br&gt;APEX &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/16597&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/16597&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/16597&lt;/a&gt;&lt;br&gt;ZFS storage appliance &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/learningboard/16600-zfs-storage-appliance&quot; href=&quot;https://connectedlearning.accenture.com/learningboard/16600-zfs-storage-appliance&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/learningboard/16600-zfs-storage-appliance&lt;/a&gt;&lt;br&gt;SPARC Supercluster Admin &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/16596&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/16596&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/16596&lt;/a&gt;&lt;br&gt;Exadata Admin &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/12954&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/12954&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/12954&lt;/a&gt;&lt;br&gt;Exadata Optimizations &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/13051&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/13051&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/13051&lt;/a&gt;&lt;br&gt;All AEG &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/learningactivities&quot; href=&quot;https://connectedlearning.accenture.com/learningactivities&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/learningactivities&lt;/a&gt;&lt;br&gt;SQL Tuning with SQLTXPLAIN &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/13097&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/13097&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/13097&lt;/a&gt;&lt;br&gt;E4 2015 &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/13512&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/13512&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/13512&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://mediaexchange.accenture.com/tag/tagid/hadoop&quot; href=&quot;https://mediaexchange.accenture.com/tag/tagid/hadoop&quot; class=&quot;externalLink&quot;&gt;https://mediaexchange.accenture.com/tag/tagid/hadoop&lt;/a&gt;&lt;br&gt;AEG webinars &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/110872&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/110872&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/110872&lt;/a&gt;&lt;br&gt;media exchange tag &quot;enkitec&quot; &lt;a target=&quot;_blank&quot; title=&quot;External link to https://mediaexchange.accenture.com/tag/tagid/enkitec&quot; href=&quot;https://mediaexchange.accenture.com/tag/tagid/enkitec&quot; class=&quot;externalLink&quot;&gt;https://mediaexchange.accenture.com/tag/tagid/enkitec&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Oracle Unlimited Learning Subscription &lt;/h1&gt;&lt;br&gt;&lt;blockquote&gt;Your Unlimited Learning Subscription provides you with:&lt;br&gt; &lt;br&gt;-          Unlimited access to all courses in the Oracle University &lt;a tiddlylink=&quot;Training-on-Demand&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#Training-on-Demand&quot; href=&quot;http://karlarao.tiddlyspot.com#Training-on-Demand&quot; class=&quot;externalLink null&quot;&gt;Training-on-Demand&lt;/a&gt; (&lt;a tiddlylink=&quot;ToD&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#ToD&quot; href=&quot;http://karlarao.tiddlyspot.com#ToD&quot; class=&quot;externalLink null&quot;&gt;ToD&lt;/a&gt;) catalog – over 450 titles of in depth training courses for Database, Applications and Middleware&lt;br&gt;-          Unlimited access to all Oracle University Learning Subscriptions, including the latest in Oracle’s Cloud Solutions, Product Solutions and Industry Solutions&lt;br&gt;-          Unlimited access to all Oracle University Learning Streams for continuous learning around Oracle’s  Database, Middleware, EBS and PSFT products&lt;br&gt;-          Access to Public live virtual classroom training sessions offered by Oracle University in the case that a Training on Demand is not available&lt;br&gt;&lt;br&gt;Digital Training Learning Portal &lt;a target=&quot;_blank&quot; title=&quot;External link to https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,986&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; href=&quot;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,986&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; class=&quot;externalLink&quot;&gt;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,986&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&lt;/a&gt;&lt;br&gt;&lt;br&gt;Program Overview &lt;a target=&quot;_blank&quot; title=&quot;External link to http://link.brightcove.com/services/player/bcpid1799411699001?bckey=AQ~~,AAABmsB_z2k~,HvNx0XQhsPxXu5er5IYkstkCq_O9j5dg&amp;amp;bctid=4731151798001&quot; href=&quot;http://link.brightcove.com/services/player/bcpid1799411699001?bckey=AQ%7E%7E,AAABmsB_z2k%7E,HvNx0XQhsPxXu5er5IYkstkCq_O9j5dg&amp;amp;bctid=4731151798001&quot; class=&quot;externalLink&quot;&gt;http://link.brightcove.com/services/player/bcpid1799411699001?bckey=AQ~~,AAABmsB_z2k~,HvNx0XQhsPxXu5er5IYkstkCq_O9j5dg&amp;amp;bctid=4731151798001&lt;/a&gt;&lt;br&gt;&lt;br&gt;Learning Paths &lt;a target=&quot;_blank&quot; title=&quot;External link to https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,976&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; href=&quot;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,976&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; class=&quot;externalLink&quot;&gt;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,976&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;</description>
<category>.video content</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BAccenture%20Enkitec%20Courses%5D%5D</link>
<pubDate>Thu, 08 Jun 2017 15:24:00 GMT</pubDate>

</item>
<item>
<title>RealTimeSQLMonitoring-sql_monitor</title>
<description>&lt;strong&gt;Monitoring SQL statements with &lt;a tiddlylink=&quot;Real-Time&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#Real-Time&quot; href=&quot;http://karlarao.tiddlyspot.com#Real-Time&quot; class=&quot;externalLink null&quot;&gt;Real-Time&lt;/a&gt; SQL Monitoring [ID 1380492.1]&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://structureddata.org/2008/01/06/oracle-11g-real-time-sql-monitoring-using-dbms_sqltunereport_sql_monitor&quot; href=&quot;http://structureddata.org/2008/01/06/oracle-11g-real-time-sql-monitoring-using-dbms_sqltunereport_sql_monitor&quot; class=&quot;externalLink&quot;&gt;http://structureddata.org/2008/01/06/oracle-11g-real-time-sql-monitoring-using-dbms_sqltunereport_sql_monitor&lt;/a&gt; &amp;lt;&lt;span&gt;—&lt;/span&gt; Good stuff&lt;br&gt;&lt;pre&gt;If you want to get a SQL Monitor report for a statement you just ran in your session (similar to dbms_xplan.display_cursor) then use this command:

set pagesize 0 echo off timing off linesize 1000 trimspool on trim on long 2000000 longchunksize 2000000
select DBMS_SQLTUNE.REPORT_SQL_MONITOR(
   session_id=&amp;gt;sys_context('userenv','sid'),
   report_level=&amp;gt;'ALL') as report
from dual;

Or if you want to generate the EM Active SQL Monitor Report (my recommendation) from any SQL_ID you can use:

set pagesize 0 echo off timing off linesize 1000 trimspool on trim on long 2000000 longchunksize 2000000 feedback off
spool sqlmon_4vbqtp97hwqk8.html
select dbms_sqltune.report_sql_monitor(report_level=&amp;gt;'+histogram', type=&amp;gt;'EM', sql_id=&amp;gt;'4vbqtp97hwqk8') monitor_report from dual;
spool off
&lt;/pre&gt;&lt;br&gt;&lt;strong&gt;hint&lt;/strong&gt;&lt;br&gt;&lt;pre&gt;/*+ MONITOR */
&lt;/pre&gt;&lt;br&gt;&lt;strong&gt;spool from SQL Developer&lt;/strong&gt;&lt;br&gt;&lt;pre&gt;--select * from v$sql where sql_fulltext like '%&amp;amp;txt%' order by last_load_time;
SET TERMOUT OFF
SET verify off;
 
 
spool C:\Users\Administrator\Documents\sql_stats\fe_stage2a.html;
 
select
  dbms_sql_monitor.report_sql_monitor(sql_id =&amp;gt; '&amp;amp;sql_id',
                                      type =&amp;gt; decode(upper('&amp;amp;&amp;amp;ptype'),'A', 'ACTIVE', 'H' , 'HTML', 'TEXT'), --'TEXT'  'HTML'  'ACTIVE'
                                      report_level =&amp;gt; 'ALL') as report
FROM DUAL;
SPOOL OFF;
&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.oracle.com/technetwork/database/focus-areas/manageability/sqlmonitor-084401.html?ssSourceSiteId=otncn&quot; href=&quot;http://www.oracle.com/technetwork/database/focus-areas/manageability/sqlmonitor-084401.html?ssSourceSiteId=otncn&quot; class=&quot;externalLink&quot;&gt;http://www.oracle.com/technetwork/database/focus-areas/manageability/sqlmonitor-084401.html?ssSourceSiteId=otncn&lt;/a&gt;  &amp;lt;&lt;span&gt;—&lt;/span&gt; SQL Monitor FAQ&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://oracledoug.com/serendipity/index.php?/archives/1506-Real-Time-SQL-Monitoring-in-SQL-Developer.html&quot; href=&quot;http://oracledoug.com/serendipity/index.php?/archives/1506-Real-Time-SQL-Monitoring-in-SQL-Developer.html&quot; class=&quot;externalLink&quot;&gt;http://oracledoug.com/serendipity/index.php?/archives/1506-Real-Time-SQL-Monitoring-in-SQL-Developer.html&lt;/a&gt; &amp;lt;&lt;span&gt;—&lt;/span&gt; SQL Developer&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://oracledoug.com/serendipity/index.php?/archives/1642-Real-Time-SQL-Monitoring-Statement-Not-Appearing.html&quot; href=&quot;http://oracledoug.com/serendipity/index.php?/archives/1642-Real-Time-SQL-Monitoring-Statement-Not-Appearing.html&quot; class=&quot;externalLink&quot;&gt;http://oracledoug.com/serendipity/index.php?/archives/1642-Real-Time-SQL-Monitoring-Statement-Not-Appearing.html&lt;/a&gt; &amp;lt;&lt;span&gt;—&lt;/span&gt; hidden parameter to increase the lines - statement not appearing&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://oracledoug.com/serendipity/index.php?%2Farchives%2F1646-Real-Time-SQL-Monitoring-Retention.html&quot; href=&quot;http://oracledoug.com/serendipity/index.php?%2Farchives%2F1646-Real-Time-SQL-Monitoring-Retention.html&quot; class=&quot;externalLink&quot;&gt;http://oracledoug.com/serendipity/index.php?%2Farchives%2F1646-Real-Time-SQL-Monitoring-Retention.html&lt;/a&gt; &amp;lt;&lt;span&gt;—&lt;/span&gt; retention&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://structureddata.org/2011/08/28/reading-active-sql-monitor-reports-offline/&quot; href=&quot;http://structureddata.org/2011/08/28/reading-active-sql-monitor-reports-offline/&quot; class=&quot;externalLink&quot;&gt;http://structureddata.org/2011/08/28/reading-active-sql-monitor-reports-offline/&lt;/a&gt;  &amp;lt;&lt;span&gt;—&lt;/span&gt; &lt;strong&gt;offline view&lt;/strong&gt; of sql monitor reports&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.oracle-base.com/blog/2011/03/22/real-time-sql-monitoring-update/&quot; href=&quot;http://www.oracle-base.com/blog/2011/03/22/real-time-sql-monitoring-update/&quot; class=&quot;externalLink&quot;&gt;http://www.oracle-base.com/blog/2011/03/22/real-time-sql-monitoring-update/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://blog.aristadba.com/?tag=real-time-sql-monitoring&quot; href=&quot;http://blog.aristadba.com/?tag=real-time-sql-monitoring&quot; class=&quot;externalLink&quot;&gt;http://blog.aristadba.com/?tag=real-time-sql-monitoring&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.pythian.com/news/582/tuning-pack-11g-real-time-sql-monitoring/&quot; href=&quot;http://www.pythian.com/news/582/tuning-pack-11g-real-time-sql-monitoring/&quot; class=&quot;externalLink&quot;&gt;http://www.pythian.com/news/582/tuning-pack-11g-real-time-sql-monitoring/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://joze-senegacnik.blogspot.com/2009/12/vsqlmonitor-and-vsqlplanmonitor.html&quot; href=&quot;http://joze-senegacnik.blogspot.com/2009/12/vsqlmonitor-and-vsqlplanmonitor.html&quot; class=&quot;externalLink&quot;&gt;http://joze-senegacnik.blogspot.com/2009/12/vsqlmonitor-and-vsqlplanmonitor.html&lt;/a&gt; &amp;lt;&lt;span&gt;—&lt;/span&gt; V$&lt;a tiddlylink=&quot;SQL_MONITOR&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SQL_MONITOR&quot; href=&quot;http://karlarao.tiddlyspot.com#SQL_MONITOR&quot; class=&quot;externalLink null&quot;&gt;SQL_MONITOR&lt;/a&gt; and V$&lt;a tiddlylink=&quot;SQL_PLAN_MONITOR&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SQL_PLAN_MONITOR&quot; href=&quot;http://karlarao.tiddlyspot.com#SQL_PLAN_MONITOR&quot; class=&quot;externalLink null&quot;&gt;SQL_PLAN_MONITOR&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>SQL Tuning</category>
<link>http://karlarao.tiddlyspot.com#RealTimeSQLMonitoring-sql_monitor</link>
<pubDate>Wed, 07 Jun 2017 21:23:00 GMT</pubDate>

</item>
<item>
<title>text compare tools</title>
<description>kdiff3 - my standard tool &lt;a target=&quot;_blank&quot; title=&quot;External link to http://kdiff3.sourceforge.net/&quot; href=&quot;http://kdiff3.sourceforge.net/&quot; class=&quot;externalLink&quot;&gt;http://kdiff3.sourceforge.net/&lt;/a&gt;&lt;br&gt;diffuse - diff 4 or more files at a time &lt;a target=&quot;_blank&quot; title=&quot;External link to http://diffuse.sourceforge.net/&quot; href=&quot;http://diffuse.sourceforge.net/&quot; class=&quot;externalLink&quot;&gt;http://diffuse.sourceforge.net/&lt;/a&gt;&lt;br&gt;beyond compare - output diff reports to html &lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.scootersoftware.com/download.php&quot; href=&quot;https://www.scootersoftware.com/download.php&quot; class=&quot;externalLink&quot;&gt;https://www.scootersoftware.com/download.php&lt;/a&gt;&lt;br&gt;&lt;br&gt;diffmerge - diff tool I use for git tower &lt;a target=&quot;_blank&quot; title=&quot;External link to https://sourcegear.com/diffmerge/&quot; href=&quot;https://sourcegear.com/diffmerge/&quot; class=&quot;externalLink&quot;&gt;https://sourcegear.com/diffmerge/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>texteditors</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Btext%20compare%20tools%5D%5D</link>
<pubDate>Tue, 06 Jun 2017 15:53:00 GMT</pubDate>

</item>
<item>
<title>dplan.sql, dplan_awr.sql, dbms_xplan</title>
<description>&lt;strong&gt;dplan&lt;/strong&gt;&lt;br&gt;&lt;pre&gt;select * from table( dbms_xplan.display_cursor('&amp;amp;sql_id', null, 'ADVANCED +ALLSTATS LAST +MEMSTATS LAST') );
&lt;/pre&gt;&lt;strong&gt;dplan_awr&lt;/strong&gt;&lt;br&gt;&lt;pre&gt;select * from table(DBMS_XPLAN.DISPLAY_AWR('&amp;amp;sql_id',NULL,NULL,'ADVANCED +ALLSTATS LAST +MEMSTATS LAST'));
&lt;/pre&gt;&lt;br&gt;&lt;h1&gt; get the &lt;a tiddlylink=&quot;SQL_ID&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SQL_ID&quot; href=&quot;http://karlarao.tiddlyspot.com#SQL_ID&quot; class=&quot;externalLink null&quot;&gt;SQL_ID&lt;/a&gt; using &lt;/h1&gt;&lt;pre&gt;explain plan for 
&amp;lt;&amp;lt;SQL_ID goes here&amp;gt;&amp;gt;

select * from table(dbms_xplan.display_cursor);
&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>other scripts</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bdplan.sql%2C%20dplan_awr.sql%2C%20dbms_xplan%5D%5D</link>
<pubDate>Tue, 06 Jun 2017 15:38:00 GMT</pubDate>

</item>
<item>
<title>get tuning advisor task</title>
<description>&lt;pre&gt;
--######################################################################################################################################################################################
-- SQL TUNING ADVISOR

-- Create tuning set 
DECLARE
  cursor1 DBMS_SQLTUNE.SQLSET_CURSOR;
BEGIN
  OPEN cursor1 FOR SELECT VALUE(p)
  FROM TABLE(DBMS_SQLTUNE.SELECT_CURSOR_CACHE('sql_id = ''0fwmyxhv6qpry''')) p;
 
  DBMS_SQLTUNE.CREATE_SQLSET(sqlset_name =&amp;gt; '0fwmyxhv6qpry', description  =&amp;gt; '0fwmyxhv6qpry');
  DBMS_SQLTUNE.LOAD_SQLSET(sqlset_name =&amp;gt; '0fwmyxhv6qpry', populate_cursor =&amp;gt; cursor1);
END;
/

-- Create tuning task from tuning set
DECLARE
  l_sql_tune_task_id  VARCHAR2(100);
BEGIN
  l_sql_tune_task_id := DBMS_SQLTUNE.create_tuning_task (
                          sqlset_name =&amp;gt; '0fwmyxhv6qpry',
                          scope       =&amp;gt; DBMS_SQLTUNE.scope_comprehensive,
                          time_limit  =&amp;gt; 3600,
                          task_name   =&amp;gt; '0fwmyxhv6qpry',
                          description =&amp;gt; 'Tuning task for an SQL tuning set.');
  DBMS_OUTPUT.put_line('l_sql_tune_task_id: ' || l_sql_tune_task_id);
END;
/

-- Execute tuning task
EXEC DBMS_SQLTUNE.execute_tuning_task(task_name =&amp;gt; '0fwmyxhv6qpry');

-- View result 
SET LONG 10000
SET PAGESIZE 1000
SET LINESIZE 200
SELECT DBMS_SQLTUNE.report_tuning_task('0fwmyxhv6qpry') AS recommendations FROM dual;

--my_tuning_set_0fwmyxhv6qpry
--my_tuning_set_0fwmyxhv6qpryb
--staName45412
--0fwmyxhv6qpryb
--0fwmyxhv6qpry
--0fwmyxhv6qpryb

--######################################################################################################################################################################################
-- SQL ACCESS ADVISOR

DECLARE

taskname varchar2(30) := 'access_0fwmyxhv6qpryb';
task_desc varchar2(256) := 'SQL Access Advisor';
task_or_template varchar2(30) := 'SQLACCESS_EMTASK';
task_id number := 0;
num_found number;
sts_name varchar2(256) := '0fwmyxhv6qpryb';
sts_owner varchar2(30) := 'SYSTEM';

BEGIN
/* Create Task */
dbms_advisor.create_task(DBMS_ADVISOR.SQLACCESS_ADVISOR,task_id,taskname,task_desc,task_or_template);
/* Reset Task */
dbms_advisor.reset_task(taskname);
/* Delete Previous STS Workload Task Link */
select count(*) into num_found from user_advisor_sqla_wk_map where task_name = taskname and workload_name = sts_name;
IF num_found &amp;gt; 0 THEN
dbms_advisor.delete_sts_ref(taskname, sts_owner, sts_name);
END IF;
/* Link STS Workload to Task */
dbms_advisor.add_sts_ref(taskname,sts_owner, sts_name);
/* Set STS Workload Parameters */
dbms_advisor.set_task_parameter(taskname,'VALID_ACTION_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'VALID_MODULE_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'SQL_LIMIT',DBMS_ADVISOR.ADVISOR_UNLIMITED);
dbms_advisor.set_task_parameter(taskname,'VALID_USERNAME_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'VALID_TABLE_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'INVALID_TABLE_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'INVALID_ACTION_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'INVALID_USERNAME_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'INVALID_MODULE_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'VALID_SQLSTRING_LIST',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'INVALID_SQLSTRING_LIST','&quot;@!&quot;');
/* Set Task Parameters */
dbms_advisor.set_task_parameter(taskname,'ANALYSIS_SCOPE','ALL');
dbms_advisor.set_task_parameter(taskname,'RANKING_MEASURE','PRIORITY,OPTIMIZER_COST');
dbms_advisor.set_task_parameter(taskname,'DEF_PARTITION_TABLESPACE',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'TIME_LIMIT','30');
dbms_advisor.set_task_parameter(taskname,'MODE','COMPREHENSIVE');
dbms_advisor.set_task_parameter(taskname,'STORAGE_CHANGE',DBMS_ADVISOR.ADVISOR_UNLIMITED);
dbms_advisor.set_task_parameter(taskname,'DML_VOLATILITY','TRUE');
dbms_advisor.set_task_parameter(taskname,'WORKLOAD_SCOPE','PARTIAL');
dbms_advisor.set_task_parameter(taskname,'DEF_INDEX_TABLESPACE',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'DEF_INDEX_OWNER',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'DEF_MVIEW_TABLESPACE',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'DEF_MVIEW_OWNER',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'DEF_MVLOG_TABLESPACE',DBMS_ADVISOR.ADVISOR_UNUSED);
dbms_advisor.set_task_parameter(taskname,'CREATION_COST','TRUE');
dbms_advisor.set_task_parameter(taskname,'JOURNALING','4');
dbms_advisor.set_task_parameter(taskname,'DAYS_TO_EXPIRE','3');
/* Execute Task */
dbms_advisor.execute_task(taskname);
END;
/
        
-- Display the resulting script.
SET LONG 100000
SET PAGESIZE 100000
SET LINESIZE 200
SELECT DBMS_ADVISOR.get_task_script('my_tuning_set_0fwmyxhv6qpry') AS script FROM   dual;


-- Drop tasks and STS 
BEGIN
      DBMS_SQLTUNE.drop_tuning_task (task_name =&amp;gt; '0fwmyxhv6qpryb');
      DBMS_SQLTUNE.drop_tuning_task (task_name =&amp;gt; 'access_0fwmyxhv6qpryb');
END;
/
BEGIN
	  DBMS_SQLTUNE.DROP_SQLSET( sqlset_name =&amp;gt; '0fwmyxhv6qpryb' );
END;
/






-----------------


SELECT execution_name, task_name, execution_type, TO_CHAR(execution_start,'dd-mon-yyyy hh24:mi:ss') AS execution_start,
     TO_CHAR(execution_end,'dd-mon-yyyy hh24:mi:ss') AS execution_end, status
     FROM dba_advisor_executions 
     where owner = 'SYSTEM'
     order by execution_start desc 
--     WHERE task_name='access_0fwmyxhv6qpryb';

select * from dba_advisor_executions where owner = 'SYSTEM';
select * from dba_advisor_findings where owner = 'SYSTEM';
select * from DBA_ADVISOR_RECOMMENDATIONS where task_name = '0fwmyxhv6qpry';

-----------------  

&lt;/pre&gt;</description>
<category>TuningAdvisor</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bget%20tuning%20advisor%20task%5D%5D</link>
<pubDate>Wed, 31 May 2017 15:07:00 GMT</pubDate>

</item>
<item>
<title>TuningAdvisor</title>
<description></description>
<category>SQL Tuning</category>
<link>http://karlarao.tiddlyspot.com#TuningAdvisor</link>
<pubDate>Wed, 31 May 2017 15:06:00 GMT</pubDate>

</item>
</channel>
</rss>