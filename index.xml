<?xml version="1.0"?>
<rss version="2.0">
<channel>
<title>Karl Arao's TiddlyWiki</title>
<link>http://karlarao.tiddlyspot.com</link>
<description></description>
<language>en</language>
<copyright>Copyright 2018 KarlArao</copyright>
<pubDate>Tue, 16 Jan 2018 12:48:17 GMT</pubDate>
<lastBuildDate>Tue, 16 Jan 2018 12:48:17 GMT</lastBuildDate>
<docs>http://blogs.law.harvard.edu/tech/rss</docs>
<generator>TiddlyWiki 2.5.0</generator>
<item>
<title>3dxpoint, 3d crosspoint, optane memory</title>
<description>&lt;blockquote&gt;3D &lt;a tiddlylink=&quot;XPoint&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#XPoint&quot; href=&quot;http://karlarao.tiddlyspot.com#XPoint&quot; class=&quot;externalLink null&quot;&gt;XPoint&lt;/a&gt; (cross point) memory, which will be sold under the name Optane&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.intel.com/content/www/us/en/architecture-and-technology/intel-optane-technology.html&quot; href=&quot;https://www.intel.com/content/www/us/en/architecture-and-technology/intel-optane-technology.html&quot; class=&quot;externalLink&quot;&gt;https://www.intel.com/content/www/us/en/architecture-and-technology/intel-optane-technology.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.intel.com/content/www/us/en/architecture-and-technology/optane-memory.html&quot; href=&quot;https://www.intel.com/content/www/us/en/architecture-and-technology/optane-memory.html&quot; class=&quot;externalLink&quot;&gt;https://www.intel.com/content/www/us/en/architecture-and-technology/optane-memory.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.computerworld.com/article/3154051/data-storage/intel-unveils-its-optane-hyperfast-memory.html&quot; href=&quot;https://www.computerworld.com/article/3154051/data-storage/intel-unveils-its-optane-hyperfast-memory.html&quot; class=&quot;externalLink&quot;&gt;https://www.computerworld.com/article/3154051/data-storage/intel-unveils-its-optane-hyperfast-memory.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.computerworld.com/article/3082658/data-storage/intel-lets-slip-roadmap-for-optane-ssds-with-1000x-performance.html&quot; href=&quot;https://www.computerworld.com/article/3082658/data-storage/intel-lets-slip-roadmap-for-optane-ssds-with-1000x-performance.html&quot; class=&quot;externalLink&quot;&gt;https://www.computerworld.com/article/3082658/data-storage/intel-lets-slip-roadmap-for-optane-ssds-with-1000x-performance.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>CPU</category>
<link>http://karlarao.tiddlyspot.com#%5B%5B3dxpoint%2C%203d%20crosspoint%2C%20optane%20memory%5D%5D</link>
<pubDate>Tue, 16 Jan 2018 12:48:16 GMT</pubDate>

</item>
<item>
<title>CPU persistent memory</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://software.intel.com/en-us/videos/what-is-persistent-memory-persistent-memory-programming-series&quot; href=&quot;https://software.intel.com/en-us/videos/what-is-persistent-memory-persistent-memory-programming-series&quot; class=&quot;externalLink&quot;&gt;https://software.intel.com/en-us/videos/what-is-persistent-memory-persistent-memory-programming-series&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.pcgamer.com/rumor-intel-may-release-3d-xpoint-system-memory-in-2018/&quot; href=&quot;http://www.pcgamer.com/rumor-intel-may-release-3d-xpoint-system-memory-in-2018/&quot; class=&quot;externalLink&quot;&gt;http://www.pcgamer.com/rumor-intel-may-release-3d-xpoint-system-memory-in-2018/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://itpeernetwork.intel.com/new-breakthrough-persistent-memory-first-public-demo/&quot; href=&quot;https://itpeernetwork.intel.com/new-breakthrough-persistent-memory-first-public-demo/&quot; class=&quot;externalLink&quot;&gt;https://itpeernetwork.intel.com/new-breakthrough-persistent-memory-first-public-demo/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;blockquote&gt;this could come as a new switch/parameter on new Exadata versions to enable the use of the hardware feature just like what they did before on HW flash compression on the flash devices. Or it could come enabled as default.&lt;br&gt;But for sure this is a big boost in performance, look at that microsecond difference in latency.&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;blockquote&gt;it’s my believe that the new memory cache with Exadata actually is a development based upon 3dxpoint, alias memory that can be written to to persist.&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;blockquote&gt;3D &lt;a tiddlylink=&quot;XPoint&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#XPoint&quot; href=&quot;http://karlarao.tiddlyspot.com#XPoint&quot; class=&quot;externalLink null&quot;&gt;XPoint&lt;/a&gt; (cross point) memory, which will be sold under the name Optane&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;blockquote&gt;Looks like the application/DB vendor should make code change to take advantage of the new memory layer. Without code change to use the persistent memory structures with the kernel code of the DB software  ( like what was done in &lt;a tiddlylink=&quot;SqlServer&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SqlServer&quot; href=&quot;http://karlarao.tiddlyspot.com#SqlServer&quot; class=&quot;externalLink null&quot;&gt;SqlServer&lt;/a&gt; 2016 for very fast transaction/redo log write), it looks like we cannot easily add this super fast layer.&lt;br&gt; &lt;br&gt;So, I think the question is the adoption of this new persistent memory layer within the software.&lt;br&gt; &lt;br&gt;Some examples I see are&lt;br&gt; &lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://channel9.msdn.com/Shows/Data-Exposed/SQL-Server-2016-and-Windows-Server-2016-SCM--FAST&quot; href=&quot;https://channel9.msdn.com/Shows/Data-Exposed/SQL-Server-2016-and-Windows-Server-2016-SCM--FAST&quot; class=&quot;externalLink&quot;&gt;https://channel9.msdn.com/Shows/Data-Exposed/SQL-Server-2016-and-Windows-Server-2016-SCM--FAST&lt;/a&gt; ( check details from 8:00 Min)&lt;br&gt; &lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://software.intel.com/en-us/videos/a-c-example-persistent-memory-programming-series&quot; href=&quot;https://software.intel.com/en-us/videos/a-c-example-persistent-memory-programming-series&quot; class=&quot;externalLink&quot;&gt;https://software.intel.com/en-us/videos/a-c-example-persistent-memory-programming-series&lt;/a&gt;&lt;br&gt; &lt;br&gt;&lt;/blockquote&gt;</description>
<category>CPU</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BCPU%20persistent%20memory%5D%5D</link>
<pubDate>Tue, 16 Jan 2018 12:46:16 GMT</pubDate>

</item>
<item>
<title>.TiddlyWiki</title>
<description>&lt;h1&gt; fork this&lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://github.com/karlarao/karlaraowiki&quot; href=&quot;https://github.com/karlarao/karlaraowiki&quot; class=&quot;externalLink&quot;&gt;https://github.com/karlarao/karlaraowiki&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; how to run two versions of mozilla (need to create a new profile)&lt;/h1&gt;&lt;pre&gt;&quot;C:\Program Files (x86)\MozillaFirefox4RC2\firefox.exe&quot; -P &quot;karlarao&quot; -no-remote
&lt;/pre&gt;</description>
<category>CodeNinja</category>
<link>http://karlarao.tiddlyspot.com#.TiddlyWiki</link>
<pubDate>Tue, 16 Jan 2018 11:57:00 GMT</pubDate>

</item>
<item>
<title>About</title>
<description>Mmm.. It's a long story, just check out this blog post..  &lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.wordpress.com/2010/04/10/my-personal-wiki-karlarao-tiddlyspot-com/&quot; href=&quot;http://karlarao.wordpress.com/2010/04/10/my-personal-wiki-karlarao-tiddlyspot-com/&quot; class=&quot;externalLink&quot;&gt;http://karlarao.wordpress.com/2010/04/10/my-personal-wiki-karlarao-tiddlyspot-com/&lt;/a&gt;   :)&lt;br&gt;&lt;br&gt;Also check out my Google profile here &lt;a target=&quot;_blank&quot; title=&quot;External link to https://plus.google.com/102472804060828276067/about&quot; href=&quot;https://plus.google.com/102472804060828276067/about&quot; class=&quot;externalLink&quot;&gt;https://plus.google.com/102472804060828276067/about&lt;/a&gt; to know more about my web/social media presence&lt;br&gt;&lt;br&gt;check here &lt;a tiddlylink=&quot;.TiddlyWiki&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#.TiddlyWiki&quot; href=&quot;http://karlarao.tiddlyspot.com#.TiddlyWiki&quot; class=&quot;externalLink null&quot;&gt;.TiddlyWiki&lt;/a&gt; to get started on setting up and configuring your own wiki&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<link>http://karlarao.tiddlyspot.com#About</link>
<pubDate>Tue, 16 Jan 2018 11:57:00 GMT</pubDate>

</item>
<item>
<title>Oracle RDS</title>
<description>&lt;blockquote&gt;&lt;br&gt;&lt;br&gt;Oracle on RDS &lt;br&gt;&lt;br&gt;There are Oracle native features that do not work with RDS such as RAC, Data Guard and RMAN.&lt;br&gt;Instead of Data Guard,  RDS uses replicas which is basically block copies from primary to replica copy.&lt;br&gt;Backups via RMAN are not possible.  AWS performs storage volume snapshots.&lt;br&gt;Hot backups are possible only if there is a replica in play.  In this case, the backup is taken from the secondary instead of the primary.  If there is only a primary, the storage snapshot will cause and temporary I/O suspension; so no hot backup.&lt;br&gt;No access to sys/system; some normal DBA tasks will need to be done via AWS api.&lt;br&gt;No access to underlying file system&lt;br&gt; &lt;br&gt;If they really want Oracle on AWS, I would recommend putting Oracle on &lt;a tiddlylink=&quot;EC2&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#EC2&quot; href=&quot;http://karlarao.tiddlyspot.com#EC2&quot; class=&quot;externalLink null&quot;&gt;EC2&lt;/a&gt;.  The performance and cost are better on OCI.&lt;br&gt; &lt;br&gt;&lt;br&gt;Oracle RDS database max size up to 6TB&lt;br&gt;Getting Data into RDS is also another challenge – you are limited to datapump  and can’t not use lift and shift approach as RMAN backup is not supported.&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;</description>
<category>Amazon EC2, AWS</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BOracle%20RDS%5D%5D</link>
<pubDate>Mon, 15 Jan 2018 05:37:00 GMT</pubDate>

</item>
<item>
<title>Google Compute Platform</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://stackoverflow.com/questions/22697049/what-is-the-difference-between-google-app-engine-and-google-compute-engine&quot; href=&quot;https://stackoverflow.com/questions/22697049/what-is-the-difference-between-google-app-engine-and-google-compute-engine&quot; class=&quot;externalLink&quot;&gt;https://stackoverflow.com/questions/22697049/what-is-the-difference-between-google-app-engine-and-google-compute-engine&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; official documentation &lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://cloud.google.com/products/&quot; href=&quot;https://cloud.google.com/products/&quot; class=&quot;externalLink&quot;&gt;https://cloud.google.com/products/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://cloud.google.com/compute/docs/how-to&quot; href=&quot;https://cloud.google.com/compute/docs/how-to&quot; class=&quot;externalLink&quot;&gt;https://cloud.google.com/compute/docs/how-to&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; cloud sdk &lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://cloud.google.com/sdk/downloads&quot; href=&quot;https://cloud.google.com/sdk/downloads&quot; class=&quot;externalLink&quot;&gt;https://cloud.google.com/sdk/downloads&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://github.com/GoogleCloudPlatform&quot; href=&quot;https://github.com/GoogleCloudPlatform&quot; class=&quot;externalLink&quot;&gt;https://github.com/GoogleCloudPlatform&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; GCP vs AWS comparison &lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://cloud.google.com/docs/compare/aws&quot; href=&quot;https://cloud.google.com/docs/compare/aws&quot; class=&quot;externalLink&quot;&gt;https://cloud.google.com/docs/compare/aws&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.coursera.org/learn/gcp-fundamentals-aws&quot; href=&quot;https://www.coursera.org/learn/gcp-fundamentals-aws&quot; class=&quot;externalLink&quot;&gt;https://www.coursera.org/learn/gcp-fundamentals-aws&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; hadoop and gcp&lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Hadoop-tutorials/Hadoop-Google-Cloud-Platform/516574/593166-4.html&quot; href=&quot;https://www.lynda.com/Hadoop-tutorials/Hadoop-Google-Cloud-Platform/516574/593166-4.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Hadoop-tutorials/Hadoop-Google-Cloud-Platform/516574/593166-4.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; GCP networking&lt;/h1&gt;&lt;br&gt;&lt;h2&gt; edge network &lt;/h2&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://peering.google.com/#/&quot; href=&quot;https://peering.google.com/#/&quot; class=&quot;externalLink&quot;&gt;https://peering.google.com/#/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; online courses &lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://bit.ly/2Al1rUP&quot; href=&quot;http://bit.ly/2Al1rUP&quot; class=&quot;externalLink&quot;&gt;http://bit.ly/2Al1rUP&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.coursera.org/specializations/gcp-architecture&quot; href=&quot;https://www.coursera.org/specializations/gcp-architecture&quot; class=&quot;externalLink&quot;&gt;https://www.coursera.org/specializations/gcp-architecture&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.coursera.org/learn/gcp-fundamentals-aws#pricing&quot; href=&quot;https://www.coursera.org/learn/gcp-fundamentals-aws#pricing&quot; class=&quot;externalLink&quot;&gt;https://www.coursera.org/learn/gcp-fundamentals-aws#pricing&lt;/a&gt; &amp;lt;- Google Cloud Platform Fundamentals for AWS Professionals&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.udemy.com/courses/search/?q=google%20compute%20engine&amp;amp;src=ukw&quot; href=&quot;https://www.udemy.com/courses/search/?q=google%20compute%20engine&amp;amp;src=ukw&quot; class=&quot;externalLink&quot;&gt;https://www.udemy.com/courses/search/?q=google%20compute%20engine&amp;amp;src=ukw&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Cloud-tutorials/Google-Cloud-Compute-Engine-Essential-Training/181244-2.html&quot; href=&quot;https://www.lynda.com/Cloud-tutorials/Google-Cloud-Compute-Engine-Essential-Training/181244-2.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Cloud-tutorials/Google-Cloud-Compute-Engine-Essential-Training/181244-2.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.pluralsight.com/search?q=google%20compute&quot; href=&quot;https://www.pluralsight.com/search?q=google%20compute&quot; class=&quot;externalLink&quot;&gt;https://www.pluralsight.com/search?q=google%20compute&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.pluralsight.com/authors/lynn-langit&quot; href=&quot;https://www.pluralsight.com/authors/lynn-langit&quot; class=&quot;externalLink&quot;&gt;https://www.pluralsight.com/authors/lynn-langit&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.safaribooksonline.com/search/?query=%22Google%20Compute%20Engine%22&amp;amp;extended_publisher_data=true&amp;amp;highlight=true&amp;amp;is_academic_institution_account=false&amp;amp;source=user&amp;amp;include_assessments=false&amp;amp;include_case_studies=true&amp;amp;include_courses=true&amp;amp;include_orioles=true&amp;amp;include_playlists=true&amp;amp;formats=video&amp;amp;sort=relevance&quot; href=&quot;https://www.safaribooksonline.com/search/?query=%22Google%20Compute%20Engine%22&amp;amp;extended_publisher_data=true&amp;amp;highlight=true&amp;amp;is_academic_institution_account=false&amp;amp;source=user&amp;amp;include_assessments=false&amp;amp;include_case_studies=true&amp;amp;include_courses=true&amp;amp;include_orioles=true&amp;amp;include_playlists=true&amp;amp;formats=video&amp;amp;sort=relevance&quot; class=&quot;externalLink&quot;&gt;https://www.safaribooksonline.com/search/?query=%22Google%20Compute%20Engine%22&amp;amp;extended_publisher_data=true&amp;amp;highlight=true&amp;amp;is_academic_institution_account=false&amp;amp;source=user&amp;amp;include_assessments=false&amp;amp;include_case_studies=true&amp;amp;include_courses=true&amp;amp;include_orioles=true&amp;amp;include_playlists=true&amp;amp;formats=video&amp;amp;sort=relevance&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt; &lt;a tiddlylink=&quot;Lynn-Langit&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#Lynn-Langit&quot; href=&quot;http://karlarao.tiddlyspot.com#Lynn-Langit&quot; class=&quot;externalLink null&quot;&gt;Lynn-Langit&lt;/a&gt;&lt;/h2&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Google-Cloud-Platform-tutorials/Google-Cloud-Platform-Essential-Training/540539-2.html&quot; href=&quot;https://www.lynda.com/Google-Cloud-Platform-tutorials/Google-Cloud-Platform-Essential-Training/540539-2.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Google-Cloud-Platform-tutorials/Google-Cloud-Platform-Essential-Training/540539-2.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Google-Cloud-tutorials/Google-Cloud-Spanner-First-Look/597023-2.html&quot; href=&quot;https://www.lynda.com/Google-Cloud-tutorials/Google-Cloud-Spanner-First-Look/597023-2.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Google-Cloud-tutorials/Google-Cloud-Spanner-First-Look/597023-2.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt; Joseph Lowery&lt;/h2&gt;app engine &lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Developer-Cloud-Computing-tutorials/Google-App-Engine-Essential-Training/194134-2.html&quot; href=&quot;https://www.lynda.com/Developer-Cloud-Computing-tutorials/Google-App-Engine-Essential-Training/194134-2.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Developer-Cloud-Computing-tutorials/Google-App-Engine-Essential-Training/194134-2.html&lt;/a&gt;&lt;br&gt;compute engine &lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Cloud-tutorials/Google-Cloud-Compute-Engine-Essential-Training/181244-2.html&quot; href=&quot;https://www.lynda.com/Cloud-tutorials/Google-Cloud-Compute-Engine-Essential-Training/181244-2.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Cloud-tutorials/Google-Cloud-Compute-Engine-Essential-Training/181244-2.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.lynda.com/Cloud-tutorials/Google-Cloud-Storage-Data-Essential-Training/181243-2.html&quot; href=&quot;https://www.lynda.com/Cloud-tutorials/Google-Cloud-Storage-Data-Essential-Training/181243-2.html&quot; class=&quot;externalLink&quot;&gt;https://www.lynda.com/Cloud-tutorials/Google-Cloud-Storage-Data-Essential-Training/181243-2.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;h2&gt; James Wilson &lt;/h2&gt;cloud functions &lt;a target=&quot;_blank&quot; title=&quot;External link to https://app.pluralsight.com/library/courses/google-cloud-functions-getting-started/table-of-contents&quot; href=&quot;https://app.pluralsight.com/library/courses/google-cloud-functions-getting-started/table-of-contents&quot; class=&quot;externalLink&quot;&gt;https://app.pluralsight.com/library/courses/google-cloud-functions-getting-started/table-of-contents&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>1 CodeNinja Hosting , cloud computing</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BGoogle%20Compute%20Platform%5D%5D</link>
<pubDate>Sun, 14 Jan 2018 06:32:00 GMT</pubDate>

</item>
<item>
<title>gcp example app</title>
<description>Google Cloud Platform tutorial: Deploying an example app | lynda.com &lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.youtube.com/watch?v=M56RdQwXvEU&quot; href=&quot;https://www.youtube.com/watch?v=M56RdQwXvEU&quot; class=&quot;externalLink&quot;&gt;https://www.youtube.com/watch?v=M56RdQwXvEU&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://clrc.org/this-weeks-featured-lynda-com-course-up-and-running-with-google-cloud-platform-with-joseph-lowery/&quot; href=&quot;https://clrc.org/this-weeks-featured-lynda-com-course-up-and-running-with-google-cloud-platform-with-joseph-lowery/&quot; class=&quot;externalLink&quot;&gt;https://clrc.org/this-weeks-featured-lynda-com-course-up-and-running-with-google-cloud-platform-with-joseph-lowery/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://github.com/GoogleCloudPlatform/solutions-photo-sharing-demo-java&quot; href=&quot;https://github.com/GoogleCloudPlatform/solutions-photo-sharing-demo-java&quot; class=&quot;externalLink&quot;&gt;https://github.com/GoogleCloudPlatform/solutions-photo-sharing-demo-java&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;Build your first website on the Google Cloud platform &lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.youtube.com/watch?v=KzJxwu2poIc&quot; href=&quot;https://www.youtube.com/watch?v=KzJxwu2poIc&quot; class=&quot;externalLink&quot;&gt;https://www.youtube.com/watch?v=KzJxwu2poIc&lt;/a&gt;</description>
<category>Google Compute Platform</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bgcp%20example%20app%5D%5D</link>
<pubDate>Sun, 14 Jan 2018 06:32:00 GMT</pubDate>

</item>
<item>
<title>TensorFlow</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://tensorflow.rstudio.com/&quot; href=&quot;https://tensorflow.rstudio.com/&quot; class=&quot;externalLink&quot;&gt;https://tensorflow.rstudio.com/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://github.com/rstudio/tensorflow&quot; href=&quot;https://github.com/rstudio/tensorflow&quot; class=&quot;externalLink&quot;&gt;https://github.com/rstudio/tensorflow&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://cloud.google.com/ml-engine/&quot; href=&quot;https://cloud.google.com/ml-engine/&quot; class=&quot;externalLink&quot;&gt;https://cloud.google.com/ml-engine/&lt;/a&gt;&lt;br&gt;</description>
<category>Machine Learning</category>
<link>http://karlarao.tiddlyspot.com#TensorFlow</link>
<pubDate>Sat, 13 Jan 2018 19:19:00 GMT</pubDate>

</item>
<item>
<title>PerformanceTools-Database</title>
<description>&lt;h1&gt; Session/System level perf monitoring&lt;/h1&gt;&lt;ul&gt;&lt;li&gt; Perfsheet (Performance Visualization) – For Session Monitoring, uses excel sheet&lt;/li&gt;&lt;li&gt; Ashmon (Active Session Monitoring) – For monitoring Database Session , Ashmon on 64bit &lt;a target=&quot;_blank&quot; title=&quot;External link to http://db-optimizer.blogspot.com/2010/10/ashmon-on-64bit-oracle-11gr2.html&quot; href=&quot;http://db-optimizer.blogspot.com/2010/10/ashmon-on-64bit-oracle-11gr2.html&quot; class=&quot;externalLink&quot;&gt;http://db-optimizer.blogspot.com/2010/10/ashmon-on-64bit-oracle-11gr2.html&lt;/a&gt;, by marcin at github &lt;a target=&quot;_blank&quot; title=&quot;External link to https://github.com/pioro/orasash/&quot; href=&quot;https://github.com/pioro/orasash/&quot; class=&quot;externalLink&quot;&gt;https://github.com/pioro/orasash/&lt;/a&gt;&lt;/li&gt;&lt;li&gt; DB Optimizer - the production version of Ashmon, with cool Visual SQL Tuning! (just like Dan Tow has envisioned)&lt;/li&gt;&lt;li&gt; ASH Viewer by Alexander Kardapolov &lt;a target=&quot;_blank&quot; title=&quot;External link to http://j.mp/dNidrB&quot; href=&quot;http://j.mp/dNidrB&quot; class=&quot;externalLink&quot;&gt;http://j.mp/dNidrB&lt;/a&gt;, &lt;a target=&quot;_blank&quot; title=&quot;External link to http://ronr.blogspot.com/2012/10/ash-for-standard-edition-or-without.html&quot; href=&quot;http://ronr.blogspot.com/2012/10/ash-for-standard-edition-or-without.html&quot; class=&quot;externalLink&quot;&gt;http://ronr.blogspot.com/2012/10/ash-for-standard-edition-or-without.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt; Lab128 (trial software) – Tool for Oracle Tuning, Monitoring and trace SQL/Stored procedures transactions &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.lab128.com/lab128_download.html&quot; href=&quot;http://www.lab128.com/lab128_download.html&quot; class=&quot;externalLink&quot;&gt;http://www.lab128.com/lab128_download.html&lt;/a&gt; &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.lab128.com/lab128_new_features.html&quot; href=&quot;http://www.lab128.com/lab128_new_features.html&quot; class=&quot;externalLink&quot;&gt;http://www.lab128.com/lab128_new_features.html&lt;/a&gt; &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.lab128.com/lab128_rg/html/contents.html&quot; href=&quot;http://www.lab128.com/lab128_rg/html/contents.html&quot; class=&quot;externalLink&quot;&gt;http://www.lab128.com/lab128_rg/html/contents.html&lt;/a&gt; Lab128 has automated the pstack sampling, os_explain, &amp;amp; reporting. Good tool to know where the query was spending time &lt;a target=&quot;_blank&quot; title=&quot;External link to http://goo.gl/fyH5x&quot; href=&quot;http://goo.gl/fyH5x&quot; class=&quot;externalLink&quot;&gt;http://goo.gl/fyH5x&lt;/a&gt;&lt;/li&gt;&lt;li&gt; Mumbai (freeware) - Performance monitoring tool that integrated Snapper, Orasrp, Statspack viewer, alert log viewer, nice session level profiling, and lots of good stuff! &lt;a target=&quot;_blank&quot; title=&quot;External link to https://marcusmonnig.wordpress.com/mumbai/&quot; href=&quot;https://marcusmonnig.wordpress.com/mumbai/&quot; class=&quot;externalLink&quot;&gt;https://marcusmonnig.wordpress.com/mumbai/&lt;/a&gt; &lt;/li&gt;&lt;li&gt; &lt;a tiddlylink=&quot;EMlight&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#EMlight&quot; href=&quot;http://karlarao.tiddlyspot.com#EMlight&quot; class=&quot;externalLink null&quot;&gt;EMlight&lt;/a&gt; by Obzora &lt;a target=&quot;_blank&quot; title=&quot;External link to http://obzora.com/home.html&quot; href=&quot;http://obzora.com/home.html&quot; class=&quot;externalLink&quot;&gt;http://obzora.com/home.html&lt;/a&gt; - a lightweight web based EM&lt;/li&gt;&lt;li&gt; Google Chrome AWR Formatter by Tyler Muth - &lt;a target=&quot;_blank&quot; title=&quot;External link to http://tylermuth.wordpress.com/2011/04/20/awr-formatter/&quot; href=&quot;http://tylermuth.wordpress.com/2011/04/20/awr-formatter/&quot; class=&quot;externalLink&quot;&gt;http://tylermuth.wordpress.com/2011/04/20/awr-formatter/&lt;/a&gt; - when you want to drill down on AWR statistics for a specific &lt;a tiddlylink=&quot;SNAP_ID&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#SNAP_ID&quot; href=&quot;http://karlarao.tiddlyspot.com#SNAP_ID&quot; class=&quot;externalLink null&quot;&gt;SNAP_ID&lt;/a&gt; this tool can be very helpful. This works only on html format of AWR. I would use it together with the Firefighting Diagnosis excel template of Craig Shallahamer to quickly account the RT = ST+QT&lt;/li&gt;&lt;li&gt; Snapper (Oracle Session Snapper) - Reports Oracle session level performance counter and wait information in real time &lt;a target=&quot;_blank&quot; title=&quot;External link to http://tech.e2sn.com/oracle-scripts-and-tools/session-snapper&quot; href=&quot;http://tech.e2sn.com/oracle-scripts-and-tools/session-snapper&quot; class=&quot;externalLink&quot;&gt;http://tech.e2sn.com/oracle-scripts-and-tools/session-snapper&lt;/a&gt; - doesn't require Diag&amp;amp;Tuning pack&lt;/li&gt;&lt;li&gt; MOATS - &lt;a target=&quot;_blank&quot; title=&quot;External link to http://blog.tanelpoder.com/2011/03/29/moats-the-mother-of-all-tuning-scripts/&quot; href=&quot;http://blog.tanelpoder.com/2011/03/29/moats-the-mother-of-all-tuning-scripts/&quot; class=&quot;externalLink&quot;&gt;http://blog.tanelpoder.com/2011/03/29/moats-the-mother-of-all-tuning-scripts/&lt;/a&gt; , &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.oracle-developer.net/utilities.php&quot; href=&quot;http://www.oracle-developer.net/utilities.php&quot; class=&quot;externalLink&quot;&gt;http://www.oracle-developer.net/utilities.php&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a tiddlylink=&quot;RAC-aware&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#RAC-aware&quot; href=&quot;http://karlarao.tiddlyspot.com#RAC-aware&quot; class=&quot;externalLink null&quot;&gt;RAC-aware&lt;/a&gt; MOATS - &lt;a target=&quot;_blank&quot; title=&quot;External link to http://jagjeet.wordpress.com/2012/05/13/sqlplus-dashboard-for-rac/&quot; href=&quot;http://jagjeet.wordpress.com/2012/05/13/sqlplus-dashboard-for-rac/&quot; class=&quot;externalLink&quot;&gt;http://jagjeet.wordpress.com/2012/05/13/sqlplus-dashboard-for-rac/&lt;/a&gt; has a cool AAS dashboard with Exadata metrics (smart scans, flash cache, etc.) - this requires Diag&amp;amp;Tuning Pack&lt;/li&gt;&lt;li&gt; oratop (MOS 1500864.1) - near real-time monitoring of databases, RAC and Single Instance, much like &lt;a tiddlylink=&quot;RAC-aware&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#RAC-aware&quot; href=&quot;http://karlarao.tiddlyspot.com#RAC-aware&quot; class=&quot;externalLink null&quot;&gt;RAC-aware&lt;/a&gt; MOATS - doesn't require Diag&amp;amp;Tuning pack, no cool AAS dashboard&lt;/li&gt;&lt;li&gt; Oracle LTOM (Oracle Lite Onboard Monitor) – Provides automatic session tracing&lt;/li&gt;&lt;li&gt; Orapub's OSM scripts - A toolkit for database monitoring and workload characterization&lt;/li&gt;&lt;li&gt; JL references &lt;a target=&quot;_blank&quot; title=&quot;External link to http://jonathanlewis.wordpress.com/2009/06/23/glossary/&quot; href=&quot;http://jonathanlewis.wordpress.com/2009/06/23/glossary/&quot; class=&quot;externalLink&quot;&gt;http://jonathanlewis.wordpress.com/2009/06/23/glossary/&lt;/a&gt; , &lt;a target=&quot;_blank&quot; title=&quot;External link to http://jonathanlewis.wordpress.com/2009/12/18/simple-scripts/&quot; href=&quot;http://jonathanlewis.wordpress.com/2009/12/18/simple-scripts/&quot; class=&quot;externalLink&quot;&gt;http://jonathanlewis.wordpress.com/2009/12/18/simple-scripts/&lt;/a&gt; , &lt;a target=&quot;_blank&quot; title=&quot;External link to http://jonathanlewis.wordpress.com/statspack-examples/&quot; href=&quot;http://jonathanlewis.wordpress.com/statspack-examples/&quot; class=&quot;externalLink&quot;&gt;http://jonathanlewis.wordpress.com/statspack-examples/&lt;/a&gt; , &lt;a target=&quot;_blank&quot; title=&quot;External link to http://jonathanlewis.wordpress.com/2010/03/17/partition-stats/&quot; href=&quot;http://jonathanlewis.wordpress.com/2010/03/17/partition-stats/&quot; class=&quot;externalLink&quot;&gt;http://jonathanlewis.wordpress.com/2010/03/17/partition-stats/&lt;/a&gt;&lt;/li&gt;&lt;li&gt; List of end-user monitoring tools &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.real-user-monitoring.com/the-complete-list-of-end-user-experience-monitoring-tools/&quot; href=&quot;http://www.real-user-monitoring.com/the-complete-list-of-end-user-experience-monitoring-tools/&quot; class=&quot;externalLink&quot;&gt;http://www.real-user-monitoring.com/the-complete-list-of-end-user-experience-monitoring-tools/&lt;/a&gt; , &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.alexanderpodelko.com/PerfManagement.html&quot; href=&quot;http://www.alexanderpodelko.com/PerfManagement.html&quot; class=&quot;externalLink&quot;&gt;http://www.alexanderpodelko.com/PerfManagement.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a tiddlylink=&quot;ASH masters, AWR masters&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#ASH masters, AWR masters&quot; href=&quot;http://karlarao.tiddlyspot.com#ASH%20masters,%20AWR%20masters&quot; class=&quot;externalLink null&quot;&gt;ASH masters, AWR masters&lt;/a&gt; - a collection of ASH and AWR scripts I've been using for years to do session level profiling and workload characterization&lt;/li&gt;&lt;li&gt; orachk collection manager &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.fuadarshad.com/2015/02/exadata-12c-new-features-rmoug-slides.html&quot; href=&quot;http://www.fuadarshad.com/2015/02/exadata-12c-new-features-rmoug-slides.html&quot; class=&quot;externalLink&quot;&gt;http://www.fuadarshad.com/2015/02/exadata-12c-new-features-rmoug-slides.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a tiddlylink=&quot;report_sql_monitor_html.sql&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#report_sql_monitor_html.sql&quot; href=&quot;http://karlarao.tiddlyspot.com#report_sql_monitor_html.sql&quot; class=&quot;externalLink null&quot;&gt;report_sql_monitor_html.sql&lt;/a&gt; sql monitor reports&lt;/li&gt;&lt;li&gt; &lt;a tiddlylink=&quot;Performance Hub report&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#Performance Hub report&quot; href=&quot;http://karlarao.tiddlyspot.com#Performance%20Hub%20report&quot; class=&quot;externalLink null&quot;&gt;Performance Hub report&lt;/a&gt; performance hub reports&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;h1&gt; SQL Tuning&lt;/h1&gt;&lt;ul&gt;&lt;li&gt; SQLTXPLAIN (Oracle Extended Explain Plan Statistics) – Provides details about all schema objects in which the SQL statement depends on.&lt;/li&gt;&lt;li&gt; Orasrp (Oracle Session Resource Planner) – Builds complete detailed session profile&lt;/li&gt;&lt;li&gt; gxplan - Visualization of explain plan&lt;/li&gt;&lt;li&gt; 10053 viewer - &lt;a target=&quot;_blank&quot; title=&quot;External link to http://jonathanlewis.wordpress.com/2010/04/30/10053-viewer/&quot; href=&quot;http://jonathanlewis.wordpress.com/2010/04/30/10053-viewer/&quot; class=&quot;externalLink&quot;&gt;http://jonathanlewis.wordpress.com/2010/04/30/10053-viewer/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;h1&gt; Forecasting&lt;/h1&gt;&lt;ul&gt;&lt;li&gt; r2toolkit - &lt;a target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com/#r2project&quot; href=&quot;http://karlarao.tiddlyspot.com/#r2project&quot; class=&quot;externalLink&quot;&gt;http://karlarao.tiddlyspot.com/#r2project&lt;/a&gt; This is a performance toolkit that uses AWR data and Linear Regression to identify what metric/statistic is driving the database server’s workload. The data points can be very useful for capacity planning giving you informed decisions and completely avoiding guesswork!&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;Kyle's notes &lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://sites.google.com/site/oraclemonitor/notes&quot; href=&quot;https://sites.google.com/site/oraclemonitor/notes&quot; class=&quot;externalLink&quot;&gt;https://sites.google.com/site/oraclemonitor/notes&lt;/a&gt;&lt;br&gt;</description>
<category>PerformanceTools</category>
<link>http://karlarao.tiddlyspot.com#PerformanceTools-Database</link>
<pubDate>Wed, 10 Jan 2018 17:51:00 GMT</pubDate>

</item>
<item>
<title>latch free</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://logicalread.com/oracle-latch-free-wait-dr01/#.WlOW9WTwbdQ&quot; href=&quot;https://logicalread.com/oracle-latch-free-wait-dr01/#.WlOW9WTwbdQ&quot; class=&quot;externalLink&quot;&gt;https://logicalread.com/oracle-latch-free-wait-dr01/#.WlOW9WTwbdQ&lt;/a&gt;&lt;br&gt;</description>
<category>SharedPool</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Blatch%20free%5D%5D</link>
<pubDate>Tue, 09 Jan 2018 15:04:00 GMT</pubDate>

</item>
<item>
<title>node.js</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.npmjs.com/&quot; href=&quot;https://www.npmjs.com/&quot; class=&quot;externalLink&quot;&gt;https://www.npmjs.com/&lt;/a&gt;&lt;br&gt;&lt;br&gt;history &lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.youtube.com/watch?v=SAc0vQCC6UQ&amp;amp;feature=g-vrec&quot; href=&quot;http://www.youtube.com/watch?v=SAc0vQCC6UQ&amp;amp;feature=g-vrec&quot; class=&quot;externalLink&quot;&gt;http://www.youtube.com/watch?v=SAc0vQCC6UQ&amp;amp;feature=g-vrec&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://blog.nodejs.org/2012/05/08/bryan-cantrill-instrumenting-the-real-time-web/&quot; href=&quot;http://blog.nodejs.org/2012/05/08/bryan-cantrill-instrumenting-the-real-time-web/&quot; class=&quot;externalLink&quot;&gt;http://blog.nodejs.org/2012/05/08/bryan-cantrill-instrumenting-the-real-time-web/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.nodebeginner.org/&quot; href=&quot;http://www.nodebeginner.org/&quot; class=&quot;externalLink&quot;&gt;http://www.nodebeginner.org/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js&quot; href=&quot;http://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js&quot; class=&quot;externalLink&quot;&gt;http://www.toptal.com/nodejs/why-the-hell-would-i-use-node-js&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://medium.com/@sagish/intro-why-i-chose-node-js-over-ruby-on-rails-905b0d7d15c3&quot; href=&quot;https://medium.com/@sagish/intro-why-i-chose-node-js-over-ruby-on-rails-905b0d7d15c3&quot; class=&quot;externalLink&quot;&gt;https://medium.com/@sagish/intro-why-i-chose-node-js-over-ruby-on-rails-905b0d7d15c3&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://nodeframework.com/&quot; href=&quot;http://nodeframework.com/&quot; class=&quot;externalLink&quot;&gt;http://nodeframework.com/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://app.pluralsight.com/library/courses/node-intro/table-of-contents&quot; href=&quot;https://app.pluralsight.com/library/courses/node-intro/table-of-contents&quot; class=&quot;externalLink&quot;&gt;https://app.pluralsight.com/library/courses/node-intro/table-of-contents&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.codeschool.com/courses/real-time-web-with-node-js&quot; href=&quot;https://www.codeschool.com/courses/real-time-web-with-node-js&quot; class=&quot;externalLink&quot;&gt;https://www.codeschool.com/courses/real-time-web-with-node-js&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.udacity.com/course/javascript-promises--ud898&quot; href=&quot;https://www.udacity.com/course/javascript-promises--ud898&quot; class=&quot;externalLink&quot;&gt;https://www.udacity.com/course/javascript-promises--ud898&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>Javascript</category>
<link>http://karlarao.tiddlyspot.com#node.js</link>
<pubDate>Wed, 03 Jan 2018 13:30:00 GMT</pubDate>

</item>
<item>
<title>Exadata IO breakdown - correlate instance IO vs cellmetrics</title>
<description>explained to a customer the correlation of instance IO vs cellmetrics by (CG,DB - flash vs hard disk)&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.evernote.com/l/ADB0VbIOPs1Leb4s79Np5GvKmHPER93wW0g/&quot; href=&quot;http://www.evernote.com/l/ADB0VbIOPs1Leb4s79Np5GvKmHPER93wW0g/&quot; class=&quot;externalLink&quot;&gt;http://www.evernote.com/l/ADB0VbIOPs1Leb4s79Np5GvKmHPER93wW0g/&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description>
<category>awr_iowlexa.sql - Hierarchy of Exadata IO</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BExadata%20IO%20breakdown%20-%20correlate%20instance%20IO%20vs%20cellmetrics%5D%5D</link>
<pubDate>Thu, 28 Dec 2017 15:06:00 GMT</pubDate>

</item>
<item>
<title>ITL</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to http://arup.blogspot.com/2011/01/more-on-interested-transaction-lists.html&quot; href=&quot;http://arup.blogspot.com/2011/01/more-on-interested-transaction-lists.html&quot; class=&quot;externalLink&quot;&gt;http://arup.blogspot.com/2011/01/more-on-interested-transaction-lists.html&lt;/a&gt;&lt;br&gt;&lt;pre&gt;There are two basic alternatives to solve the ITL wait problem:
(1) INITRANS
(2) Less Space for Data

select snap_id, ITL_WAITS_TOTAL, ITL_WAITS_DELTA from DBA_HIST_SEG_STAT;
select ini_trans from dba_tables;
&lt;/pre&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.antognini.ch/2011/04/itl-waits-changes-in-recent-releases/&quot; href=&quot;http://www.antognini.ch/2011/04/itl-waits-changes-in-recent-releases/&quot; class=&quot;externalLink&quot;&gt;http://www.antognini.ch/2011/04/itl-waits-changes-in-recent-releases/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.antognini.ch/2011/06/itl-waits-changes-in-recent-releases-script/&quot; href=&quot;http://www.antognini.ch/2011/06/itl-waits-changes-in-recent-releases-script/&quot; class=&quot;externalLink&quot;&gt;http://www.antognini.ch/2011/06/itl-waits-changes-in-recent-releases-script/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.antognini.ch/2013/05/itl-deadlocks-script/&quot; href=&quot;http://www.antognini.ch/2013/05/itl-deadlocks-script/&quot; class=&quot;externalLink&quot;&gt;http://www.antognini.ch/2013/05/itl-deadlocks-script/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://neeraj-dba.blogspot.com/2012/05/interested-transaction-list-itl-in.html&quot; href=&quot;http://neeraj-dba.blogspot.com/2012/05/interested-transaction-list-itl-in.html&quot; class=&quot;externalLink&quot;&gt;http://neeraj-dba.blogspot.com/2012/05/interested-transaction-list-itl-in.html&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://avdeo.com/2008/06/16/interested-transaction-list-itl/&quot; href=&quot;http://avdeo.com/2008/06/16/interested-transaction-list-itl/&quot; class=&quot;externalLink&quot;&gt;http://avdeo.com/2008/06/16/interested-transaction-list-itl/&lt;/a&gt;  &amp;lt;&lt;span&gt;—&lt;/span&gt; interesting explanation of block, ITL, and tied to Undo transaction table and segments&lt;br&gt;&lt;pre&gt;Oracle Data block is divided into 3 major portions.
&amp;gt; Oracle Fixed size header
&amp;gt; Oracle Variable size header
&amp;gt; Oracle Data content space
&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; mos Troubleshooting waits for 'enq: TX - allocate ITL entry' (Doc ID 1472175.1)&lt;/h1&gt;&lt;pre&gt;SYMPTOMS

Observe high waits for event enq: TX - allocate ITL entry

Top 5 Timed Foreground Events

Event                           Waits  Time(s)  Avg wait (ms)  % DB time  Wait Class
enq: TX - allocate ITL entry    1,200   3,129           2607       85.22  Configuration
DB CPU                                                   323        8.79 
gc buffer busy acquire         17,261      50              3        1.37  Cluster
gc cr block 2-way             143,108      48              0        1.32  Cluster
gc current block busy          10,631      46              4        1.24  Cluster

CAUSE

By default INITRANS value for table is 1 and for index is 2. When too many concurrent DML transactions are competing for the same data block we observe this wait event - &quot; enq: TX - allocate ITL entry&quot;

Once the table or index is reorganized by altering the INITRANS or PCTFREE parameter, it helps to reduce &quot;enq: TX - allocate ITL entry&quot; wait events.
 
As per AWR report below are the tables which reported this wait event 

Segments by ITL Waits

  * % of Capture shows % of ITL waits for each top segment compared
  * with total ITL waits for all segments captured by the Snapshot

Owner Tablespace Name Object Name Subobject Name Obj. Type       ITL  Waits % of Capture
PIN   BRM_TABLES      SERVICE_T                  TABLE           188               84.30
PIN   BRM_TABLES      BILLINFO_T  P_R_06202012   TABLE PARTITION  35               15.70

 

To know more details, In the AWR report, search for the section &quot;Segments by ITL Waits&quot;  .

 

SOLUTION

To reduce enq: TX - allocate ITL entry&quot; wait events, We need to follow the below steps.

A)

1) Depending on the amount of transactions in the table we need to alter the value of INITRANS.

alter table &amp;lt;table name&amp;gt; INITRANS 50;

2) Then re-organize the table using move (alter table &amp;lt;table_name&amp;gt; move;)

3) Then rebuild all the indexes of this table as below

alter index &amp;lt;index_name&amp;gt; rebuild INITRANS 50;
 

If the issue is not resolved by the above steps, please try by increasing PCTFREE


B)

1) Spreading rows into more number of blocks will also helps to reduce this wait event.

alter table &amp;lt;table name&amp;gt;  PCTFREE 40;
2) Then re-organize the table using move (alter table service_T move;)

3) Rebuild index

alter index index_name  rebuild PCTFREE 40;
 

OR You can combine steps A and B as below


1) Set INITRANS to 50  pct_free to 40

alter table &amp;lt;table_name&amp;gt; PCTFREE 40  INITRANS 50;

2) Then re-organize the table using move (alter table &amp;lt;table_name&amp;gt; move;)

3) Then rebuild all the indexes of the table as below

alter index &amp;lt;index_name&amp;gt;  rebuild PCTFREE 40 INITRANS 50;


NOTE:
The table/index can be altered to set the new value for INITRANS. But the altered value takes effect for new blocks only. Basically you need to rebuild the objects so that the blocks are initialized again.

For an index this means the index needs to be rebuild or recreated.

For a table this can be achieved through:
exp/imp
alter table move
dbms_redefenition
&lt;/pre&gt;</description>
<category>Database Tuning</category>
<link>http://karlarao.tiddlyspot.com#ITL</link>
<pubDate>Fri, 15 Dec 2017 00:06:00 GMT</pubDate>

</item>
<item>
<title>Facebook</title>
<description>&lt;strong&gt;RSS to Groups&lt;/strong&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.facebook.com/topic.php?uid=4915599711&amp;amp;topic=4658#topic_top&quot; href=&quot;http://www.facebook.com/topic.php?uid=4915599711&amp;amp;topic=4658#topic_top&quot; class=&quot;externalLink&quot;&gt;http://www.facebook.com/topic.php?uid=4915599711&amp;amp;topic=4658#topic_top&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://www.youtube.com/watch?v=HgGxgX9KFfc&quot; href=&quot;http://www.youtube.com/watch?v=HgGxgX9KFfc&quot; class=&quot;externalLink&quot;&gt;http://www.youtube.com/watch?v=HgGxgX9KFfc&lt;/a&gt;&lt;br&gt;&lt;br&gt;timeline&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.facebook.com/about/timeline&quot; href=&quot;https://www.facebook.com/about/timeline&quot; class=&quot;externalLink&quot;&gt;https://www.facebook.com/about/timeline&lt;/a&gt;&lt;br&gt;&lt;br&gt;facebook download ALL info &lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.facebook.com/help/?page=116481065103985&quot; href=&quot;https://www.facebook.com/help/?page=116481065103985&quot; class=&quot;externalLink&quot;&gt;https://www.facebook.com/help/?page=116481065103985&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; graph search &lt;/h1&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.facebook.com/find-friends/browser/&quot; href=&quot;https://www.facebook.com/find-friends/browser/&quot; class=&quot;externalLink&quot;&gt;https://www.facebook.com/find-friends/browser/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.sitepoint.com/facebook-graph-search/&quot; href=&quot;https://www.sitepoint.com/facebook-graph-search/&quot; class=&quot;externalLink&quot;&gt;https://www.sitepoint.com/facebook-graph-search/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://www.labnol.org/internet/facebook-graph-search-commands/28542/&quot; href=&quot;https://www.labnol.org/internet/facebook-graph-search-commands/28542/&quot; class=&quot;externalLink&quot;&gt;https://www.labnol.org/internet/facebook-graph-search-commands/28542/&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to http://graph.tips/&quot; href=&quot;http://graph.tips/&quot; class=&quot;externalLink&quot;&gt;http://graph.tips/&lt;/a&gt;&lt;br&gt;</description>
<category>SocialNetwork</category>
<link>http://karlarao.tiddlyspot.com#Facebook</link>
<pubDate>Thu, 14 Dec 2017 06:19:00 GMT</pubDate>

</item>
<item>
<title>Accenture Enkitec Courses</title>
<description>&lt;blockquote&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/curator/chanea-heard&quot; href=&quot;https://connectedlearning.accenture.com/curator/chanea-heard&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/curator/chanea-heard&lt;/a&gt;&lt;br&gt;Golden Gate Admin &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/learningboard/goldengate-administration&quot; href=&quot;https://connectedlearning.accenture.com/learningboard/goldengate-administration&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/learningboard/goldengate-administration&lt;/a&gt;&lt;br&gt;APEX &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/16597&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/16597&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/16597&lt;/a&gt;&lt;br&gt;ZFS storage appliance &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/learningboard/16600-zfs-storage-appliance&quot; href=&quot;https://connectedlearning.accenture.com/learningboard/16600-zfs-storage-appliance&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/learningboard/16600-zfs-storage-appliance&lt;/a&gt;&lt;br&gt;SPARC Supercluster Admin &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/16596&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/16596&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/16596&lt;/a&gt;&lt;br&gt;Exadata Admin &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/12954&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/12954&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/12954&lt;/a&gt;&lt;br&gt;Exadata Optimizations &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/13051&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/13051&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/13051&lt;/a&gt;&lt;br&gt;All AEG &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/learningactivities&quot; href=&quot;https://connectedlearning.accenture.com/learningactivities&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/learningactivities&lt;/a&gt;&lt;br&gt;SQL Tuning with SQLTXPLAIN &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/13097&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/13097&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/13097&lt;/a&gt;&lt;br&gt;E4 2015 &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/13512&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/13512&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/13512&lt;/a&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://mediaexchange.accenture.com/tag/tagid/hadoop&quot; href=&quot;https://mediaexchange.accenture.com/tag/tagid/hadoop&quot; class=&quot;externalLink&quot;&gt;https://mediaexchange.accenture.com/tag/tagid/hadoop&lt;/a&gt;&lt;br&gt;AEG webinars &lt;a target=&quot;_blank&quot; title=&quot;External link to https://connectedlearning.accenture.com/leaning-list-view/110872&quot; href=&quot;https://connectedlearning.accenture.com/leaning-list-view/110872&quot; class=&quot;externalLink&quot;&gt;https://connectedlearning.accenture.com/leaning-list-view/110872&lt;/a&gt;&lt;br&gt;media exchange tag &quot;enkitec&quot; &lt;a target=&quot;_blank&quot; title=&quot;External link to https://mediaexchange.accenture.com/tag/tagid/enkitec&quot; href=&quot;https://mediaexchange.accenture.com/tag/tagid/enkitec&quot; class=&quot;externalLink&quot;&gt;https://mediaexchange.accenture.com/tag/tagid/enkitec&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; Oracle Unlimited Learning Subscription &lt;/h1&gt;&lt;br&gt;&lt;blockquote&gt;Your Unlimited Learning Subscription provides you with:&lt;br&gt; &lt;br&gt;-          Unlimited access to all courses in the Oracle University &lt;a tiddlylink=&quot;Training-on-Demand&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#Training-on-Demand&quot; href=&quot;http://karlarao.tiddlyspot.com#Training-on-Demand&quot; class=&quot;externalLink null&quot;&gt;Training-on-Demand&lt;/a&gt; (&lt;a tiddlylink=&quot;ToD&quot; refresh=&quot;link&quot; target=&quot;_blank&quot; title=&quot;External link to http://karlarao.tiddlyspot.com#ToD&quot; href=&quot;http://karlarao.tiddlyspot.com#ToD&quot; class=&quot;externalLink null&quot;&gt;ToD&lt;/a&gt;) catalog – over 450 titles of in depth training courses for Database, Applications and Middleware&lt;br&gt;-          Unlimited access to all Oracle University Learning Subscriptions, including the latest in Oracle’s Cloud Solutions, Product Solutions and Industry Solutions&lt;br&gt;-          Unlimited access to all Oracle University Learning Streams for continuous learning around Oracle’s  Database, Middleware, EBS and PSFT products&lt;br&gt;-          Access to Public live virtual classroom training sessions offered by Oracle University in the case that a Training on Demand is not available&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://urldefense.proofpoint.com/v2/url?u=http-3A__launch.oracle.com_-3Faglp&amp;amp;d=CwMFAg&amp;amp;c=eIGjsITfXP_y-DLLX0uEHXJvU8nOHrUK8IrwNKOtkVU&amp;amp;r=uuYKy3Gs1_0JIUEV5KRRHtJRajKnrRi8D07dW2RkXus&amp;amp;m=2h0zMlY_aYkRW_DfSm0TQNCIUJvQ5Ym10XaIfNNla8M&amp;amp;s=ku1WbuFdaZky-ezYS3fnO2V0R9RXG75rJctvZg-ztY0&amp;amp;e&quot; href=&quot;https://urldefense.proofpoint.com/v2/url?u=http-3A__launch.oracle.com_-3Faglp&amp;amp;d=CwMFAg&amp;amp;c=eIGjsITfXP_y-DLLX0uEHXJvU8nOHrUK8IrwNKOtkVU&amp;amp;r=uuYKy3Gs1_0JIUEV5KRRHtJRajKnrRi8D07dW2RkXus&amp;amp;m=2h0zMlY_aYkRW_DfSm0TQNCIUJvQ5Ym10XaIfNNla8M&amp;amp;s=ku1WbuFdaZky-ezYS3fnO2V0R9RXG75rJctvZg-ztY0&amp;amp;e&quot; class=&quot;externalLink&quot;&gt;https://urldefense.proofpoint.com/v2/url?u=http-3A__launch.oracle.com_-3Faglp&amp;amp;d=CwMFAg&amp;amp;c=eIGjsITfXP_y-DLLX0uEHXJvU8nOHrUK8IrwNKOtkVU&amp;amp;r=uuYKy3Gs1_0JIUEV5KRRHtJRajKnrRi8D07dW2RkXus&amp;amp;m=2h0zMlY_aYkRW_DfSm0TQNCIUJvQ5Ym10XaIfNNla8M&amp;amp;s=ku1WbuFdaZky-ezYS3fnO2V0R9RXG75rJctvZg-ztY0&amp;amp;e&lt;/a&gt;=&lt;br&gt;&lt;br&gt;Digital Training Learning Portal &lt;a target=&quot;_blank&quot; title=&quot;External link to https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,986&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; href=&quot;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,986&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; class=&quot;externalLink&quot;&gt;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,986&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&lt;/a&gt;&lt;br&gt;&lt;br&gt;Program Overview &lt;a target=&quot;_blank&quot; title=&quot;External link to http://link.brightcove.com/services/player/bcpid1799411699001?bckey=AQ~~,AAABmsB_z2k~,HvNx0XQhsPxXu5er5IYkstkCq_O9j5dg&amp;amp;bctid=4731151798001&quot; href=&quot;http://link.brightcove.com/services/player/bcpid1799411699001?bckey=AQ%7E%7E,AAABmsB_z2k%7E,HvNx0XQhsPxXu5er5IYkstkCq_O9j5dg&amp;amp;bctid=4731151798001&quot; class=&quot;externalLink&quot;&gt;http://link.brightcove.com/services/player/bcpid1799411699001?bckey=AQ~~,AAABmsB_z2k~,HvNx0XQhsPxXu5er5IYkstkCq_O9j5dg&amp;amp;bctid=4731151798001&lt;/a&gt;&lt;br&gt;&lt;br&gt;Learning Paths &lt;a target=&quot;_blank&quot; title=&quot;External link to https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,976&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; href=&quot;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,976&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&quot; class=&quot;externalLink&quot;&gt;https://isdportal.oracle.com/pls/portal/tsr_admin.page.main?pageid=33,976&amp;amp;dad=portal&amp;amp;schema=PORTAL&amp;amp;p_k=hCwPEObICeHNWFJNdHCxsnXIyaWOpibldVWGShuxqGCGEmtoGCkVshGgcTdu1191413973&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;&lt;br&gt;</description>
<category>.video content</category>
<link>http://karlarao.tiddlyspot.com#%5B%5BAccenture%20Enkitec%20Courses%5D%5D</link>
<pubDate>Tue, 12 Sep 2017 15:04:00 GMT</pubDate>

</item>
<item>
<title>..Stats Gathering Procedure</title>
<description>&lt;pre&gt;parameters: 
    p_owner       
    p_tabname     
    p_partname    
    p_granularity 
    p_est_percent 
    p_method_opt
    p_degree
&lt;/pre&gt;&lt;br&gt;&lt;pre&gt;
CREATE OR REPLACE PROCEDURE alloc_app_perf.table_stats 
( 
    p_owner IN varchar2,
    p_tabname IN varchar2, 
    p_partname IN varchar2 default NULL,  
    p_granularity IN varchar2 default 'GLOBAL AND PARTITION',
    p_est_percent IN varchar2 default 'DBMS_STATS.AUTO_SAMPLE_SIZE',
    p_method_opt IN varchar2 default 'FOR ALL COLUMNS SIZE AUTO',
    p_degree IN varchar2 default 8
) 
IS
    action varchar2(128);
    v_mode varchar2(30);
    cmd varchar2(2000);
BEGIN
    action := 'Analyzing the table ' || p_tabname; 
    IF p_partname IS NOT NULL THEN
        action := action||', partition '||p_partname;
        v_mode := p_granularity;

        cmd := '
        BEGIN 
            DBMS_STATS.GATHER_TABLE_STATS('||
            'ownname=&amp;gt;'''||p_owner||''',tabname=&amp;gt;'''||p_tabname||
            ''',partname=&amp;gt;'''||p_partname||''',granularity=&amp;gt;'''||v_mode||
            ''',estimate_percent=&amp;gt;'||p_est_percent||',method_opt=&amp;gt;'''||p_method_opt||''',cascade=&amp;gt;TRUE,degree=&amp;gt;'||p_degree||');
        END;';

        execute immediate cmd;
    ELSE 
        v_mode := 'DEFAULT';

        cmd := '
        BEGIN 
            DBMS_STATS.GATHER_TABLE_STATS('||
            'ownname=&amp;gt;'''||p_owner||''',tabname=&amp;gt;'''||p_tabname||
            ''',estimate_percent=&amp;gt;'||p_est_percent||',method_opt=&amp;gt;'''||p_method_opt||''',cascade=&amp;gt;TRUE,degree=&amp;gt;'||p_degree||');
        END;';

        execute immediate cmd;
    END IF; 
END;
/

&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;pre&gt;
grant analyze any to alloc_app_perf;
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'CLASS_SALES')
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'CLASS_SALES',p_est_percent=&amp;gt;'dbms_stats.auto_sample_size')
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'CLASS_SALES',p_est_percent=&amp;gt;'1')

exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'DBA_OBJECTS')
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'DBA_OBJECTS',p_est_percent=&amp;gt;'1')
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'DBA_OBJECTS',p_est_percent=&amp;gt;'100')
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'DBA_OBJECTS',p_est_percent=&amp;gt;'dbms_stats.auto_sample_size')

exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'DEMO_SKEW')
exec alloc_app_perf.table_stats(p_owner=&amp;gt;'BAS',p_tabname=&amp;gt;'DEMO_SKEW',p_method_opt=&amp;gt;'for all columns size skewonly')


&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; generate stats commands &lt;/h1&gt;&lt;pre&gt;
set lines 500
set pages 0
select 'exec alloc_app_perf.table_stats(p_owner=&amp;gt;'''||owner||''',p_tabname=&amp;gt;'''||table_name||''',p_degree=&amp;gt;''16'');'
from dba_tables where table_name in 
('ALGO_INPUT_FOR_REVIEW'        
,'ALLOCATED_NOTSHIPPED_INVS'     
,'ALLOC_BATCH_LINE_ITEMS'        
,'ALLOC_BATCH_VOLUMEGRADE_CHANGE'
,'ALLOC_SKU0_MASTER'             
,'ALLOC_SKU_MASTER'              
,'ALLOC_STORES'                  
,'EOM_NEED_UNITS'                
,'EOM_UNIT_TARGETS'              
,'INVENTORY_CLASSES'             
,'SIM_CLASSES'                   
,'STAGING_STORES'                
,'STORE_ON_ORDERS'               
,'STORE_WAREHOUSE_DETAILS'       
,'VOLUME_GRADE_CONSTRAINTS')
/


&lt;/pre&gt;&lt;br&gt;</description>
<category>stats gathering</category>
<category>DatabaseHealthCheck</category>
<link>http://karlarao.tiddlyspot.com#%5B%5B..Stats%20Gathering%20Procedure%5D%5D</link>
<pubDate>Wed, 30 Aug 2017 19:43:00 GMT</pubDate>

</item>
<item>
<title>postgre source code</title>
<description>&lt;pre&gt;/*-------------------------------------------------------------------------
 *
 * fe-exec.c
 *	  functions related to sending a query down to the backend
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-exec.c
 *
 *-------------------------------------------------------------------------
 */
#include &quot;postgres_fe.h&quot;

#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

#include &quot;libpq-fe.h&quot;
#include &quot;libpq-int.h&quot;

#include &quot;mb/pg_wchar.h&quot;

#ifdef WIN32
#include &quot;win32.h&quot;
#else
#include &amp;lt;unistd.h&amp;gt;
#endif

/* keep this in same order as ExecStatusType in libpq-fe.h */
char	   *const pgresStatus[] = {
	&quot;PGRES_EMPTY_QUERY&quot;,
	&quot;PGRES_COMMAND_OK&quot;,
	&quot;PGRES_TUPLES_OK&quot;,
	&quot;PGRES_COPY_OUT&quot;,
	&quot;PGRES_COPY_IN&quot;,
	&quot;PGRES_BAD_RESPONSE&quot;,
	&quot;PGRES_NONFATAL_ERROR&quot;,
	&quot;PGRES_FATAL_ERROR&quot;,
	&quot;PGRES_COPY_BOTH&quot;,
	&quot;PGRES_SINGLE_TUPLE&quot;
};

/*
 * static state needed by PQescapeString and PQescapeBytea; initialize to
 * values that result in backward-compatible behavior
 */
static int	static_client_encoding = PG_SQL_ASCII;
static bool static_std_strings = false;


static PGEvent *dupEvents(PGEvent *events, int count);
static bool pqAddTuple(PGresult *res, PGresAttValue *tup);
static bool PQsendQueryStart(PGconn *conn);
static int PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat);
static void parseInput(PGconn *conn);
static PGresult *getCopyResult(PGconn *conn, ExecStatusType copytype);
static bool PQexecStart(PGconn *conn);
static PGresult *PQexecFinish(PGconn *conn);
static int PQsendDescribe(PGconn *conn, char desc_type,
			   const char *desc_target);
static int	check_field_number(const PGresult *res, int field_num);


/* ----------------
 * Space management for PGresult.
 *
 * Formerly, libpq did a separate malloc() for each field of each tuple
 * returned by a query.  This was remarkably expensive --- malloc/free
 * consumed a sizable part of the application's runtime.  And there is
 * no real need to keep track of the fields separately, since they will
 * all be freed together when the PGresult is released.  So now, we grab
 * large blocks of storage from malloc and allocate space for query data
 * within these blocks, using a trivially simple allocator.  This reduces
 * the number of malloc/free calls dramatically, and it also avoids
 * fragmentation of the malloc storage arena.
 * The PGresult structure itself is still malloc'd separately.  We could
 * combine it with the first allocation block, but that would waste space
 * for the common case that no extra storage is actually needed (that is,
 * the SQL command did not return tuples).
 *
 * We also malloc the top-level array of tuple pointers separately, because
 * we need to be able to enlarge it via realloc, and our trivial space
 * allocator doesn't handle that effectively.  (Too bad the FE/BE protocol
 * doesn't tell us up front how many tuples will be returned.)
 * All other subsidiary storage for a PGresult is kept in PGresult_data blocks
 * of size PGRESULT_DATA_BLOCKSIZE.  The overhead at the start of each block
 * is just a link to the next one, if any.  Free-space management info is
 * kept in the owning PGresult.
 * A query returning a small amount of data will thus require three malloc
 * calls: one for the PGresult, one for the tuples pointer array, and one
 * PGresult_data block.
 *
 * Only the most recently allocated PGresult_data block is a candidate to
 * have more stuff added to it --- any extra space left over in older blocks
 * is wasted.  We could be smarter and search the whole chain, but the point
 * here is to be simple and fast.  Typical applications do not keep a PGresult
 * around very long anyway, so some wasted space within one is not a problem.
 *
 * Tuning constants for the space allocator are:
 * PGRESULT_DATA_BLOCKSIZE: size of a standard allocation block, in bytes
 * PGRESULT_ALIGN_BOUNDARY: assumed alignment requirement for binary data
 * PGRESULT_SEP_ALLOC_THRESHOLD: objects bigger than this are given separate
 *	 blocks, instead of being crammed into a regular allocation block.
 * Requirements for correct function are:
 * PGRESULT_ALIGN_BOUNDARY must be a multiple of the alignment requirements
 *		of all machine data types.  (Currently this is set from configure
 *		tests, so it should be OK automatically.)
 * PGRESULT_SEP_ALLOC_THRESHOLD + PGRESULT_BLOCK_OVERHEAD &amp;lt;=
 *			PGRESULT_DATA_BLOCKSIZE
 *		pqResultAlloc assumes an object smaller than the threshold will fit
 *		in a new block.
 * The amount of space wasted at the end of a block could be as much as
 * PGRESULT_SEP_ALLOC_THRESHOLD, so it doesn't pay to make that too large.
 * ----------------
 */

#define PGRESULT_DATA_BLOCKSIZE		2048
#define PGRESULT_ALIGN_BOUNDARY		MAXIMUM_ALIGNOF		/* from configure */
#define PGRESULT_BLOCK_OVERHEAD		Max(sizeof(PGresult_data), PGRESULT_ALIGN_BOUNDARY)
#define PGRESULT_SEP_ALLOC_THRESHOLD	(PGRESULT_DATA_BLOCKSIZE / 2)


/*
 * PQmakeEmptyPGresult
 *	 returns a newly allocated, initialized PGresult with given status.
 *	 If conn is not NULL and status indicates an error, the conn's
 *	 errorMessage is copied.  Also, any PGEvents are copied from the conn.
 */
PGresult *
PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status)
{
	PGresult   *result;

	result = (PGresult *) malloc(sizeof(PGresult));
	if (!result)
		return NULL;

	result-&amp;gt;ntups = 0;
	result-&amp;gt;numAttributes = 0;
	result-&amp;gt;attDescs = NULL;
	result-&amp;gt;tuples = NULL;
	result-&amp;gt;tupArrSize = 0;
	result-&amp;gt;numParameters = 0;
	result-&amp;gt;paramDescs = NULL;
	result-&amp;gt;resultStatus = status;
	result-&amp;gt;cmdStatus[0] = '\0';
	result-&amp;gt;binary = 0;
	result-&amp;gt;events = NULL;
	result-&amp;gt;nEvents = 0;
	result-&amp;gt;errMsg = NULL;
	result-&amp;gt;errFields = NULL;
	result-&amp;gt;errQuery = NULL;
	result-&amp;gt;null_field[0] = '\0';
	result-&amp;gt;curBlock = NULL;
	result-&amp;gt;curOffset = 0;
	result-&amp;gt;spaceLeft = 0;

	if (conn)
	{
		/* copy connection data we might need for operations on PGresult */
		result-&amp;gt;noticeHooks = conn-&amp;gt;noticeHooks;
		result-&amp;gt;client_encoding = conn-&amp;gt;client_encoding;

		/* consider copying conn's errorMessage */
		switch (status)
		{
			case PGRES_EMPTY_QUERY:
			case PGRES_COMMAND_OK:
			case PGRES_TUPLES_OK:
			case PGRES_COPY_OUT:
			case PGRES_COPY_IN:
			case PGRES_COPY_BOTH:
			case PGRES_SINGLE_TUPLE:
				/* non-error cases */
				break;
			default:
				pqSetResultError(result, conn-&amp;gt;errorMessage.data);
				break;
		}

		/* copy events last; result must be valid if we need to PQclear */
		if (conn-&amp;gt;nEvents &amp;gt; 0)
		{
			result-&amp;gt;events = dupEvents(conn-&amp;gt;events, conn-&amp;gt;nEvents);
			if (!result-&amp;gt;events)
			{
				PQclear(result);
				return NULL;
			}
			result-&amp;gt;nEvents = conn-&amp;gt;nEvents;
		}
	}
	else
	{
		/* defaults... */
		result-&amp;gt;noticeHooks.noticeRec = NULL;
		result-&amp;gt;noticeHooks.noticeRecArg = NULL;
		result-&amp;gt;noticeHooks.noticeProc = NULL;
		result-&amp;gt;noticeHooks.noticeProcArg = NULL;
		result-&amp;gt;client_encoding = PG_SQL_ASCII;
	}

	return result;
}

/*
 * PQsetResultAttrs
 *
 * Set the attributes for a given result.  This function fails if there are
 * already attributes contained in the provided result.  The call is
 * ignored if numAttributes is zero or attDescs is NULL.  If the
 * function fails, it returns zero.  If the function succeeds, it
 * returns a non-zero value.
 */
int
PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs)
{
	int			i;

	/* If attrs already exist, they cannot be overwritten. */
	if (!res || res-&amp;gt;numAttributes &amp;gt; 0)
		return FALSE;

	/* ignore no-op request */
	if (numAttributes &amp;lt;= 0 || !attDescs)
		return TRUE;

	res-&amp;gt;attDescs = (PGresAttDesc *)
		PQresultAlloc(res, numAttributes * sizeof(PGresAttDesc));

	if (!res-&amp;gt;attDescs)
		return FALSE;

	res-&amp;gt;numAttributes = numAttributes;
	memcpy(res-&amp;gt;attDescs, attDescs, numAttributes * sizeof(PGresAttDesc));

	/* deep-copy the attribute names, and determine format */
	res-&amp;gt;binary = 1;
	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (res-&amp;gt;attDescs[i].name)
			res-&amp;gt;attDescs[i].name = pqResultStrdup(res, res-&amp;gt;attDescs[i].name);
		else
			res-&amp;gt;attDescs[i].name = res-&amp;gt;null_field;

		if (!res-&amp;gt;attDescs[i].name)
			return FALSE;

		if (res-&amp;gt;attDescs[i].format == 0)
			res-&amp;gt;binary = 0;
	}

	return TRUE;
}

/*
 * PQcopyResult
 *
 * Returns a deep copy of the provided 'src' PGresult, which cannot be NULL.
 * The 'flags' argument controls which portions of the result will or will
 * NOT be copied.  The created result is always put into the
 * PGRES_TUPLES_OK status.  The source result error message is not copied,
 * although cmdStatus is.
 *
 * To set custom attributes, use PQsetResultAttrs.  That function requires
 * that there are no attrs contained in the result, so to use that
 * function you cannot use the PG_COPYRES_ATTRS or PG_COPYRES_TUPLES
 * options with this function.
 *
 * Options:
 *	 PG_COPYRES_ATTRS - Copy the source result's attributes
 *
 *	 PG_COPYRES_TUPLES - Copy the source result's tuples.  This implies
 *	 copying the attrs, seeing how the attrs are needed by the tuples.
 *
 *	 PG_COPYRES_EVENTS - Copy the source result's events.
 *
 *	 PG_COPYRES_NOTICEHOOKS - Copy the source result's notice hooks.
 */
PGresult *
PQcopyResult(const PGresult *src, int flags)
{
	PGresult   *dest;
	int			i;

	if (!src)
		return NULL;

	dest = PQmakeEmptyPGresult(NULL, PGRES_TUPLES_OK);
	if (!dest)
		return NULL;

	/* Always copy these over.  Is cmdStatus really useful here? */
	dest-&amp;gt;client_encoding = src-&amp;gt;client_encoding;
	strcpy(dest-&amp;gt;cmdStatus, src-&amp;gt;cmdStatus);

	/* Wants attrs? */
	if (flags &amp;amp; (PG_COPYRES_ATTRS | PG_COPYRES_TUPLES))
	{
		if (!PQsetResultAttrs(dest, src-&amp;gt;numAttributes, src-&amp;gt;attDescs))
		{
			PQclear(dest);
			return NULL;
		}
	}

	/* Wants to copy tuples? */
	if (flags &amp;amp; PG_COPYRES_TUPLES)
	{
		int			tup,
					field;

		for (tup = 0; tup &amp;lt; src-&amp;gt;ntups; tup++)
		{
			for (field = 0; field &amp;lt; src-&amp;gt;numAttributes; field++)
			{
				if (!PQsetvalue(dest, tup, field,
								src-&amp;gt;tuples[tup][field].value,
								src-&amp;gt;tuples[tup][field].len))
				{
					PQclear(dest);
					return NULL;
				}
			}
		}
	}

	/* Wants to copy notice hooks? */
	if (flags &amp;amp; PG_COPYRES_NOTICEHOOKS)
		dest-&amp;gt;noticeHooks = src-&amp;gt;noticeHooks;

	/* Wants to copy PGEvents? */
	if ((flags &amp;amp; PG_COPYRES_EVENTS) &amp;amp;&amp;amp; src-&amp;gt;nEvents &amp;gt; 0)
	{
		dest-&amp;gt;events = dupEvents(src-&amp;gt;events, src-&amp;gt;nEvents);
		if (!dest-&amp;gt;events)
		{
			PQclear(dest);
			return NULL;
		}
		dest-&amp;gt;nEvents = src-&amp;gt;nEvents;
	}

	/* Okay, trigger PGEVT_RESULTCOPY event */
	for (i = 0; i &amp;lt; dest-&amp;gt;nEvents; i++)
	{
		if (src-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultCopy evt;

			evt.src = src;
			evt.dest = dest;
			if (!dest-&amp;gt;events[i].proc(PGEVT_RESULTCOPY, &amp;amp;evt,
									  dest-&amp;gt;events[i].passThrough))
			{
				PQclear(dest);
				return NULL;
			}
			dest-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return dest;
}

/*
 * Copy an array of PGEvents (with no extra space for more).
 * Does not duplicate the event instance data, sets this to NULL.
 * Also, the resultInitialized flags are all cleared.
 */
static PGEvent *
dupEvents(PGEvent *events, int count)
{
	PGEvent    *newEvents;
	int			i;

	if (!events || count &amp;lt;= 0)
		return NULL;

	newEvents = (PGEvent *) malloc(count * sizeof(PGEvent));
	if (!newEvents)
		return NULL;

	for (i = 0; i &amp;lt; count; i++)
	{
		newEvents[i].proc = events[i].proc;
		newEvents[i].passThrough = events[i].passThrough;
		newEvents[i].data = NULL;
		newEvents[i].resultInitialized = FALSE;
		newEvents[i].name = strdup(events[i].name);
		if (!newEvents[i].name)
		{
			while (--i &amp;gt;= 0)
				free(newEvents[i].name);
			free(newEvents);
			return NULL;
		}
	}

	return newEvents;
}


/*
 * Sets the value for a tuple field.  The tup_num must be less than or
 * equal to PQntuples(res).  If it is equal, a new tuple is created and
 * added to the result.
 * Returns a non-zero value for success and zero for failure.
 */
int
PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len)
{
	PGresAttValue *attval;

	if (!check_field_number(res, field_num))
		return FALSE;

	/* Invalid tup_num, must be &amp;lt;= ntups */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt; res-&amp;gt;ntups)
		return FALSE;

	/* need to allocate a new tuple? */
	if (tup_num == res-&amp;gt;ntups)
	{
		PGresAttValue *tup;
		int			i;

		tup = (PGresAttValue *)
			pqResultAlloc(res, res-&amp;gt;numAttributes * sizeof(PGresAttValue),
						  TRUE);

		if (!tup)
			return FALSE;

		/* initialize each column to NULL */
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
		{
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}

		/* add it to the array */
		if (!pqAddTuple(res, tup))
			return FALSE;
	}

	attval = &amp;amp;res-&amp;gt;tuples[tup_num][field_num];

	/* treat either NULL_LEN or NULL value pointer as a NULL field */
	if (len == NULL_LEN || value == NULL)
	{
		attval-&amp;gt;len = NULL_LEN;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else if (len &amp;lt;= 0)
	{
		attval-&amp;gt;len = 0;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else
	{
		attval-&amp;gt;value = (char *) pqResultAlloc(res, len + 1, TRUE);
		if (!attval-&amp;gt;value)
			return FALSE;
		attval-&amp;gt;len = len;
		memcpy(attval-&amp;gt;value, value, len);
		attval-&amp;gt;value[len] = '\0';
	}

	return TRUE;
}

/*
 * pqResultAlloc - exported routine to allocate local storage in a PGresult.
 *
 * We force all such allocations to be maxaligned, since we don't know
 * whether the value might be binary.
 */
void *
PQresultAlloc(PGresult *res, size_t nBytes)
{
	return pqResultAlloc(res, nBytes, TRUE);
}

/*
 * pqResultAlloc -
 *		Allocate subsidiary storage for a PGresult.
 *
 * nBytes is the amount of space needed for the object.
 * If isBinary is true, we assume that we need to align the object on
 * a machine allocation boundary.
 * If isBinary is false, we assume the object is a char string and can
 * be allocated on any byte boundary.
 */
void *
pqResultAlloc(PGresult *res, size_t nBytes, bool isBinary)
{
	char	   *space;
	PGresult_data *block;

	if (!res)
		return NULL;

	if (nBytes &amp;lt;= 0)
		return res-&amp;gt;null_field;

	/*
	 * If alignment is needed, round up the current position to an alignment
	 * boundary.
	 */
	if (isBinary)
	{
		int			offset = res-&amp;gt;curOffset % PGRESULT_ALIGN_BOUNDARY;

		if (offset)
		{
			res-&amp;gt;curOffset += PGRESULT_ALIGN_BOUNDARY - offset;
			res-&amp;gt;spaceLeft -= PGRESULT_ALIGN_BOUNDARY - offset;
		}
	}

	/* If there's enough space in the current block, no problem. */
	if (nBytes &amp;lt;= (size_t) res-&amp;gt;spaceLeft)
	{
		space = res-&amp;gt;curBlock-&amp;gt;space + res-&amp;gt;curOffset;
		res-&amp;gt;curOffset += nBytes;
		res-&amp;gt;spaceLeft -= nBytes;
		return space;
	}

	/*
	 * If the requested object is very large, give it its own block; this
	 * avoids wasting what might be most of the current block to start a new
	 * block.  (We'd have to special-case requests bigger than the block size
	 * anyway.)  The object is always given binary alignment in this case.
	 */
	if (nBytes &amp;gt;= PGRESULT_SEP_ALLOC_THRESHOLD)
	{
		block = (PGresult_data *) malloc(nBytes + PGRESULT_BLOCK_OVERHEAD);
		if (!block)
			return NULL;
		space = block-&amp;gt;space + PGRESULT_BLOCK_OVERHEAD;
		if (res-&amp;gt;curBlock)
		{
			/*
			 * Tuck special block below the active block, so that we don't
			 * have to waste the free space in the active block.
			 */
			block-&amp;gt;next = res-&amp;gt;curBlock-&amp;gt;next;
			res-&amp;gt;curBlock-&amp;gt;next = block;
		}
		else
		{
			/* Must set up the new block as the first active block. */
			block-&amp;gt;next = NULL;
			res-&amp;gt;curBlock = block;
			res-&amp;gt;spaceLeft = 0; /* be sure it's marked full */
		}
		return space;
	}

	/* Otherwise, start a new block. */
	block = (PGresult_data *) malloc(PGRESULT_DATA_BLOCKSIZE);
	if (!block)
		return NULL;
	block-&amp;gt;next = res-&amp;gt;curBlock;
	res-&amp;gt;curBlock = block;
	if (isBinary)
	{
		/* object needs full alignment */
		res-&amp;gt;curOffset = PGRESULT_BLOCK_OVERHEAD;
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - PGRESULT_BLOCK_OVERHEAD;
	}
	else
	{
		/* we can cram it right after the overhead pointer */
		res-&amp;gt;curOffset = sizeof(PGresult_data);
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - sizeof(PGresult_data);
	}

	space = block-&amp;gt;space + res-&amp;gt;curOffset;
	res-&amp;gt;curOffset += nBytes;
	res-&amp;gt;spaceLeft -= nBytes;
	return space;
}

/*
 * pqResultStrdup -
 *		Like strdup, but the space is subsidiary PGresult space.
 */
char *
pqResultStrdup(PGresult *res, const char *str)
{
	char	   *space = (char *) pqResultAlloc(res, strlen(str) + 1, FALSE);

	if (space)
		strcpy(space, str);
	return space;
}

/*
 * pqSetResultError -
 *		assign a new error message to a PGresult
 */
void
pqSetResultError(PGresult *res, const char *msg)
{
	if (!res)
		return;
	if (msg &amp;amp;&amp;amp; *msg)
		res-&amp;gt;errMsg = pqResultStrdup(res, msg);
	else
		res-&amp;gt;errMsg = NULL;
}

/*
 * pqCatenateResultError -
 *		concatenate a new error message to the one already in a PGresult
 */
void
pqCatenateResultError(PGresult *res, const char *msg)
{
	PQExpBufferData errorBuf;

	if (!res || !msg)
		return;
	initPQExpBuffer(&amp;amp;errorBuf);
	if (res-&amp;gt;errMsg)
		appendPQExpBufferStr(&amp;amp;errorBuf, res-&amp;gt;errMsg);
	appendPQExpBufferStr(&amp;amp;errorBuf, msg);
	pqSetResultError(res, errorBuf.data);
	termPQExpBuffer(&amp;amp;errorBuf);
}

/*
 * PQclear -
 *	  free's the memory associated with a PGresult
 */
void
PQclear(PGresult *res)
{
	PGresult_data *block;
	int			i;

	if (!res)
		return;

	for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
	{
		/* only send DESTROY to successfully-initialized event procs */
		if (res-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultDestroy evt;

			evt.result = res;
			(void) res-&amp;gt;events[i].proc(PGEVT_RESULTDESTROY, &amp;amp;evt,
									   res-&amp;gt;events[i].passThrough);
		}
		free(res-&amp;gt;events[i].name);
	}

	if (res-&amp;gt;events)
		free(res-&amp;gt;events);

	/* Free all the subsidiary blocks */
	while ((block = res-&amp;gt;curBlock) != NULL)
	{
		res-&amp;gt;curBlock = block-&amp;gt;next;
		free(block);
	}

	/* Free the top-level tuple pointer array */
	if (res-&amp;gt;tuples)
		free(res-&amp;gt;tuples);

	/* zero out the pointer fields to catch programming errors */
	res-&amp;gt;attDescs = NULL;
	res-&amp;gt;tuples = NULL;
	res-&amp;gt;paramDescs = NULL;
	res-&amp;gt;errFields = NULL;
	res-&amp;gt;events = NULL;
	res-&amp;gt;nEvents = 0;
	/* res-&amp;gt;curBlock was zeroed out earlier */

	/* Free the PGresult structure itself */
	free(res);
}

/*
 * Handy subroutine to deallocate any partially constructed async result.
 *
 * Any &quot;next&quot; result gets cleared too.
 */
void
pqClearAsyncResult(PGconn *conn)
{
	if (conn-&amp;gt;result)
		PQclear(conn-&amp;gt;result);
	conn-&amp;gt;result = NULL;
	if (conn-&amp;gt;next_result)
		PQclear(conn-&amp;gt;next_result);
	conn-&amp;gt;next_result = NULL;
}

/*
 * This subroutine deletes any existing async result, sets conn-&amp;gt;result
 * to a PGresult with status PGRES_FATAL_ERROR, and stores the current
 * contents of conn-&amp;gt;errorMessage into that result.  It differs from a
 * plain call on PQmakeEmptyPGresult() in that if there is already an
 * async result with status PGRES_FATAL_ERROR, the current error message
 * is APPENDED to the old error message instead of replacing it.  This
 * behavior lets us report multiple error conditions properly, if necessary.
 * (An example where this is needed is when the backend sends an 'E' message
 * and immediately closes the connection --- we want to report both the
 * backend error and the connection closure error.)
 */
void
pqSaveErrorResult(PGconn *conn)
{
	/*
	 * If no old async result, just let PQmakeEmptyPGresult make one. Likewise
	 * if old result is not an error message.
	 */
	if (conn-&amp;gt;result == NULL ||
		conn-&amp;gt;result-&amp;gt;resultStatus != PGRES_FATAL_ERROR ||
		conn-&amp;gt;result-&amp;gt;errMsg == NULL)
	{
		pqClearAsyncResult(conn);
		conn-&amp;gt;result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	}
	else
	{
		/* Else, concatenate error message to existing async result. */
		pqCatenateResultError(conn-&amp;gt;result, conn-&amp;gt;errorMessage.data);
	}
}

/*
 * This subroutine prepares an async result object for return to the caller.
 * If there is not already an async result object, build an error object
 * using whatever is in conn-&amp;gt;errorMessage.  In any case, clear the async
 * result storage and make sure PQerrorMessage will agree with the result's
 * error string.
 */
PGresult *
pqPrepareAsyncResult(PGconn *conn)
{
	PGresult   *res;

	/*
	 * conn-&amp;gt;result is the PGresult to return.  If it is NULL (which probably
	 * shouldn't happen) we assume there is an appropriate error message in
	 * conn-&amp;gt;errorMessage.
	 */
	res = conn-&amp;gt;result;
	if (!res)
		res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	else
	{
		/*
		 * Make sure PQerrorMessage agrees with result; it could be different
		 * if we have concatenated messages.
		 */
		resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
		appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage,
							 PQresultErrorMessage(res));
	}

	/*
	 * Replace conn-&amp;gt;result with next_result, if any.  In the normal case
	 * there isn't a next result and we're just dropping ownership of the
	 * current result.  In single-row mode this restores the situation to what
	 * it was before we created the current single-row result.
	 */
	conn-&amp;gt;result = conn-&amp;gt;next_result;
	conn-&amp;gt;next_result = NULL;

	return res;
}

/*
 * pqInternalNotice - produce an internally-generated notice message
 *
 * A format string and optional arguments can be passed.  Note that we do
 * libpq_gettext() here, so callers need not.
 *
 * The supplied text is taken as primary message (ie., it should not include
 * a trailing newline, and should not be more than one line).
 */
void
pqInternalNotice(const PGNoticeHooks *hooks, const char *fmt,...)
{
	char		msgBuf[1024];
	va_list		args;
	PGresult   *res;

	if (hooks-&amp;gt;noticeRec == NULL)
		return;					/* nobody home to receive notice? */

	/* Format the message */
	va_start(args, fmt);
	vsnprintf(msgBuf, sizeof(msgBuf), libpq_gettext(fmt), args);
	va_end(args);
	msgBuf[sizeof(msgBuf) - 1] = '\0';	/* make real sure it's terminated */

	/* Make a PGresult to pass to the notice receiver */
	res = PQmakeEmptyPGresult(NULL, PGRES_NONFATAL_ERROR);
	if (!res)
		return;
	res-&amp;gt;noticeHooks = *hooks;

	/*
	 * Set up fields of notice.
	 */
	pqSaveMessageField(res, PG_DIAG_MESSAGE_PRIMARY, msgBuf);
	pqSaveMessageField(res, PG_DIAG_SEVERITY, libpq_gettext(&quot;NOTICE&quot;));
	pqSaveMessageField(res, PG_DIAG_SEVERITY_NONLOCALIZED, &quot;NOTICE&quot;);
	/* XXX should provide a SQLSTATE too? */

	/*
	 * Result text is always just the primary message + newline. If we can't
	 * allocate it, don't bother invoking the receiver.
	 */
	res-&amp;gt;errMsg = (char *) pqResultAlloc(res, strlen(msgBuf) + 2, FALSE);
	if (res-&amp;gt;errMsg)
	{
		sprintf(res-&amp;gt;errMsg, &quot;%s\n&quot;, msgBuf);

		/*
		 * Pass to receiver, then free it.
		 */
		(*res-&amp;gt;noticeHooks.noticeRec) (res-&amp;gt;noticeHooks.noticeRecArg, res);
	}
	PQclear(res);
}

/*
 * pqAddTuple
 *	  add a row pointer to the PGresult structure, growing it if necessary
 *	  Returns TRUE if OK, FALSE if not enough memory to add the row
 */
static bool
pqAddTuple(PGresult *res, PGresAttValue *tup)
{
	if (res-&amp;gt;ntups &amp;gt;= res-&amp;gt;tupArrSize)
	{
		/*
		 * Try to grow the array.
		 *
		 * We can use realloc because shallow copying of the structure is
		 * okay. Note that the first time through, res-&amp;gt;tuples is NULL. While
		 * ANSI says that realloc() should act like malloc() in that case,
		 * some old C libraries (like SunOS 4.1.x) coredump instead. On
		 * failure realloc is supposed to return NULL without damaging the
		 * existing allocation. Note that the positions beyond res-&amp;gt;ntups are
		 * garbage, not necessarily NULL.
		 */
		int			newSize = (res-&amp;gt;tupArrSize &amp;gt; 0) ? res-&amp;gt;tupArrSize * 2 : 128;
		PGresAttValue **newTuples;

		if (res-&amp;gt;tuples == NULL)
			newTuples = (PGresAttValue **)
				malloc(newSize * sizeof(PGresAttValue *));
		else
			newTuples = (PGresAttValue **)
				realloc(res-&amp;gt;tuples, newSize * sizeof(PGresAttValue *));
		if (!newTuples)
			return FALSE;		/* malloc or realloc failed */
		res-&amp;gt;tupArrSize = newSize;
		res-&amp;gt;tuples = newTuples;
	}
	res-&amp;gt;tuples[res-&amp;gt;ntups] = tup;
	res-&amp;gt;ntups++;
	return TRUE;
}

/*
 * pqSaveMessageField - save one field of an error or notice message
 */
void
pqSaveMessageField(PGresult *res, char code, const char *value)
{
	PGMessageField *pfield;

	pfield = (PGMessageField *)
		pqResultAlloc(res,
					  offsetof(PGMessageField, contents) +
					  strlen(value) + 1,
					  TRUE);
	if (!pfield)
		return;					/* out of memory? */
	pfield-&amp;gt;code = code;
	strcpy(pfield-&amp;gt;contents, value);
	pfield-&amp;gt;next = res-&amp;gt;errFields;
	res-&amp;gt;errFields = pfield;
}

/*
 * pqSaveParameterStatus - remember parameter status sent by backend
 */
void
pqSaveParameterStatus(PGconn *conn, const char *name, const char *value)
{
	pgParameterStatus *pstatus;
	pgParameterStatus *prev;

	if (conn-&amp;gt;Pfdebug)
		fprintf(conn-&amp;gt;Pfdebug, &quot;pqSaveParameterStatus: '%s' = '%s'\n&quot;,
				name, value);

	/*
	 * Forget any old information about the parameter
	 */
	for (pstatus = conn-&amp;gt;pstatus, prev = NULL;
		 pstatus != NULL;
		 prev = pstatus, pstatus = pstatus-&amp;gt;next)
	{
		if (strcmp(pstatus-&amp;gt;name, name) == 0)
		{
			if (prev)
				prev-&amp;gt;next = pstatus-&amp;gt;next;
			else
				conn-&amp;gt;pstatus = pstatus-&amp;gt;next;
			free(pstatus);		/* frees name and value strings too */
			break;
		}
	}

	/*
	 * Store new info as a single malloc block
	 */
	pstatus = (pgParameterStatus *) malloc(sizeof(pgParameterStatus) +
										   strlen(name) +strlen(value) + 2);
	if (pstatus)
	{
		char	   *ptr;

		ptr = ((char *) pstatus) + sizeof(pgParameterStatus);
		pstatus-&amp;gt;name = ptr;
		strcpy(ptr, name);
		ptr += strlen(name) + 1;
		pstatus-&amp;gt;value = ptr;
		strcpy(ptr, value);
		pstatus-&amp;gt;next = conn-&amp;gt;pstatus;
		conn-&amp;gt;pstatus = pstatus;
	}

	/*
	 * Special hacks: remember client_encoding and
	 * standard_conforming_strings, and convert server version to a numeric
	 * form.  We keep the first two of these in static variables as well, so
	 * that PQescapeString and PQescapeBytea can behave somewhat sanely (at
	 * least in single-connection-using programs).
	 */
	if (strcmp(name, &quot;client_encoding&quot;) == 0)
	{
		conn-&amp;gt;client_encoding = pg_char_to_encoding(value);
		/* if we don't recognize the encoding name, fall back to SQL_ASCII */
		if (conn-&amp;gt;client_encoding &amp;lt; 0)
			conn-&amp;gt;client_encoding = PG_SQL_ASCII;
		static_client_encoding = conn-&amp;gt;client_encoding;
	}
	else if (strcmp(name, &quot;standard_conforming_strings&quot;) == 0)
	{
		conn-&amp;gt;std_strings = (strcmp(value, &quot;on&quot;) == 0);
		static_std_strings = conn-&amp;gt;std_strings;
	}
	else if (strcmp(name, &quot;server_version&quot;) == 0)
	{
		int			cnt;
		int			vmaj,
					vmin,
					vrev;

		cnt = sscanf(value, &quot;%d.%d.%d&quot;, &amp;amp;vmaj, &amp;amp;vmin, &amp;amp;vrev);

		if (cnt == 3)
		{
			/* old style, e.g. 9.6.1 */
			conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100 + vrev;
		}
		else if (cnt == 2)
		{
			if (vmaj &amp;gt;= 10)
			{
				/* new style, e.g. 10.1 */
				conn-&amp;gt;sversion = 100 * 100 * vmaj + vmin;
			}
			else
			{
				/* old style without minor version, e.g. 9.6devel */
				conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100;
			}
		}
		else if (cnt == 1)
		{
			/* new style without minor version, e.g. 10devel */
			conn-&amp;gt;sversion = 100 * 100 * vmaj;
		}
		else
			conn-&amp;gt;sversion = 0; /* unknown */
	}
}


/*
 * pqRowProcessor
 *	  Add the received row to the current async result (conn-&amp;gt;result).
 *	  Returns 1 if OK, 0 if error occurred.
 *
 * On error, *errmsgp can be set to an error string to be returned.
 * If it is left NULL, the error is presumed to be &quot;out of memory&quot;.
 *
 * In single-row mode, we create a new result holding just the current row,
 * stashing the previous result in conn-&amp;gt;next_result so that it becomes
 * active again after pqPrepareAsyncResult().  This allows the result metadata
 * (column descriptions) to be carried forward to each result row.
 */
int
pqRowProcessor(PGconn *conn, const char **errmsgp)
{
	PGresult   *res = conn-&amp;gt;result;
	int			nfields = res-&amp;gt;numAttributes;
	const PGdataValue *columns = conn-&amp;gt;rowBuf;
	PGresAttValue *tup;
	int			i;

	/*
	 * In single-row mode, make a new PGresult that will hold just this one
	 * row; the original conn-&amp;gt;result is left unchanged so that it can be used
	 * again as the template for future rows.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Copy everything that should be in the result at this point */
		res = PQcopyResult(res,
						   PG_COPYRES_ATTRS | PG_COPYRES_EVENTS |
						   PG_COPYRES_NOTICEHOOKS);
		if (!res)
			return 0;
	}

	/*
	 * Basically we just allocate space in the PGresult for each field and
	 * copy the data over.
	 *
	 * Note: on malloc failure, we return 0 leaving *errmsgp still NULL, which
	 * caller will take to mean &quot;out of memory&quot;.  This is preferable to trying
	 * to set up such a message here, because evidently there's not enough
	 * memory for gettext() to do anything.
	 */
	tup = (PGresAttValue *)
		pqResultAlloc(res, nfields * sizeof(PGresAttValue), TRUE);
	if (tup == NULL)
		goto fail;

	for (i = 0; i &amp;lt; nfields; i++)
	{
		int			clen = columns[i].len;

		if (clen &amp;lt; 0)
		{
			/* null field */
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}
		else
		{
			bool		isbinary = (res-&amp;gt;attDescs[i].format != 0);
			char	   *val;

			val = (char *) pqResultAlloc(res, clen + 1, isbinary);
			if (val == NULL)
				goto fail;

			/* copy and zero-terminate the data (even if it's binary) */
			memcpy(val, columns[i].value, clen);
			val[clen] = '\0';

			tup[i].len = clen;
			tup[i].value = val;
		}
	}

	/* And add the tuple to the PGresult's tuple array */
	if (!pqAddTuple(res, tup))
		goto fail;

	/*
	 * Success.  In single-row mode, make the result available to the client
	 * immediately.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Change result status to special single-row value */
		res-&amp;gt;resultStatus = PGRES_SINGLE_TUPLE;
		/* Stash old result for re-use later */
		conn-&amp;gt;next_result = conn-&amp;gt;result;
		conn-&amp;gt;result = res;
		/* And mark the result ready to return */
		conn-&amp;gt;asyncStatus = PGASYNC_READY;
	}

	return 1;

fail:
	/* release locally allocated PGresult, if we made one */
	if (res != conn-&amp;gt;result)
		PQclear(res);
	return 0;
}


/*
 * PQsendQuery
 *	 Submit a query, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendQuery(PGconn *conn, const char *query)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the argument */
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}

	/* construct the outgoing Query message */
	if (pqPutMsgStart('Q', false, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* remember we are using simple query protocol */
	conn-&amp;gt;queryclass = PGQUERY_SIMPLE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;
}

/*
 * PQsendQueryParams
 *		Like PQsendQuery, but use protocol 3.0 so we can pass parameters
 */
int
PQsendQueryParams(PGconn *conn,
				  const char *command,
				  int nParams,
				  const Oid *paramTypes,
				  const char *const * paramValues,
				  const int *paramLengths,
				  const int *paramFormats,
				  int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!command)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   command,
						   &quot;&quot;,	/* use unnamed statement */
						   nParams,
						   paramTypes,
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * PQsendPrepare
 *	 Submit a Parse message, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendPrepare(PGconn *conn,
			  const char *stmtName, const char *query,
			  int nParams, const Oid *paramTypes)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Parse message */
	if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0)
		goto sendFailed;

	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
	{
		int			i;

		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing just a Parse */
	conn-&amp;gt;queryclass = PGQUERY_PREPARE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQsendQueryPrepared
 *		Like PQsendQuery, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
int
PQsendQueryPrepared(PGconn *conn,
					const char *stmtName,
					int nParams,
					const char *const * paramValues,
					const int *paramLengths,
					const int *paramFormats,
					int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   NULL,	/* no command to parse */
						   stmtName,
						   nParams,
						   NULL,	/* no param types */
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * Common startup code for PQsendQuery and sibling routines
 */
static bool
PQsendQueryStart(PGconn *conn)
{
	if (!conn)
		return false;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Don't try to send if we know there's no live connection. */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no connection to the server\n&quot;));
		return false;
	}
	/* Can't send while already busy, either. */
	if (conn-&amp;gt;asyncStatus != PGASYNC_IDLE)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;another command is already in progress\n&quot;));
		return false;
	}

	/* initialize async result-accumulation state */
	pqClearAsyncResult(conn);

	/* reset single-row processing mode */
	conn-&amp;gt;singleRowMode = false;

	/* ready to send command message */
	return true;
}

/*
 * PQsendQueryGuts
 *		Common code for protocol-3.0 query sending
 *		PQsendQueryStart should be done already
 *
 * command may be NULL to indicate we use an already-prepared statement
 */
static int
PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat)
{
	int			i;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/*
	 * We will send Parse (if needed), Bind, Describe Portal, Execute, Sync,
	 * using specified statement name and the unnamed portal.
	 */

	if (command)
	{
		/* construct the Parse message */
		if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
			pqPuts(stmtName, conn) &amp;lt; 0 ||
			pqPuts(command, conn) &amp;lt; 0)
			goto sendFailed;
		if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
		{
			if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
				goto sendFailed;
			for (i = 0; i &amp;lt; nParams; i++)
			{
				if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
					goto sendFailed;
			}
		}
		else
		{
			if (pqPutInt(0, 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
		if (pqPutMsgEnd(conn) &amp;lt; 0)
			goto sendFailed;
	}

	/* Construct the Bind message */
	if (pqPutMsgStart('B', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameter formats */
	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramFormats)
	{
		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramFormats[i], 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}

	if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameters */
	for (i = 0; i &amp;lt; nParams; i++)
	{
		if (paramValues &amp;amp;&amp;amp; paramValues[i])
		{
			int			nbytes;

			if (paramFormats &amp;amp;&amp;amp; paramFormats[i] != 0)
			{
				/* binary parameter */
				if (paramLengths)
					nbytes = paramLengths[i];
				else
				{
					printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
									  libpq_gettext(&quot;length must be given for binary parameter\n&quot;));
					goto sendFailed;
				}
			}
			else
			{
				/* text parameter, do not use paramLengths */
				nbytes = strlen(paramValues[i]);
			}
			if (pqPutInt(nbytes, 4, conn) &amp;lt; 0 ||
				pqPutnchar(paramValues[i], nbytes, conn) &amp;lt; 0)
				goto sendFailed;
		}
		else
		{
			/* take the param as NULL */
			if (pqPutInt(-1, 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	if (pqPutInt(1, 2, conn) &amp;lt; 0 ||
		pqPutInt(resultFormat, 2, conn))
		goto sendFailed;
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Describe Portal message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc('P', conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Execute message */
	if (pqPutMsgStart('E', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutInt(0, 4, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are using extended query protocol */
	conn-&amp;gt;queryclass = PGQUERY_EXTENDED;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	if (command)
		conn-&amp;gt;last_query = strdup(command);
	else
		conn-&amp;gt;last_query = NULL;

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * pqHandleSendFailure: try to clean up after failure to send command.
 *
 * Primarily, what we want to accomplish here is to process any ERROR or
 * NOTICE messages that the backend might have sent just before it died.
 * Since we're in IDLE state, all such messages will get sent to the notice
 * processor.
 *
 * NOTE: this routine should only be called in PGASYNC_IDLE state.
 */
void
pqHandleSendFailure(PGconn *conn)
{
	/*
	 * Accept and parse any available input data, ignoring I/O errors.  Note
	 * that if pqReadData decides the backend has closed the channel, it will
	 * close our side of the socket --- that's just what we want here.
	 */
	while (pqReadData(conn) &amp;gt; 0)
		parseInput(conn);

	/*
	 * Be sure to parse available input messages even if we read no data.
	 * (Note: calling parseInput within the above loop isn't really necessary,
	 * but it prevents buffer bloat if there's a lot of data available.)
	 */
	parseInput(conn);
}

/*
 * Select row-by-row processing mode
 */
int
PQsetSingleRowMode(PGconn *conn)
{
	/*
	 * Only allow setting the flag when we have launched a query and not yet
	 * received any results.
	 */
	if (!conn)
		return 0;
	if (conn-&amp;gt;asyncStatus != PGASYNC_BUSY)
		return 0;
	if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE &amp;amp;&amp;amp;
		conn-&amp;gt;queryclass != PGQUERY_EXTENDED)
		return 0;
	if (conn-&amp;gt;result)
		return 0;

	/* OK, set flag */
	conn-&amp;gt;singleRowMode = true;
	return 1;
}

/*
 * Consume any available input from the backend
 * 0 return: some kind of trouble
 * 1 return: no problem
 */
int
PQconsumeInput(PGconn *conn)
{
	if (!conn)
		return 0;

	/*
	 * for non-blocking connections try to flush the send-queue, otherwise we
	 * may never get a response for something that may not have already been
	 * sent because it's in our write buffer!
	 */
	if (pqIsnonblocking(conn))
	{
		if (pqFlush(conn) &amp;lt; 0)
			return 0;
	}

	/*
	 * Load more data, if available. We do this no matter what state we are
	 * in, since we are probably getting called because the application wants
	 * to get rid of a read-select condition. Note that we will NOT block
	 * waiting for more input.
	 */
	if (pqReadData(conn) &amp;lt; 0)
		return 0;

	/* Parsing of the data waits till later. */
	return 1;
}


/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */
static void
parseInput(PGconn *conn)
{
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		pqParseInput3(conn);
	else
		pqParseInput2(conn);
}

/*
 * PQisBusy
 *	 Return TRUE if PQgetResult would block waiting for input.
 */

int
PQisBusy(PGconn *conn)
{
	if (!conn)
		return FALSE;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* PQgetResult will return immediately in all states except BUSY. */
	return conn-&amp;gt;asyncStatus == PGASYNC_BUSY;
}


/*
 * PQgetResult
 *	  Get the next PGresult produced by a query.  Returns NULL if no
 *	  query work remains or an error has occurred (e.g. out of
 *	  memory).
 */

PGresult *
PQgetResult(PGconn *conn)
{
	PGresult   *res;

	if (!conn)
		return NULL;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* If not ready to return something, block until we are. */
	while (conn-&amp;gt;asyncStatus == PGASYNC_BUSY)
	{
		int			flushResult;

		/*
		 * If data remains unsent, send it.  Else we might be waiting for the
		 * result of a command the backend hasn't even got yet.
		 */
		while ((flushResult = pqFlush(conn)) &amp;gt; 0)
		{
			if (pqWait(FALSE, TRUE, conn))
			{
				flushResult = -1;
				break;
			}
		}

		/* Wait for some more data, and load it. */
		if (flushResult ||
			pqWait(TRUE, FALSE, conn) ||
			pqReadData(conn) &amp;lt; 0)
		{
			/*
			 * conn-&amp;gt;errorMessage has been set by pqWait or pqReadData. We
			 * want to append it to any already-received error message.
			 */
			pqSaveErrorResult(conn);
			conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
			return pqPrepareAsyncResult(conn);
		}

		/* Parse it. */
		parseInput(conn);
	}

	/* Return the appropriate thing. */
	switch (conn-&amp;gt;asyncStatus)
	{
		case PGASYNC_IDLE:
			res = NULL;			/* query is complete */
			break;
		case PGASYNC_READY:
			res = pqPrepareAsyncResult(conn);
			/* Set the state back to BUSY, allowing parsing to proceed. */
			conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
			break;
		case PGASYNC_COPY_IN:
			res = getCopyResult(conn, PGRES_COPY_IN);
			break;
		case PGASYNC_COPY_OUT:
			res = getCopyResult(conn, PGRES_COPY_OUT);
			break;
		case PGASYNC_COPY_BOTH:
			res = getCopyResult(conn, PGRES_COPY_BOTH);
			break;
		default:
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;unexpected asyncStatus: %d\n&quot;),
							  (int) conn-&amp;gt;asyncStatus);
			res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
			break;
	}

	if (res)
	{
		int			i;

		for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
		{
			PGEventResultCreate evt;

			evt.conn = conn;
			evt.result = res;
			if (!res-&amp;gt;events[i].proc(PGEVT_RESULTCREATE, &amp;amp;evt,
									 res-&amp;gt;events[i].passThrough))
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
								  libpq_gettext(&quot;PGEventProc \&quot;%s\&quot; failed during PGEVT_RESULTCREATE event\n&quot;),
								  res-&amp;gt;events[i].name);
				pqSetResultError(res, conn-&amp;gt;errorMessage.data);
				res-&amp;gt;resultStatus = PGRES_FATAL_ERROR;
				break;
			}
			res-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return res;
}

/*
 * getCopyResult
 *	  Helper for PQgetResult: generate result for COPY-in-progress cases
 */
static PGresult *
getCopyResult(PGconn *conn, ExecStatusType copytype)
{
	/*
	 * If the server connection has been lost, don't pretend everything is
	 * hunky-dory; instead return a PGRES_FATAL_ERROR result, and reset the
	 * asyncStatus to idle (corresponding to what we'd do if we'd detected I/O
	 * error in the earlier steps in PQgetResult).  The text returned in the
	 * result is whatever is in conn-&amp;gt;errorMessage; we hope that was filled
	 * with something relevant when the lost connection was detected.
	 */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		pqSaveErrorResult(conn);
		conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
		return pqPrepareAsyncResult(conn);
	}

	/* If we have an async result for the COPY, return that */
	if (conn-&amp;gt;result &amp;amp;&amp;amp; conn-&amp;gt;result-&amp;gt;resultStatus == copytype)
		return pqPrepareAsyncResult(conn);

	/* Otherwise, invent a suitable PGresult */
	return PQmakeEmptyPGresult(conn, copytype);
}


/*
 * PQexec
 *	  send a query to the backend and package up the result in a PGresult
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQexec(PGconn *conn, const char *query)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQuery(conn, query))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecParams
 *		Like PQexec, but use protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecParams(PGconn *conn,
			 const char *command,
			 int nParams,
			 const Oid *paramTypes,
			 const char *const * paramValues,
			 const int *paramLengths,
			 const int *paramFormats,
			 int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryParams(conn, command,
						   nParams, paramTypes, paramValues, paramLengths,
						   paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQprepare
 *	  Creates a prepared statement by issuing a v3.0 parse message.
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQprepare(PGconn *conn,
		  const char *stmtName, const char *query,
		  int nParams, const Oid *paramTypes)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendPrepare(conn, stmtName, query, nParams, paramTypes))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecPrepared
 *		Like PQexec, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecPrepared(PGconn *conn,
			   const char *stmtName,
			   int nParams,
			   const char *const * paramValues,
			   const int *paramLengths,
			   const int *paramFormats,
			   int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryPrepared(conn, stmtName,
							 nParams, paramValues, paramLengths,
							 paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * Common code for PQexec and sibling routines: prepare to send command
 */
static bool
PQexecStart(PGconn *conn)
{
	PGresult   *result;

	if (!conn)
		return false;

	/*
	 * Silently discard any prior query result that application didn't eat.
	 * This is probably poor design, but it's here for backward compatibility.
	 */
	while ((result = PQgetResult(conn)) != NULL)
	{
		ExecStatusType resultStatus = result-&amp;gt;resultStatus;

		PQclear(result);		/* only need its status */
		if (resultStatus == PGRES_COPY_IN)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/* In protocol 3, we can get out of a COPY IN state */
				if (PQputCopyEnd(conn,
						 libpq_gettext(&quot;COPY terminated by new PQexec&quot;)) &amp;lt; 0)
					return false;
				/* keep waiting to swallow the copy's failure message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;COPY IN state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_OUT)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/*
				 * In protocol 3, we can get out of a COPY OUT state: we just
				 * switch back to BUSY and allow the remaining COPY data to be
				 * dropped on the floor.
				 */
				conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
				/* keep waiting to swallow the copy's completion message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				 libpq_gettext(&quot;COPY OUT state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_BOTH)
		{
			/* We don't allow PQexec during COPY BOTH */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
					 libpq_gettext(&quot;PQexec not allowed during COPY BOTH\n&quot;));
			return false;
		}
		/* check for loss of connection, too */
		if (conn-&amp;gt;status == CONNECTION_BAD)
			return false;
	}

	/* OK to send a command */
	return true;
}

/*
 * Common code for PQexec and sibling routines: wait for command result
 */
static PGresult *
PQexecFinish(PGconn *conn)
{
	PGresult   *result;
	PGresult   *lastResult;

	/*
	 * For backwards compatibility, return the last result if there are more
	 * than one --- but merge error messages if we get more than one error
	 * result.
	 *
	 * We have to stop if we see copy in/out/both, however. We will resume
	 * parsing after application performs the data transfer.
	 *
	 * Also stop if the connection is lost (else we'll loop infinitely).
	 */
	lastResult = NULL;
	while ((result = PQgetResult(conn)) != NULL)
	{
		if (lastResult)
		{
			if (lastResult-&amp;gt;resultStatus == PGRES_FATAL_ERROR &amp;amp;&amp;amp;
				result-&amp;gt;resultStatus == PGRES_FATAL_ERROR)
			{
				pqCatenateResultError(lastResult, result-&amp;gt;errMsg);
				PQclear(result);
				result = lastResult;

				/*
				 * Make sure PQerrorMessage agrees with concatenated result
				 */
				resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
				appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage, result-&amp;gt;errMsg);
			}
			else
				PQclear(lastResult);
		}
		lastResult = result;
		if (result-&amp;gt;resultStatus == PGRES_COPY_IN ||
			result-&amp;gt;resultStatus == PGRES_COPY_OUT ||
			result-&amp;gt;resultStatus == PGRES_COPY_BOTH ||
			conn-&amp;gt;status == CONNECTION_BAD)
			break;
	}

	return lastResult;
}

/*
 * PQdescribePrepared
 *	  Obtain information about a previously prepared statement
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).  On success, the PGresult contains status
 * PGRES_COMMAND_OK, and its parameter and column-heading fields describe
 * the statement's inputs and outputs respectively.
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQdescribePrepared(PGconn *conn, const char *stmt)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'S', stmt))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQdescribePortal
 *	  Obtain information about a previously created portal
 *
 * This is much like PQdescribePrepared, except that no parameter info is
 * returned.  Note that at the moment, libpq doesn't really expose portals
 * to the client; but this can be used with a portal created by a SQL
 * DECLARE CURSOR command.
 */
PGresult *
PQdescribePortal(PGconn *conn, const char *portal)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'P', portal))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQsendDescribePrepared
 *	 Submit a Describe Statement command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePrepared(PGconn *conn, const char *stmt)
{
	return PQsendDescribe(conn, 'S', stmt);
}

/*
 * PQsendDescribePortal
 *	 Submit a Describe Portal command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePortal(PGconn *conn, const char *portal)
{
	return PQsendDescribe(conn, 'P', portal);
}

/*
 * PQsendDescribe
 *	 Common code to send a Describe command
 *
 * Available options for desc_type are
 *	 'S' to describe a prepared statement; or
 *	 'P' to describe a portal.
 * Returns 1 on success and 0 on failure.
 */
static int
PQsendDescribe(PGconn *conn, char desc_type, const char *desc_target)
{
	/* Treat null desc_target as empty string */
	if (!desc_target)
		desc_target = &quot;&quot;;

	if (!PQsendQueryStart(conn))
		return 0;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Describe message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc(desc_type, conn) &amp;lt; 0 ||
		pqPuts(desc_target, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing a Describe */
	conn-&amp;gt;queryclass = PGQUERY_DESCRIBE;

	/* reset last-query string (not relevant now) */
	if (conn-&amp;gt;last_query)
	{
		free(conn-&amp;gt;last_query);
		conn-&amp;gt;last_query = NULL;
	}

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQnotifies
 *	  returns a PGnotify* structure of the latest async notification
 * that has not yet been handled
 *
 * returns NULL, if there is currently
 * no unhandled async notification from the backend
 *
 * the CALLER is responsible for FREE'ing the structure returned
 */
PGnotify *
PQnotifies(PGconn *conn)
{
	PGnotify   *event;

	if (!conn)
		return NULL;

	/* Parse any available data to see if we can extract NOTIFY messages. */
	parseInput(conn);

	event = conn-&amp;gt;notifyHead;
	if (event)
	{
		conn-&amp;gt;notifyHead = event-&amp;gt;next;
		if (!conn-&amp;gt;notifyHead)
			conn-&amp;gt;notifyTail = NULL;
		event-&amp;gt;next = NULL;		/* don't let app see the internal state */
	}
	return event;
}

/*
 * PQputCopyData - send some data to the backend during COPY IN or COPY BOTH
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyData(PGconn *conn, const char *buffer, int nbytes)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Process any NOTICE or NOTIFY messages that might be pending in the
	 * input buffer.  Since the server might generate many notices during the
	 * COPY, we want to clean those out reasonably promptly to prevent
	 * indefinite expansion of the input buffer.  (Note: the actual read of
	 * input data into the input buffer happens down inside pqSendSome, but
	 * it's not authorized to get rid of the data again.)
	 */
	parseInput(conn);

	if (nbytes &amp;gt; 0)
	{
		/*
		 * Try to flush any previously sent data in preference to growing the
		 * output buffer.  If we can't enlarge the buffer enough to hold the
		 * data, return 0 in the nonblock case, else hard error. (For
		 * simplicity, always assume 5 bytes of overhead even in protocol 2.0
		 * case.)
		 */
		if ((conn-&amp;gt;outBufSize - conn-&amp;gt;outCount - 5) &amp;lt; nbytes)
		{
			if (pqFlush(conn) &amp;lt; 0)
				return -1;
			if (pqCheckOutBufferSpace(conn-&amp;gt;outCount + 5 + (size_t) nbytes,
									  conn))
				return pqIsnonblocking(conn) ? 0 : -1;
		}
		/* Send the data (too simple to delegate to fe-protocol files) */
		if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		{
			if (pqPutMsgStart('d', false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	return 1;
}

/*
 * PQputCopyEnd - send EOF indication to the backend during COPY IN
 *
 * After calling this, use PQgetResult() to check command completion status.
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyEnd(PGconn *conn, const char *errormsg)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Send the COPY END indicator.  This is simple enough that we don't
	 * bother delegating it to the fe-protocol files.
	 */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
	{
		if (errormsg)
		{
			/* Send COPY FAIL */
			if (pqPutMsgStart('f', false, conn) &amp;lt; 0 ||
				pqPuts(errormsg, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			/* Send COPY DONE */
			if (pqPutMsgStart('c', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}

		/*
		 * If we sent the COPY command in extended-query mode, we must issue a
		 * Sync as well.
		 */
		if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE)
		{
			if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	else
	{
		if (errormsg)
		{
			/* Oops, no way to do this in 2.0 */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
			return -1;
		}
		else
		{
			/* Send old-style end-of-data marker */
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(&quot;\\.\n&quot;, 3, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}

	/* Return to active duty */
	if (conn-&amp;gt;asyncStatus == PGASYNC_COPY_BOTH)
		conn-&amp;gt;asyncStatus = PGASYNC_COPY_OUT;
	else
		conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Try to flush data */
	if (pqFlush(conn) &amp;lt; 0)
		return -1;

	return 1;
}

/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 * or COPY BOTH
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &amp;gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */
int
PQgetCopyData(PGconn *conn, char **buffer, int async)
{
	*buffer = NULL;				/* for all failure cases */
	if (!conn)
		return -2;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_OUT &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -2;
	}
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetCopyData3(conn, buffer, async);
	else
		return pqGetCopyData2(conn, buffer, async);
}

/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * Chiefly here so that applications can use &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * and read the output string.  Returns a null-terminated string in s.
 *
 * XXX this routine is now deprecated, because it can't handle binary data.
 * If called during a COPY BINARY we return EOF.
 *
 * PQgetline reads up to maxlen-1 characters (like fgets(3)) but strips
 * the terminating \n (like gets(3)).
 *
 * CAUTION: the caller is responsible for detecting the end-of-copy signal
 * (a line containing just &quot;\.&quot;) when using this routine.
 *
 * RETURNS:
 *		EOF if error (eg, invalid arguments are given)
 *		0 if EOL is reached (i.e., \n has been read)
 *				(this is required for backward-compatibility -- this
 *				 routine used to always return EOF or 0, assuming that
 *				 the line ended within maxlen bytes.)
 *		1 in other cases (i.e., the buffer was filled before \n is reached)
 */
int
PQgetline(PGconn *conn, char *s, int maxlen)
{
	if (!s || maxlen &amp;lt;= 0)
		return EOF;
	*s = '\0';
	/* maxlen must be at least 3 to hold the \. terminator! */
	if (maxlen &amp;lt; 3)
		return EOF;

	if (!conn)
		return EOF;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetline3(conn, s, maxlen);
	else
		return pqGetline2(conn, s, maxlen);
}

/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * This routine is for applications that want to do &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * asynchronously, that is without blocking.  Having issued the COPY command
 * and gotten a PGRES_COPY_OUT response, the app should call PQconsumeInput
 * and this routine until the end-of-data signal is detected.  Unlike
 * PQgetline, this routine takes responsibility for detecting end-of-data.
 *
 * On each call, PQgetlineAsync will return data if a complete data row
 * is available in libpq's input buffer.  Otherwise, no data is returned
 * until the rest of the row arrives.
 *
 * If -1 is returned, the end-of-data signal has been recognized (and removed
 * from libpq's input buffer).  The caller *must* next call PQendcopy and
 * then return to normal processing.
 *
 * RETURNS:
 *	 -1    if the end-of-copy-data marker has been recognized
 *	 0	   if no data is available
 *	 &amp;gt;0    the number of bytes returned.
 *
 * The data returned will not extend beyond a data-row boundary.  If possible
 * a whole row will be returned at one time.  But if the buffer offered by
 * the caller is too small to hold a row sent by the backend, then a partial
 * data row will be returned.  In text mode this can be detected by testing
 * whether the last returned byte is '\n' or not.
 *
 * The returned data is *not* null-terminated.
 */

int
PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)
{
	if (!conn)
		return -1;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetlineAsync3(conn, buffer, bufsize);
	else
		return pqGetlineAsync2(conn, buffer, bufsize);
}

/*
 * PQputline -- sends a string to the backend during COPY IN.
 * Returns 0 if OK, EOF if not.
 *
 * This is deprecated primarily because the return convention doesn't allow
 * caller to tell the difference between a hard error and a nonblock-mode
 * send failure.
 */
int
PQputline(PGconn *conn, const char *s)
{
	return PQputnbytes(conn, s, strlen(s));
}

/*
 * PQputnbytes -- like PQputline, but buffer need not be null-terminated.
 * Returns 0 if OK, EOF if not.
 */
int
PQputnbytes(PGconn *conn, const char *buffer, int nbytes)
{
	if (PQputCopyData(conn, buffer, nbytes) &amp;gt; 0)
		return 0;
	else
		return EOF;
}

/*
 * PQendcopy
 *		After completing the data transfer portion of a copy in/out,
 *		the application must call this routine to finish the command protocol.
 *
 * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult
 * to get the transfer status.  Note however that when using 2.0 protocol,
 * recovering from a copy failure often requires a PQreset.  PQendcopy will
 * take care of that, PQgetResult won't.
 *
 * RETURNS:
 *		0 on success
 *		1 on failure
 */
int
PQendcopy(PGconn *conn)
{
	if (!conn)
		return 0;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqEndcopy3(conn);
	else
		return pqEndcopy2(conn);
}


/* ----------------
 *		PQfn -	Send a function call to the POSTGRES backend.
 *
 *		conn			: backend connection
 *		fnid			: OID of function to be called
 *		result_buf		: pointer to result buffer
 *		result_len		: actual length of result is returned here
 *		result_is_int	: If the result is an integer, this must be 1,
 *						  otherwise this should be 0
 *		args			: pointer to an array of function arguments
 *						  (each has length, if integer, and value/pointer)
 *		nargs			: # of arguments in args array.
 *
 * RETURNS
 *		PGresult with status = PGRES_COMMAND_OK if successful.
 *			*result_len is &amp;gt; 0 if there is a return value, 0 if not.
 *		PGresult with status = PGRES_FATAL_ERROR if backend returns an error.
 *		NULL on communications failure.  conn-&amp;gt;errorMessage will be set.
 * ----------------
 */

PGresult *
PQfn(PGconn *conn,
	 int fnid,
	 int *result_buf,
	 int *result_len,
	 int result_is_int,
	 const PQArgBlock *args,
	 int nargs)
{
	*result_len = 0;

	if (!conn)
		return NULL;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	if (conn-&amp;gt;sock == PGINVALID_SOCKET || conn-&amp;gt;asyncStatus != PGASYNC_IDLE ||
		conn-&amp;gt;result != NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;connection in wrong state\n&quot;));
		return NULL;
	}

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqFunctionCall3(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
	else
		return pqFunctionCall2(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
}


/* ====== accessor funcs for PGresult ======== */

ExecStatusType
PQresultStatus(const PGresult *res)
{
	if (!res)
		return PGRES_FATAL_ERROR;
	return res-&amp;gt;resultStatus;
}

char *
PQresStatus(ExecStatusType status)
{
	if ((unsigned int) status &amp;gt;= sizeof pgresStatus / sizeof pgresStatus[0])
		return libpq_gettext(&quot;invalid ExecStatusType code&quot;);
	return pgresStatus[status];
}

char *
PQresultErrorMessage(const PGresult *res)
{
	if (!res || !res-&amp;gt;errMsg)
		return &quot;&quot;;
	return res-&amp;gt;errMsg;
}

char *
PQresultVerboseErrorMessage(const PGresult *res,
							PGVerbosity verbosity,
							PGContextVisibility show_context)
{
	PQExpBufferData workBuf;

	/*
	 * Because the caller is expected to free the result string, we must
	 * strdup any constant result.  We use plain strdup and document that
	 * callers should expect NULL if out-of-memory.
	 */
	if (!res ||
		(res-&amp;gt;resultStatus != PGRES_FATAL_ERROR &amp;amp;&amp;amp;
		 res-&amp;gt;resultStatus != PGRES_NONFATAL_ERROR))
		return strdup(libpq_gettext(&quot;PGresult is not an error result\n&quot;));

	initPQExpBuffer(&amp;amp;workBuf);

	/*
	 * Currently, we pass this off to fe-protocol3.c in all cases; it will
	 * behave reasonably sanely with an error reported by fe-protocol2.c as
	 * well.  If necessary, we could record the protocol version in PGresults
	 * so as to be able to invoke a version-specific message formatter, but
	 * for now there's no need.
	 */
	pqBuildErrorMessage3(&amp;amp;workBuf, res, verbosity, show_context);

	/* If insufficient memory to format the message, fail cleanly */
	if (PQExpBufferDataBroken(workBuf))
	{
		termPQExpBuffer(&amp;amp;workBuf);
		return strdup(libpq_gettext(&quot;out of memory\n&quot;));
	}

	return workBuf.data;
}

char *
PQresultErrorField(const PGresult *res, int fieldcode)
{
	PGMessageField *pfield;

	if (!res)
		return NULL;
	for (pfield = res-&amp;gt;errFields; pfield != NULL; pfield = pfield-&amp;gt;next)
	{
		if (pfield-&amp;gt;code == fieldcode)
			return pfield-&amp;gt;contents;
	}
	return NULL;
}

int
PQntuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;ntups;
}

int
PQnfields(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numAttributes;
}

int
PQbinaryTuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;binary;
}

/*
 * Helper routines to range-check field numbers and tuple numbers.
 * Return TRUE if OK, FALSE if not
 */

static int
check_field_number(const PGresult *res, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_tuple_field_number(const PGresult *res,
						 int tup_num, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt;= res-&amp;gt;ntups)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;row number %d is out of range 0..%d&quot;,
						 tup_num, res-&amp;gt;ntups - 1);
		return FALSE;
	}
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_param_number(const PGresult *res, int param_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (param_num &amp;lt; 0 || param_num &amp;gt;= res-&amp;gt;numParameters)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;parameter number %d is out of range 0..%d&quot;,
						 param_num, res-&amp;gt;numParameters - 1);
		return FALSE;
	}

	return TRUE;
}

/*
 * returns NULL if the field_num is invalid
 */
char *
PQfname(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return NULL;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].name;
	else
		return NULL;
}

/*
 * PQfnumber: find column number given column name
 *
 * The column name is parsed as if it were in a SQL statement, including
 * case-folding and double-quote processing.  But note a possible gotcha:
 * downcasing in the frontend might follow different locale rules than
 * downcasing in the backend...
 *
 * Returns -1 if no match.  In the present backend it is also possible
 * to have multiple matches, in which case the first one is found.
 */
int
PQfnumber(const PGresult *res, const char *field_name)
{
	char	   *field_case;
	bool		in_quotes;
	bool		all_lower = true;
	const char *iptr;
	char	   *optr;
	int			i;

	if (!res)
		return -1;

	/*
	 * Note: it is correct to reject a zero-length input string; the proper
	 * input to match a zero-length field name would be &quot;&quot;.
	 */
	if (field_name == NULL ||
		field_name[0] == '\0' ||
		res-&amp;gt;attDescs == NULL)
		return -1;

	/*
	 * Check if we can avoid the strdup() and related work because the
	 * passed-in string wouldn't be changed before we do the check anyway.
	 */
	for (iptr = field_name; *iptr; iptr++)
	{
		char		c = *iptr;

		if (c == '&quot;' || c != pg_tolower((unsigned char) c))
		{
			all_lower = false;
			break;
		}
	}

	if (all_lower)
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
			if (strcmp(field_name, res-&amp;gt;attDescs[i].name) == 0)
				return i;

	/* Fall through to the normal check if that didn't work out. */

	/*
	 * Note: this code will not reject partially quoted strings, eg
	 * foo&quot;BAR&quot;foo will become fooBARfoo when it probably ought to be an error
	 * condition.
	 */
	field_case = strdup(field_name);
	if (field_case == NULL)
		return -1;				/* grotty */

	in_quotes = false;
	optr = field_case;
	for (iptr = field_case; *iptr; iptr++)
	{
		char		c = *iptr;

		if (in_quotes)
		{
			if (c == '&quot;')
			{
				if (iptr[1] == '&quot;')
				{
					/* doubled quotes become a single quote */
					*optr++ = '&quot;';
					iptr++;
				}
				else
					in_quotes = false;
			}
			else
				*optr++ = c;
		}
		else if (c == '&quot;')
			in_quotes = true;
		else
		{
			c = pg_tolower((unsigned char) c);
			*optr++ = c;
		}
	}
	*optr = '\0';

	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (strcmp(field_case, res-&amp;gt;attDescs[i].name) == 0)
		{
			free(field_case);
			return i;
		}
	}
	free(field_case);
	return -1;
}

Oid
PQftable(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].tableid;
	else
		return InvalidOid;
}

int
PQftablecol(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].columnid;
	else
		return 0;
}

int
PQfformat(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].format;
	else
		return 0;
}

Oid
PQftype(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typid;
	else
		return InvalidOid;
}

int
PQfsize(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typlen;
	else
		return 0;
}

int
PQfmod(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].atttypmod;
	else
		return 0;
}

char *
PQcmdStatus(PGresult *res)
{
	if (!res)
		return NULL;
	return res-&amp;gt;cmdStatus;
}

/*
 * PQoidStatus -
 *	if the last command was an INSERT, return the oid string
 *	if not, return &quot;&quot;
 */
char *
PQoidStatus(const PGresult *res)
{
	/*
	 * This must be enough to hold the result. Don't laugh, this is better
	 * than what this function used to do.
	 */
	static char buf[24];

	size_t		len;

	if (!res || strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0)
		return &quot;&quot;;

	len = strspn(res-&amp;gt;cmdStatus + 7, &quot;0123456789&quot;);
	if (len &amp;gt; sizeof(buf) - 1)
		len = sizeof(buf) - 1;
	memcpy(buf, res-&amp;gt;cmdStatus + 7, len);
	buf[len] = '\0';

	return buf;
}

/*
 * PQoidValue -
 *	a perhaps preferable form of the above which just returns
 *	an Oid type
 */
Oid
PQoidValue(const PGresult *res)
{
	char	   *endptr = NULL;
	unsigned long result;

	if (!res ||
		strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0 ||
		res-&amp;gt;cmdStatus[7] &amp;lt; '0' ||
		res-&amp;gt;cmdStatus[7] &amp;gt; '9')
		return InvalidOid;

	result = strtoul(res-&amp;gt;cmdStatus + 7, &amp;amp;endptr, 10);

	if (!endptr || (*endptr != ' ' &amp;amp;&amp;amp; *endptr != '\0'))
		return InvalidOid;
	else
		return (Oid) result;
}


/*
 * PQcmdTuples -
 *	If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
 *	a string containing the number of inserted/affected tuples. If not,
 *	return &quot;&quot;.
 *
 *	XXX: this should probably return an int
 */
char *
PQcmdTuples(PGresult *res)
{
	char	   *p,
			   *c;

	if (!res)
		return &quot;&quot;;

	if (strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) == 0)
	{
		p = res-&amp;gt;cmdStatus + 7;
		/* INSERT: skip oid and space */
		while (*p &amp;amp;&amp;amp; *p != ' ')
			p++;
		if (*p == 0)
			goto interpret_error;		/* no space? */
		p++;
	}
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;SELECT &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;DELETE &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;UPDATE &quot;, 7) == 0)
		p = res-&amp;gt;cmdStatus + 7;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;FETCH &quot;, 6) == 0)
		p = res-&amp;gt;cmdStatus + 6;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;MOVE &quot;, 5) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;COPY &quot;, 5) == 0)
		p = res-&amp;gt;cmdStatus + 5;
	else
		return &quot;&quot;;

	/* check that we have an integer (at least one digit, nothing else) */
	for (c = p; *c; c++)
	{
		if (!isdigit((unsigned char) *c))
			goto interpret_error;
	}
	if (c == p)
		goto interpret_error;

	return p;

interpret_error:
	pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
					 &quot;could not interpret result from server: %s&quot;,
					 res-&amp;gt;cmdStatus);
	return &quot;&quot;;
}

/*
 * PQgetvalue:
 *	return the value of field 'field_num' of row 'tup_num'
 */
char *
PQgetvalue(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return NULL;
	return res-&amp;gt;tuples[tup_num][field_num].value;
}

/* PQgetlength:
 *	returns the actual length of a field value in bytes.
 */
int
PQgetlength(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 0;
	if (res-&amp;gt;tuples[tup_num][field_num].len != NULL_LEN)
		return res-&amp;gt;tuples[tup_num][field_num].len;
	else
		return 0;
}

/* PQgetisnull:
 *	returns the null status of a field value.
 */
int
PQgetisnull(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 1;				/* pretend it is null */
	if (res-&amp;gt;tuples[tup_num][field_num].len == NULL_LEN)
		return 1;
	else
		return 0;
}

/* PQnparams:
 *	returns the number of input parameters of a prepared statement.
 */
int
PQnparams(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numParameters;
}

/* PQparamtype:
 *	returns type Oid of the specified statement parameter.
 */
Oid
PQparamtype(const PGresult *res, int param_num)
{
	if (!check_param_number(res, param_num))
		return InvalidOid;
	if (res-&amp;gt;paramDescs)
		return res-&amp;gt;paramDescs[param_num].typid;
	else
		return InvalidOid;
}


/* PQsetnonblocking:
 *	sets the PGconn's database connection non-blocking if the arg is TRUE
 *	or makes it blocking if the arg is FALSE, this will not protect
 *	you from PQexec(), you'll only be safe when using the non-blocking API.
 *	Needs to be called only on a connected database connection.
 */
int
PQsetnonblocking(PGconn *conn, int arg)
{
	bool		barg;

	if (!conn || conn-&amp;gt;status == CONNECTION_BAD)
		return -1;

	barg = (arg ? TRUE : FALSE);

	/* early out if the socket is already in the state requested */
	if (barg == conn-&amp;gt;nonblocking)
		return 0;

	/*
	 * to guarantee constancy for flushing/query/result-polling behavior we
	 * need to flush the send queue at this point in order to guarantee proper
	 * behavior. this is ok because either they are making a transition _from_
	 * or _to_ blocking mode, either way we can block them.
	 */
	/* if we are going from blocking to non-blocking flush here */
	if (pqFlush(conn))
		return -1;

	conn-&amp;gt;nonblocking = barg;

	return 0;
}

/*
 * return the blocking status of the database connection
 *		TRUE == nonblocking, FALSE == blocking
 */
int
PQisnonblocking(const PGconn *conn)
{
	return pqIsnonblocking(conn);
}

/* libpq is thread-safe? */
int
PQisthreadsafe(void)
{
#ifdef ENABLE_THREAD_SAFETY
	return true;
#else
	return false;
#endif
}


/* try to force data out, really only useful for non-blocking users */
int
PQflush(PGconn *conn)
{
	return pqFlush(conn);
}


/*
 *		PQfreemem - safely frees memory allocated
 *
 * Needed mostly by Win32, unless multithreaded DLL (/MD in VC6)
 * Used for freeing memory from PQescapeByte()a/PQunescapeBytea()
 */
void
PQfreemem(void *ptr)
{
	free(ptr);
}

/*
 * PQfreeNotify - free's the memory associated with a PGnotify
 *
 * This function is here only for binary backward compatibility.
 * New code should use PQfreemem().  A macro will automatically map
 * calls to PQfreemem.  It should be removed in the future.  bjm 2003-03-24
 */

#undef PQfreeNotify
void		PQfreeNotify(PGnotify *notify);

void
PQfreeNotify(PGnotify *notify)
{
	PQfreemem(notify);
}


/*
 * Escaping arbitrary strings to get valid SQL literal strings.
 *
 * Replaces &quot;'&quot; with &quot;''&quot;, and if not std_strings, replaces &quot;\&quot; with &quot;\\&quot;.
 *
 * length is the length of the source string.  (Note: if a terminating NUL
 * is encountered sooner, PQescapeString stops short of &quot;length&quot;; the behavior
 * is thus rather like strncpy.)
 *
 * For safety the buffer at &quot;to&quot; must be at least 2*length + 1 bytes long.
 * A terminating NUL character is added to the output string, whether the
 * input is NUL-terminated or not.
 *
 * Returns the actual length of the output (not counting the terminating NUL).
 */
static size_t
PQescapeStringInternal(PGconn *conn,
					   char *to, const char *from, size_t length,
					   int *error,
					   int encoding, bool std_strings)
{
	const char *source = from;
	char	   *target = to;
	size_t		remaining = length;

	if (error)
		*error = 0;

	while (remaining &amp;gt; 0 &amp;amp;&amp;amp; *source != '\0')
	{
		char		c = *source;
		int			len;
		int			i;

		/* Fast path for plain ASCII */
		if (!IS_HIGHBIT_SET(c))
		{
			/* Apply quoting if needed */
			if (SQL_STR_DOUBLE(c, !std_strings))
				*target++ = c;
			/* Copy the character */
			*target++ = c;
			source++;
			remaining--;
			continue;
		}

		/* Slow path for possible multibyte characters */
		len = pg_encoding_mblen(encoding, source);

		/* Copy the character */
		for (i = 0; i &amp;lt; len; i++)
		{
			if (remaining == 0 || *source == '\0')
				break;
			*target++ = *source++;
			remaining--;
		}

		/*
		 * If we hit premature end of string (ie, incomplete multibyte
		 * character), try to pad out to the correct length with spaces. We
		 * may not be able to pad completely, but we will always be able to
		 * insert at least one pad space (since we'd not have quoted a
		 * multibyte character).  This should be enough to make a string that
		 * the server will error out on.
		 */
		if (i &amp;lt; len)
		{
			if (error)
				*error = 1;
			if (conn)
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
			for (; i &amp;lt; len; i++)
			{
				if (((size_t) (target - to)) / 2 &amp;gt;= length)
					break;
				*target++ = ' ';
			}
			break;
		}
	}

	/* Write the terminating NUL character. */
	*target = '\0';

	return target - to;
}

size_t
PQescapeStringConn(PGconn *conn,
				   char *to, const char *from, size_t length,
				   int *error)
{
	if (!conn)
	{
		/* force empty-string result */
		*to = '\0';
		if (error)
			*error = 1;
		return 0;
	}
	return PQescapeStringInternal(conn, to, from, length, error,
								  conn-&amp;gt;client_encoding,
								  conn-&amp;gt;std_strings);
}

size_t
PQescapeString(char *to, const char *from, size_t length)
{
	return PQescapeStringInternal(NULL, to, from, length, NULL,
								  static_client_encoding,
								  static_std_strings);
}


/*
 * Escape arbitrary strings.  If as_ident is true, we escape the result
 * as an identifier; if false, as a literal.  The result is returned in
 * a newly allocated buffer.  If we fail due to an encoding violation or out
 * of memory condition, we return NULL, storing an error message into conn.
 */
static char *
PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
{
	const char *s;
	char	   *result;
	char	   *rp;
	int			num_quotes = 0; /* single or double, depending on as_ident */
	int			num_backslashes = 0;
	int			input_len;
	int			result_size;
	char		quote_char = as_ident ? '&quot;' : '\'';

	/* We must have a connection, else fail immediately. */
	if (!conn)
		return NULL;

	/* Scan the string for characters that must be escaped. */
	for (s = str; (s - str) &amp;lt; len &amp;amp;&amp;amp; *s != '\0'; ++s)
	{
		if (*s == quote_char)
			++num_quotes;
		else if (*s == '\\')
			++num_backslashes;
		else if (IS_HIGHBIT_SET(*s))
		{
			int			charlen;

			/* Slow path for possible multibyte characters */
			charlen = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

			/* Multibyte character overruns allowable length. */
			if ((s - str) + charlen &amp;gt; len || memchr(s, 0, charlen) != NULL)
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
				return NULL;
			}

			/* Adjust s, bearing in mind that for loop will increment it. */
			s += charlen - 1;
		}
	}

	/* Allocate output buffer. */
	input_len = s - str;
	result_size = input_len + num_quotes + 3;	/* two quotes, plus a NUL */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
		result_size += num_backslashes + 2;
	result = rp = (char *) malloc(result_size);
	if (rp == NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	/*
	 * If we are escaping a literal that contains backslashes, we use the
	 * escape string syntax so that the result is correct under either value
	 * of standard_conforming_strings.  We also emit a leading space in this
	 * case, to guard against the possibility that the result might be
	 * interpolated immediately following an identifier.
	 */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
	{
		*rp++ = ' ';
		*rp++ = 'E';
	}

	/* Opening quote. */
	*rp++ = quote_char;

	/*
	 * Use fast path if possible.
	 *
	 * We've already verified that the input string is well-formed in the
	 * current encoding.  If it contains no quotes and, in the case of
	 * literal-escaping, no backslashes, then we can just copy it directly to
	 * the output buffer, adding the necessary quotes.
	 *
	 * If not, we must rescan the input and process each character
	 * individually.
	 */
	if (num_quotes == 0 &amp;amp;&amp;amp; (num_backslashes == 0 || as_ident))
	{
		memcpy(rp, str, input_len);
		rp += input_len;
	}
	else
	{
		for (s = str; s - str &amp;lt; input_len; ++s)
		{
			if (*s == quote_char || (!as_ident &amp;amp;&amp;amp; *s == '\\'))
			{
				*rp++ = *s;
				*rp++ = *s;
			}
			else if (!IS_HIGHBIT_SET(*s))
				*rp++ = *s;
			else
			{
				int			i = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

				while (1)
				{
					*rp++ = *s;
					if (--i == 0)
						break;
					++s;		/* for loop will provide the final increment */
				}
			}
		}
	}

	/* Closing quote and terminating NUL. */
	*rp++ = quote_char;
	*rp = '\0';

	return result;
}

char *
PQescapeLiteral(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, false);
}

char *
PQescapeIdentifier(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, true);
}

/* HEX encoding support for bytea */
static const char hextbl[] = &quot;0123456789abcdef&quot;;

static const int8 hexlookup[128] = {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static inline char
get_hex(char c)
{
	int			res = -1;

	if (c &amp;gt; 0 &amp;amp;&amp;amp; c &amp;lt; 127)
		res = hexlookup[(unsigned char) c];

	return (char) res;
}


/*
 *		PQescapeBytea	- converts from binary string to the
 *		minimal encoding necessary to include the string in an SQL
 *		INSERT statement with a bytea type column as the target.
 *
 *		We can use either hex or escape (traditional) encoding.
 *		In escape mode, the following transformations are applied:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == ''
 *		'\\' == ASCII 92 == \\
 *		anything &amp;lt; 0x20, or &amp;gt; 0x7e ---&amp;gt; \ooo
 *										(where ooo is an octal expression)
 *
 *		If not std_strings, all backslashes sent to the output are doubled.
 */
static unsigned char *
PQescapeByteaInternal(PGconn *conn,
					  const unsigned char *from, size_t from_length,
					  size_t *to_length, bool std_strings, bool use_hex)
{
	const unsigned char *vp;
	unsigned char *rp;
	unsigned char *result;
	size_t		i;
	size_t		len;
	size_t		bslash_len = (std_strings ? 1 : 2);

	/*
	 * empty string has 1 char ('\0')
	 */
	len = 1;

	if (use_hex)
	{
		len += bslash_len + 1 + 2 * from_length;
	}
	else
	{
		vp = from;
		for (i = from_length; i &amp;gt; 0; i--, vp++)
		{
			if (*vp &amp;lt; 0x20 || *vp &amp;gt; 0x7e)
				len += bslash_len + 3;
			else if (*vp == '\'')
				len += 2;
			else if (*vp == '\\')
				len += bslash_len + bslash_len;
			else
				len++;
		}
	}

	*to_length = len;
	rp = result = (unsigned char *) malloc(len);
	if (rp == NULL)
	{
		if (conn)
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	if (use_hex)
	{
		if (!std_strings)
			*rp++ = '\\';
		*rp++ = '\\';
		*rp++ = 'x';
	}

	vp = from;
	for (i = from_length; i &amp;gt; 0; i--, vp++)
	{
		unsigned char c = *vp;

		if (use_hex)
		{
			*rp++ = hextbl[(c &amp;gt;&amp;gt; 4) &amp;amp; 0xF];
			*rp++ = hextbl[c &amp;amp; 0xF];
		}
		else if (c &amp;lt; 0x20 || c &amp;gt; 0x7e)
		{
			if (!std_strings)
				*rp++ = '\\';
			*rp++ = '\\';
			*rp++ = (c &amp;gt;&amp;gt; 6) + '0';
			*rp++ = ((c &amp;gt;&amp;gt; 3) &amp;amp; 07) + '0';
			*rp++ = (c &amp;amp; 07) + '0';
		}
		else if (c == '\'')
		{
			*rp++ = '\'';
			*rp++ = '\'';
		}
		else if (c == '\\')
		{
			if (!std_strings)
			{
				*rp++ = '\\';
				*rp++ = '\\';
			}
			*rp++ = '\\';
			*rp++ = '\\';
		}
		else
			*rp++ = c;
	}
	*rp = '\0';

	return result;
}

unsigned char *
PQescapeByteaConn(PGconn *conn,
				  const unsigned char *from, size_t from_length,
				  size_t *to_length)
{
	if (!conn)
		return NULL;
	return PQescapeByteaInternal(conn, from, from_length, to_length,
								 conn-&amp;gt;std_strings,
								 (conn-&amp;gt;sversion &amp;gt;= 90000));
}

unsigned char *
PQescapeBytea(const unsigned char *from, size_t from_length, size_t *to_length)
{
	return PQescapeByteaInternal(NULL, from, from_length, to_length,
								 static_std_strings,
								 false /* can't use hex */ );
}


#define ISFIRSTOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '3')
#define ISOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '7')
#define OCTVAL(CH) ((CH) - '0')

/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer (or NULL on error), and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function PQfreemem.
 *
 *		The following transformations are made:
 *		\\	 == ASCII 92 == \
 *		\ooo == a byte whose value = ooo (ooo is an octal number)
 *		\x	 == x (x is any character not matched by the above transformations)
 */
unsigned char *
PQunescapeBytea(const unsigned char *strtext, size_t *retbuflen)
{
	size_t		strtextlen,
				buflen;
	unsigned char *buffer,
			   *tmpbuf;
	size_t		i,
				j;

	if (strtext == NULL)
		return NULL;

	strtextlen = strlen((const char *) strtext);

	if (strtext[0] == '\\' &amp;amp;&amp;amp; strtext[1] == 'x')
	{
		const unsigned char *s;
		unsigned char *p;

		buflen = (strtextlen - 2) / 2;
		/* Avoid unportable malloc(0) */
		buffer = (unsigned char *) malloc(buflen &amp;gt; 0 ? buflen : 1);
		if (buffer == NULL)
			return NULL;

		s = strtext + 2;
		p = buffer;
		while (*s)
		{
			char		v1,
						v2;

			/*
			 * Bad input is silently ignored.  Note that this includes
			 * whitespace between hex pairs, which is allowed by byteain.
			 */
			v1 = get_hex(*s++);
			if (!*s || v1 == (char) -1)
				continue;
			v2 = get_hex(*s++);
			if (v2 != (char) -1)
				*p++ = (v1 &amp;lt;&amp;lt; 4) | v2;
		}

		buflen = p - buffer;
	}
	else
	{
		/*
		 * Length of input is max length of output, but add one to avoid
		 * unportable malloc(0) if input is zero-length.
		 */
		buffer = (unsigned char *) malloc(strtextlen + 1);
		if (buffer == NULL)
			return NULL;

		for (i = j = 0; i &amp;lt; strtextlen;)
		{
			switch (strtext[i])
			{
				case '\\':
					i++;
					if (strtext[i] == '\\')
						buffer[j++] = strtext[i++];
					else
					{
						if ((ISFIRSTOCTDIGIT(strtext[i])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 1])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 2])))
						{
							int			byte;

							byte = OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							buffer[j++] = byte;
						}
					}

					/*
					 * Note: if we see '\' followed by something that isn't a
					 * recognized escape sequence, we loop around having done
					 * nothing except advance i.  Therefore the something will
					 * be emitted as ordinary data on the next cycle. Corner
					 * case: '\' at end of string will just be discarded.
					 */
					break;

				default:
					buffer[j++] = strtext[i++];
					break;
			}
		}
		buflen = j;				/* buflen is the length of the dequoted data */
	}

	/* Shrink the buffer to be no larger than necessary */
	/* +1 avoids unportable behavior when buflen==0 */
	tmpbuf = realloc(buffer, buflen + 1);

	/* It would only be a very brain-dead realloc that could fail, but... */
	if (!tmpbuf)
	{
		free(buffer);
		return NULL;
	}

	*retbuflen = buflen;
	return tmpbuf;
}
&lt;/pre&gt;</description>
<category>PostgreSQL</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bpostgre%20source%20code%5D%5D</link>
<pubDate>Wed, 30 Aug 2017 17:40:00 GMT</pubDate>

</item>
<item>
<title>postgresql source code 2</title>
<description>&lt;div class=&quot;dcTOC&quot;&gt;&lt;a class=&quot;toggleButton&quot; title=&quot;show/collapse table of contents&quot; href=&quot;javascript:;&quot;&gt;/* Table of Contents */&lt;/a&gt;&lt;div&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' hi', event)&quot;&gt; hi&lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' hello', event)&quot;&gt; hello&lt;/a&gt;&lt;/span&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;javascript:;&quot; onclick=&quot;window.scrollToHeading('', ' how are you', event)&quot;&gt; how are you&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;h1&gt; hi&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h2&gt; hello&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h2&gt;&lt;br&gt;&lt;h3&gt; how are you&lt;div style=&quot;font-size: 0.5em; color: blue;&quot;&gt;&lt;a class=&quot;dcTOCTop&quot; title=&quot;Go to top of tiddler&quot; href=&quot;javascript:;&quot;&gt; [top]&lt;/a&gt;&lt;/div&gt;&lt;/h3&gt;&lt;br&gt;&lt;pre&gt;
/*-------------------------------------------------------------------------
 *
 * fe-exec.c
 *	  functions related to sending a query down to the backend
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/interfaces/libpq/fe-exec.c
 *
 *-------------------------------------------------------------------------
 */
#include &quot;postgres_fe.h&quot;

#include &amp;lt;ctype.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;

#include &quot;libpq-fe.h&quot;
#include &quot;libpq-int.h&quot;

#include &quot;mb/pg_wchar.h&quot;

#ifdef WIN32
#include &quot;win32.h&quot;
#else
#include &amp;lt;unistd.h&amp;gt;
#endif

/* keep this in same order as ExecStatusType in libpq-fe.h */
char	   *const pgresStatus[] = {
	&quot;PGRES_EMPTY_QUERY&quot;,
	&quot;PGRES_COMMAND_OK&quot;,
	&quot;PGRES_TUPLES_OK&quot;,
	&quot;PGRES_COPY_OUT&quot;,
	&quot;PGRES_COPY_IN&quot;,
	&quot;PGRES_BAD_RESPONSE&quot;,
	&quot;PGRES_NONFATAL_ERROR&quot;,
	&quot;PGRES_FATAL_ERROR&quot;,
	&quot;PGRES_COPY_BOTH&quot;,
	&quot;PGRES_SINGLE_TUPLE&quot;
};

/*
 * static state needed by PQescapeString and PQescapeBytea; initialize to
 * values that result in backward-compatible behavior
 */
static int	static_client_encoding = PG_SQL_ASCII;
static bool static_std_strings = false;


static PGEvent *dupEvents(PGEvent *events, int count);
static bool pqAddTuple(PGresult *res, PGresAttValue *tup);
static bool PQsendQueryStart(PGconn *conn);
static int PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat);
static void parseInput(PGconn *conn);
static PGresult *getCopyResult(PGconn *conn, ExecStatusType copytype);
static bool PQexecStart(PGconn *conn);
static PGresult *PQexecFinish(PGconn *conn);
static int PQsendDescribe(PGconn *conn, char desc_type,
			   const char *desc_target);
static int	check_field_number(const PGresult *res, int field_num);


/* ----------------
 * Space management for PGresult.
 *
 * Formerly, libpq did a separate malloc() for each field of each tuple
 * returned by a query.  This was remarkably expensive --- malloc/free
 * consumed a sizable part of the application's runtime.  And there is
 * no real need to keep track of the fields separately, since they will
 * all be freed together when the PGresult is released.  So now, we grab
 * large blocks of storage from malloc and allocate space for query data
 * within these blocks, using a trivially simple allocator.  This reduces
 * the number of malloc/free calls dramatically, and it also avoids
 * fragmentation of the malloc storage arena.
 * The PGresult structure itself is still malloc'd separately.  We could
 * combine it with the first allocation block, but that would waste space
 * for the common case that no extra storage is actually needed (that is,
 * the SQL command did not return tuples).
 *
 * We also malloc the top-level array of tuple pointers separately, because
 * we need to be able to enlarge it via realloc, and our trivial space
 * allocator doesn't handle that effectively.  (Too bad the FE/BE protocol
 * doesn't tell us up front how many tuples will be returned.)
 * All other subsidiary storage for a PGresult is kept in PGresult_data blocks
 * of size PGRESULT_DATA_BLOCKSIZE.  The overhead at the start of each block
 * is just a link to the next one, if any.  Free-space management info is
 * kept in the owning PGresult.
 * A query returning a small amount of data will thus require three malloc
 * calls: one for the PGresult, one for the tuples pointer array, and one
 * PGresult_data block.
 *
 * Only the most recently allocated PGresult_data block is a candidate to
 * have more stuff added to it --- any extra space left over in older blocks
 * is wasted.  We could be smarter and search the whole chain, but the point
 * here is to be simple and fast.  Typical applications do not keep a PGresult
 * around very long anyway, so some wasted space within one is not a problem.
 *
 * Tuning constants for the space allocator are:
 * PGRESULT_DATA_BLOCKSIZE: size of a standard allocation block, in bytes
 * PGRESULT_ALIGN_BOUNDARY: assumed alignment requirement for binary data
 * PGRESULT_SEP_ALLOC_THRESHOLD: objects bigger than this are given separate
 *	 blocks, instead of being crammed into a regular allocation block.
 * Requirements for correct function are:
 * PGRESULT_ALIGN_BOUNDARY must be a multiple of the alignment requirements
 *		of all machine data types.  (Currently this is set from configure
 *		tests, so it should be OK automatically.)
 * PGRESULT_SEP_ALLOC_THRESHOLD + PGRESULT_BLOCK_OVERHEAD &amp;lt;=
 *			PGRESULT_DATA_BLOCKSIZE
 *		pqResultAlloc assumes an object smaller than the threshold will fit
 *		in a new block.
 * The amount of space wasted at the end of a block could be as much as
 * PGRESULT_SEP_ALLOC_THRESHOLD, so it doesn't pay to make that too large.
 * ----------------
 */

#define PGRESULT_DATA_BLOCKSIZE		2048
#define PGRESULT_ALIGN_BOUNDARY		MAXIMUM_ALIGNOF		/* from configure */
#define PGRESULT_BLOCK_OVERHEAD		Max(sizeof(PGresult_data), PGRESULT_ALIGN_BOUNDARY)
#define PGRESULT_SEP_ALLOC_THRESHOLD	(PGRESULT_DATA_BLOCKSIZE / 2)


/*
 * PQmakeEmptyPGresult
 *	 returns a newly allocated, initialized PGresult with given status.
 *	 If conn is not NULL and status indicates an error, the conn's
 *	 errorMessage is copied.  Also, any PGEvents are copied from the conn.
 */
PGresult *
PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status)
{
	PGresult   *result;

	result = (PGresult *) malloc(sizeof(PGresult));
	if (!result)
		return NULL;

	result-&amp;gt;ntups = 0;
	result-&amp;gt;numAttributes = 0;
	result-&amp;gt;attDescs = NULL;
	result-&amp;gt;tuples = NULL;
	result-&amp;gt;tupArrSize = 0;
	result-&amp;gt;numParameters = 0;
	result-&amp;gt;paramDescs = NULL;
	result-&amp;gt;resultStatus = status;
	result-&amp;gt;cmdStatus[0] = '\0';
	result-&amp;gt;binary = 0;
	result-&amp;gt;events = NULL;
	result-&amp;gt;nEvents = 0;
	result-&amp;gt;errMsg = NULL;
	result-&amp;gt;errFields = NULL;
	result-&amp;gt;errQuery = NULL;
	result-&amp;gt;null_field[0] = '\0';
	result-&amp;gt;curBlock = NULL;
	result-&amp;gt;curOffset = 0;
	result-&amp;gt;spaceLeft = 0;

	if (conn)
	{
		/* copy connection data we might need for operations on PGresult */
		result-&amp;gt;noticeHooks = conn-&amp;gt;noticeHooks;
		result-&amp;gt;client_encoding = conn-&amp;gt;client_encoding;

		/* consider copying conn's errorMessage */
		switch (status)
		{
			case PGRES_EMPTY_QUERY:
			case PGRES_COMMAND_OK:
			case PGRES_TUPLES_OK:
			case PGRES_COPY_OUT:
			case PGRES_COPY_IN:
			case PGRES_COPY_BOTH:
			case PGRES_SINGLE_TUPLE:
				/* non-error cases */
				break;
			default:
				pqSetResultError(result, conn-&amp;gt;errorMessage.data);
				break;
		}

		/* copy events last; result must be valid if we need to PQclear */
		if (conn-&amp;gt;nEvents &amp;gt; 0)
		{
			result-&amp;gt;events = dupEvents(conn-&amp;gt;events, conn-&amp;gt;nEvents);
			if (!result-&amp;gt;events)
			{
				PQclear(result);
				return NULL;
			}
			result-&amp;gt;nEvents = conn-&amp;gt;nEvents;
		}
	}
	else
	{
		/* defaults... */
		result-&amp;gt;noticeHooks.noticeRec = NULL;
		result-&amp;gt;noticeHooks.noticeRecArg = NULL;
		result-&amp;gt;noticeHooks.noticeProc = NULL;
		result-&amp;gt;noticeHooks.noticeProcArg = NULL;
		result-&amp;gt;client_encoding = PG_SQL_ASCII;
	}

	return result;
}

/*
 * PQsetResultAttrs
 *
 * Set the attributes for a given result.  This function fails if there are
 * already attributes contained in the provided result.  The call is
 * ignored if numAttributes is zero or attDescs is NULL.  If the
 * function fails, it returns zero.  If the function succeeds, it
 * returns a non-zero value.
 */
int
PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs)
{
	int			i;

	/* If attrs already exist, they cannot be overwritten. */
	if (!res || res-&amp;gt;numAttributes &amp;gt; 0)
		return FALSE;

	/* ignore no-op request */
	if (numAttributes &amp;lt;= 0 || !attDescs)
		return TRUE;

	res-&amp;gt;attDescs = (PGresAttDesc *)
		PQresultAlloc(res, numAttributes * sizeof(PGresAttDesc));

	if (!res-&amp;gt;attDescs)
		return FALSE;

	res-&amp;gt;numAttributes = numAttributes;
	memcpy(res-&amp;gt;attDescs, attDescs, numAttributes * sizeof(PGresAttDesc));

	/* deep-copy the attribute names, and determine format */
	res-&amp;gt;binary = 1;
	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (res-&amp;gt;attDescs[i].name)
			res-&amp;gt;attDescs[i].name = pqResultStrdup(res, res-&amp;gt;attDescs[i].name);
		else
			res-&amp;gt;attDescs[i].name = res-&amp;gt;null_field;

		if (!res-&amp;gt;attDescs[i].name)
			return FALSE;

		if (res-&amp;gt;attDescs[i].format == 0)
			res-&amp;gt;binary = 0;
	}

	return TRUE;
}

/*
 * PQcopyResult
 *
 * Returns a deep copy of the provided 'src' PGresult, which cannot be NULL.
 * The 'flags' argument controls which portions of the result will or will
 * NOT be copied.  The created result is always put into the
 * PGRES_TUPLES_OK status.  The source result error message is not copied,
 * although cmdStatus is.
 *
 * To set custom attributes, use PQsetResultAttrs.  That function requires
 * that there are no attrs contained in the result, so to use that
 * function you cannot use the PG_COPYRES_ATTRS or PG_COPYRES_TUPLES
 * options with this function.
 *
 * Options:
 *	 PG_COPYRES_ATTRS - Copy the source result's attributes
 *
 *	 PG_COPYRES_TUPLES - Copy the source result's tuples.  This implies
 *	 copying the attrs, seeing how the attrs are needed by the tuples.
 *
 *	 PG_COPYRES_EVENTS - Copy the source result's events.
 *
 *	 PG_COPYRES_NOTICEHOOKS - Copy the source result's notice hooks.
 */
PGresult *
PQcopyResult(const PGresult *src, int flags)
{
	PGresult   *dest;
	int			i;

	if (!src)
		return NULL;

	dest = PQmakeEmptyPGresult(NULL, PGRES_TUPLES_OK);
	if (!dest)
		return NULL;

	/* Always copy these over.  Is cmdStatus really useful here? */
	dest-&amp;gt;client_encoding = src-&amp;gt;client_encoding;
	strcpy(dest-&amp;gt;cmdStatus, src-&amp;gt;cmdStatus);

	/* Wants attrs? */
	if (flags &amp;amp; (PG_COPYRES_ATTRS | PG_COPYRES_TUPLES))
	{
		if (!PQsetResultAttrs(dest, src-&amp;gt;numAttributes, src-&amp;gt;attDescs))
		{
			PQclear(dest);
			return NULL;
		}
	}

	/* Wants to copy tuples? */
	if (flags &amp;amp; PG_COPYRES_TUPLES)
	{
		int			tup,
					field;

		for (tup = 0; tup &amp;lt; src-&amp;gt;ntups; tup++)
		{
			for (field = 0; field &amp;lt; src-&amp;gt;numAttributes; field++)
			{
				if (!PQsetvalue(dest, tup, field,
								src-&amp;gt;tuples[tup][field].value,
								src-&amp;gt;tuples[tup][field].len))
				{
					PQclear(dest);
					return NULL;
				}
			}
		}
	}

	/* Wants to copy notice hooks? */
	if (flags &amp;amp; PG_COPYRES_NOTICEHOOKS)
		dest-&amp;gt;noticeHooks = src-&amp;gt;noticeHooks;

	/* Wants to copy PGEvents? */
	if ((flags &amp;amp; PG_COPYRES_EVENTS) &amp;amp;&amp;amp; src-&amp;gt;nEvents &amp;gt; 0)
	{
		dest-&amp;gt;events = dupEvents(src-&amp;gt;events, src-&amp;gt;nEvents);
		if (!dest-&amp;gt;events)
		{
			PQclear(dest);
			return NULL;
		}
		dest-&amp;gt;nEvents = src-&amp;gt;nEvents;
	}

	/* Okay, trigger PGEVT_RESULTCOPY event */
	for (i = 0; i &amp;lt; dest-&amp;gt;nEvents; i++)
	{
		if (src-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultCopy evt;

			evt.src = src;
			evt.dest = dest;
			if (!dest-&amp;gt;events[i].proc(PGEVT_RESULTCOPY, &amp;amp;evt,
									  dest-&amp;gt;events[i].passThrough))
			{
				PQclear(dest);
				return NULL;
			}
			dest-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return dest;
}

/*
 * Copy an array of PGEvents (with no extra space for more).
 * Does not duplicate the event instance data, sets this to NULL.
 * Also, the resultInitialized flags are all cleared.
 */
static PGEvent *
dupEvents(PGEvent *events, int count)
{
	PGEvent    *newEvents;
	int			i;

	if (!events || count &amp;lt;= 0)
		return NULL;

	newEvents = (PGEvent *) malloc(count * sizeof(PGEvent));
	if (!newEvents)
		return NULL;

	for (i = 0; i &amp;lt; count; i++)
	{
		newEvents[i].proc = events[i].proc;
		newEvents[i].passThrough = events[i].passThrough;
		newEvents[i].data = NULL;
		newEvents[i].resultInitialized = FALSE;
		newEvents[i].name = strdup(events[i].name);
		if (!newEvents[i].name)
		{
			while (--i &amp;gt;= 0)
				free(newEvents[i].name);
			free(newEvents);
			return NULL;
		}
	}

	return newEvents;
}


/*
 * Sets the value for a tuple field.  The tup_num must be less than or
 * equal to PQntuples(res).  If it is equal, a new tuple is created and
 * added to the result.
 * Returns a non-zero value for success and zero for failure.
 */
int
PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len)
{
	PGresAttValue *attval;

	if (!check_field_number(res, field_num))
		return FALSE;

	/* Invalid tup_num, must be &amp;lt;= ntups */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt; res-&amp;gt;ntups)
		return FALSE;

	/* need to allocate a new tuple? */
	if (tup_num == res-&amp;gt;ntups)
	{
		PGresAttValue *tup;
		int			i;

		tup = (PGresAttValue *)
			pqResultAlloc(res, res-&amp;gt;numAttributes * sizeof(PGresAttValue),
						  TRUE);

		if (!tup)
			return FALSE;

		/* initialize each column to NULL */
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
		{
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}

		/* add it to the array */
		if (!pqAddTuple(res, tup))
			return FALSE;
	}

	attval = &amp;amp;res-&amp;gt;tuples[tup_num][field_num];

	/* treat either NULL_LEN or NULL value pointer as a NULL field */
	if (len == NULL_LEN || value == NULL)
	{
		attval-&amp;gt;len = NULL_LEN;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else if (len &amp;lt;= 0)
	{
		attval-&amp;gt;len = 0;
		attval-&amp;gt;value = res-&amp;gt;null_field;
	}
	else
	{
		attval-&amp;gt;value = (char *) pqResultAlloc(res, len + 1, TRUE);
		if (!attval-&amp;gt;value)
			return FALSE;
		attval-&amp;gt;len = len;
		memcpy(attval-&amp;gt;value, value, len);
		attval-&amp;gt;value[len] = '\0';
	}

	return TRUE;
}

/*
 * pqResultAlloc - exported routine to allocate local storage in a PGresult.
 *
 * We force all such allocations to be maxaligned, since we don't know
 * whether the value might be binary.
 */
void *
PQresultAlloc(PGresult *res, size_t nBytes)
{
	return pqResultAlloc(res, nBytes, TRUE);
}

/*
 * pqResultAlloc -
 *		Allocate subsidiary storage for a PGresult.
 *
 * nBytes is the amount of space needed for the object.
 * If isBinary is true, we assume that we need to align the object on
 * a machine allocation boundary.
 * If isBinary is false, we assume the object is a char string and can
 * be allocated on any byte boundary.
 */
void *
pqResultAlloc(PGresult *res, size_t nBytes, bool isBinary)
{
	char	   *space;
	PGresult_data *block;

	if (!res)
		return NULL;

	if (nBytes &amp;lt;= 0)
		return res-&amp;gt;null_field;

	/*
	 * If alignment is needed, round up the current position to an alignment
	 * boundary.
	 */
	if (isBinary)
	{
		int			offset = res-&amp;gt;curOffset % PGRESULT_ALIGN_BOUNDARY;

		if (offset)
		{
			res-&amp;gt;curOffset += PGRESULT_ALIGN_BOUNDARY - offset;
			res-&amp;gt;spaceLeft -= PGRESULT_ALIGN_BOUNDARY - offset;
		}
	}

	/* If there's enough space in the current block, no problem. */
	if (nBytes &amp;lt;= (size_t) res-&amp;gt;spaceLeft)
	{
		space = res-&amp;gt;curBlock-&amp;gt;space + res-&amp;gt;curOffset;
		res-&amp;gt;curOffset += nBytes;
		res-&amp;gt;spaceLeft -= nBytes;
		return space;
	}

	/*
	 * If the requested object is very large, give it its own block; this
	 * avoids wasting what might be most of the current block to start a new
	 * block.  (We'd have to special-case requests bigger than the block size
	 * anyway.)  The object is always given binary alignment in this case.
	 */
	if (nBytes &amp;gt;= PGRESULT_SEP_ALLOC_THRESHOLD)
	{
		block = (PGresult_data *) malloc(nBytes + PGRESULT_BLOCK_OVERHEAD);
		if (!block)
			return NULL;
		space = block-&amp;gt;space + PGRESULT_BLOCK_OVERHEAD;
		if (res-&amp;gt;curBlock)
		{
			/*
			 * Tuck special block below the active block, so that we don't
			 * have to waste the free space in the active block.
			 */
			block-&amp;gt;next = res-&amp;gt;curBlock-&amp;gt;next;
			res-&amp;gt;curBlock-&amp;gt;next = block;
		}
		else
		{
			/* Must set up the new block as the first active block. */
			block-&amp;gt;next = NULL;
			res-&amp;gt;curBlock = block;
			res-&amp;gt;spaceLeft = 0; /* be sure it's marked full */
		}
		return space;
	}

	/* Otherwise, start a new block. */
	block = (PGresult_data *) malloc(PGRESULT_DATA_BLOCKSIZE);
	if (!block)
		return NULL;
	block-&amp;gt;next = res-&amp;gt;curBlock;
	res-&amp;gt;curBlock = block;
	if (isBinary)
	{
		/* object needs full alignment */
		res-&amp;gt;curOffset = PGRESULT_BLOCK_OVERHEAD;
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - PGRESULT_BLOCK_OVERHEAD;
	}
	else
	{
		/* we can cram it right after the overhead pointer */
		res-&amp;gt;curOffset = sizeof(PGresult_data);
		res-&amp;gt;spaceLeft = PGRESULT_DATA_BLOCKSIZE - sizeof(PGresult_data);
	}

	space = block-&amp;gt;space + res-&amp;gt;curOffset;
	res-&amp;gt;curOffset += nBytes;
	res-&amp;gt;spaceLeft -= nBytes;
	return space;
}

/*
 * pqResultStrdup -
 *		Like strdup, but the space is subsidiary PGresult space.
 */
char *
pqResultStrdup(PGresult *res, const char *str)
{
	char	   *space = (char *) pqResultAlloc(res, strlen(str) + 1, FALSE);

	if (space)
		strcpy(space, str);
	return space;
}

/*
 * pqSetResultError -
 *		assign a new error message to a PGresult
 */
void
pqSetResultError(PGresult *res, const char *msg)
{
	if (!res)
		return;
	if (msg &amp;amp;&amp;amp; *msg)
		res-&amp;gt;errMsg = pqResultStrdup(res, msg);
	else
		res-&amp;gt;errMsg = NULL;
}

/*
 * pqCatenateResultError -
 *		concatenate a new error message to the one already in a PGresult
 */
void
pqCatenateResultError(PGresult *res, const char *msg)
{
	PQExpBufferData errorBuf;

	if (!res || !msg)
		return;
	initPQExpBuffer(&amp;amp;errorBuf);
	if (res-&amp;gt;errMsg)
		appendPQExpBufferStr(&amp;amp;errorBuf, res-&amp;gt;errMsg);
	appendPQExpBufferStr(&amp;amp;errorBuf, msg);
	pqSetResultError(res, errorBuf.data);
	termPQExpBuffer(&amp;amp;errorBuf);
}

/*
 * PQclear -
 *	  free's the memory associated with a PGresult
 */
void
PQclear(PGresult *res)
{
	PGresult_data *block;
	int			i;

	if (!res)
		return;

	for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
	{
		/* only send DESTROY to successfully-initialized event procs */
		if (res-&amp;gt;events[i].resultInitialized)
		{
			PGEventResultDestroy evt;

			evt.result = res;
			(void) res-&amp;gt;events[i].proc(PGEVT_RESULTDESTROY, &amp;amp;evt,
									   res-&amp;gt;events[i].passThrough);
		}
		free(res-&amp;gt;events[i].name);
	}

	if (res-&amp;gt;events)
		free(res-&amp;gt;events);

	/* Free all the subsidiary blocks */
	while ((block = res-&amp;gt;curBlock) != NULL)
	{
		res-&amp;gt;curBlock = block-&amp;gt;next;
		free(block);
	}

	/* Free the top-level tuple pointer array */
	if (res-&amp;gt;tuples)
		free(res-&amp;gt;tuples);

	/* zero out the pointer fields to catch programming errors */
	res-&amp;gt;attDescs = NULL;
	res-&amp;gt;tuples = NULL;
	res-&amp;gt;paramDescs = NULL;
	res-&amp;gt;errFields = NULL;
	res-&amp;gt;events = NULL;
	res-&amp;gt;nEvents = 0;
	/* res-&amp;gt;curBlock was zeroed out earlier */

	/* Free the PGresult structure itself */
	free(res);
}

/*
 * Handy subroutine to deallocate any partially constructed async result.
 *
 * Any &quot;next&quot; result gets cleared too.
 */
void
pqClearAsyncResult(PGconn *conn)
{
	if (conn-&amp;gt;result)
		PQclear(conn-&amp;gt;result);
	conn-&amp;gt;result = NULL;
	if (conn-&amp;gt;next_result)
		PQclear(conn-&amp;gt;next_result);
	conn-&amp;gt;next_result = NULL;
}

/*
 * This subroutine deletes any existing async result, sets conn-&amp;gt;result
 * to a PGresult with status PGRES_FATAL_ERROR, and stores the current
 * contents of conn-&amp;gt;errorMessage into that result.  It differs from a
 * plain call on PQmakeEmptyPGresult() in that if there is already an
 * async result with status PGRES_FATAL_ERROR, the current error message
 * is APPENDED to the old error message instead of replacing it.  This
 * behavior lets us report multiple error conditions properly, if necessary.
 * (An example where this is needed is when the backend sends an 'E' message
 * and immediately closes the connection --- we want to report both the
 * backend error and the connection closure error.)
 */
void
pqSaveErrorResult(PGconn *conn)
{
	/*
	 * If no old async result, just let PQmakeEmptyPGresult make one. Likewise
	 * if old result is not an error message.
	 */
	if (conn-&amp;gt;result == NULL ||
		conn-&amp;gt;result-&amp;gt;resultStatus != PGRES_FATAL_ERROR ||
		conn-&amp;gt;result-&amp;gt;errMsg == NULL)
	{
		pqClearAsyncResult(conn);
		conn-&amp;gt;result = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	}
	else
	{
		/* Else, concatenate error message to existing async result. */
		pqCatenateResultError(conn-&amp;gt;result, conn-&amp;gt;errorMessage.data);
	}
}

/*
 * This subroutine prepares an async result object for return to the caller.
 * If there is not already an async result object, build an error object
 * using whatever is in conn-&amp;gt;errorMessage.  In any case, clear the async
 * result storage and make sure PQerrorMessage will agree with the result's
 * error string.
 */
PGresult *
pqPrepareAsyncResult(PGconn *conn)
{
	PGresult   *res;

	/*
	 * conn-&amp;gt;result is the PGresult to return.  If it is NULL (which probably
	 * shouldn't happen) we assume there is an appropriate error message in
	 * conn-&amp;gt;errorMessage.
	 */
	res = conn-&amp;gt;result;
	if (!res)
		res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
	else
	{
		/*
		 * Make sure PQerrorMessage agrees with result; it could be different
		 * if we have concatenated messages.
		 */
		resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
		appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage,
							 PQresultErrorMessage(res));
	}

	/*
	 * Replace conn-&amp;gt;result with next_result, if any.  In the normal case
	 * there isn't a next result and we're just dropping ownership of the
	 * current result.  In single-row mode this restores the situation to what
	 * it was before we created the current single-row result.
	 */
	conn-&amp;gt;result = conn-&amp;gt;next_result;
	conn-&amp;gt;next_result = NULL;

	return res;
}

/*
 * pqInternalNotice - produce an internally-generated notice message
 *
 * A format string and optional arguments can be passed.  Note that we do
 * libpq_gettext() here, so callers need not.
 *
 * The supplied text is taken as primary message (ie., it should not include
 * a trailing newline, and should not be more than one line).
 */
void
pqInternalNotice(const PGNoticeHooks *hooks, const char *fmt,...)
{
	char		msgBuf[1024];
	va_list		args;
	PGresult   *res;

	if (hooks-&amp;gt;noticeRec == NULL)
		return;					/* nobody home to receive notice? */

	/* Format the message */
	va_start(args, fmt);
	vsnprintf(msgBuf, sizeof(msgBuf), libpq_gettext(fmt), args);
	va_end(args);
	msgBuf[sizeof(msgBuf) - 1] = '\0';	/* make real sure it's terminated */

	/* Make a PGresult to pass to the notice receiver */
	res = PQmakeEmptyPGresult(NULL, PGRES_NONFATAL_ERROR);
	if (!res)
		return;
	res-&amp;gt;noticeHooks = *hooks;

	/*
	 * Set up fields of notice.
	 */
	pqSaveMessageField(res, PG_DIAG_MESSAGE_PRIMARY, msgBuf);
	pqSaveMessageField(res, PG_DIAG_SEVERITY, libpq_gettext(&quot;NOTICE&quot;));
	pqSaveMessageField(res, PG_DIAG_SEVERITY_NONLOCALIZED, &quot;NOTICE&quot;);
	/* XXX should provide a SQLSTATE too? */

	/*
	 * Result text is always just the primary message + newline. If we can't
	 * allocate it, don't bother invoking the receiver.
	 */
	res-&amp;gt;errMsg = (char *) pqResultAlloc(res, strlen(msgBuf) + 2, FALSE);
	if (res-&amp;gt;errMsg)
	{
		sprintf(res-&amp;gt;errMsg, &quot;%s\n&quot;, msgBuf);

		/*
		 * Pass to receiver, then free it.
		 */
		(*res-&amp;gt;noticeHooks.noticeRec) (res-&amp;gt;noticeHooks.noticeRecArg, res);
	}
	PQclear(res);
}

/*
 * pqAddTuple
 *	  add a row pointer to the PGresult structure, growing it if necessary
 *	  Returns TRUE if OK, FALSE if not enough memory to add the row
 */
static bool
pqAddTuple(PGresult *res, PGresAttValue *tup)
{
	if (res-&amp;gt;ntups &amp;gt;= res-&amp;gt;tupArrSize)
	{
		/*
		 * Try to grow the array.
		 *
		 * We can use realloc because shallow copying of the structure is
		 * okay. Note that the first time through, res-&amp;gt;tuples is NULL. While
		 * ANSI says that realloc() should act like malloc() in that case,
		 * some old C libraries (like SunOS 4.1.x) coredump instead. On
		 * failure realloc is supposed to return NULL without damaging the
		 * existing allocation. Note that the positions beyond res-&amp;gt;ntups are
		 * garbage, not necessarily NULL.
		 */
		int			newSize = (res-&amp;gt;tupArrSize &amp;gt; 0) ? res-&amp;gt;tupArrSize * 2 : 128;
		PGresAttValue **newTuples;

		if (res-&amp;gt;tuples == NULL)
			newTuples = (PGresAttValue **)
				malloc(newSize * sizeof(PGresAttValue *));
		else
			newTuples = (PGresAttValue **)
				realloc(res-&amp;gt;tuples, newSize * sizeof(PGresAttValue *));
		if (!newTuples)
			return FALSE;		/* malloc or realloc failed */
		res-&amp;gt;tupArrSize = newSize;
		res-&amp;gt;tuples = newTuples;
	}
	res-&amp;gt;tuples[res-&amp;gt;ntups] = tup;
	res-&amp;gt;ntups++;
	return TRUE;
}

/*
 * pqSaveMessageField - save one field of an error or notice message
 */
void
pqSaveMessageField(PGresult *res, char code, const char *value)
{
	PGMessageField *pfield;

	pfield = (PGMessageField *)
		pqResultAlloc(res,
					  offsetof(PGMessageField, contents) +
					  strlen(value) + 1,
					  TRUE);
	if (!pfield)
		return;					/* out of memory? */
	pfield-&amp;gt;code = code;
	strcpy(pfield-&amp;gt;contents, value);
	pfield-&amp;gt;next = res-&amp;gt;errFields;
	res-&amp;gt;errFields = pfield;
}

/*
 * pqSaveParameterStatus - remember parameter status sent by backend
 */
void
pqSaveParameterStatus(PGconn *conn, const char *name, const char *value)
{
	pgParameterStatus *pstatus;
	pgParameterStatus *prev;

	if (conn-&amp;gt;Pfdebug)
		fprintf(conn-&amp;gt;Pfdebug, &quot;pqSaveParameterStatus: '%s' = '%s'\n&quot;,
				name, value);

	/*
	 * Forget any old information about the parameter
	 */
	for (pstatus = conn-&amp;gt;pstatus, prev = NULL;
		 pstatus != NULL;
		 prev = pstatus, pstatus = pstatus-&amp;gt;next)
	{
		if (strcmp(pstatus-&amp;gt;name, name) == 0)
		{
			if (prev)
				prev-&amp;gt;next = pstatus-&amp;gt;next;
			else
				conn-&amp;gt;pstatus = pstatus-&amp;gt;next;
			free(pstatus);		/* frees name and value strings too */
			break;
		}
	}

	/*
	 * Store new info as a single malloc block
	 */
	pstatus = (pgParameterStatus *) malloc(sizeof(pgParameterStatus) +
										   strlen(name) +strlen(value) + 2);
	if (pstatus)
	{
		char	   *ptr;

		ptr = ((char *) pstatus) + sizeof(pgParameterStatus);
		pstatus-&amp;gt;name = ptr;
		strcpy(ptr, name);
		ptr += strlen(name) + 1;
		pstatus-&amp;gt;value = ptr;
		strcpy(ptr, value);
		pstatus-&amp;gt;next = conn-&amp;gt;pstatus;
		conn-&amp;gt;pstatus = pstatus;
	}

	/*
	 * Special hacks: remember client_encoding and
	 * standard_conforming_strings, and convert server version to a numeric
	 * form.  We keep the first two of these in static variables as well, so
	 * that PQescapeString and PQescapeBytea can behave somewhat sanely (at
	 * least in single-connection-using programs).
	 */
	if (strcmp(name, &quot;client_encoding&quot;) == 0)
	{
		conn-&amp;gt;client_encoding = pg_char_to_encoding(value);
		/* if we don't recognize the encoding name, fall back to SQL_ASCII */
		if (conn-&amp;gt;client_encoding &amp;lt; 0)
			conn-&amp;gt;client_encoding = PG_SQL_ASCII;
		static_client_encoding = conn-&amp;gt;client_encoding;
	}
	else if (strcmp(name, &quot;standard_conforming_strings&quot;) == 0)
	{
		conn-&amp;gt;std_strings = (strcmp(value, &quot;on&quot;) == 0);
		static_std_strings = conn-&amp;gt;std_strings;
	}
	else if (strcmp(name, &quot;server_version&quot;) == 0)
	{
		int			cnt;
		int			vmaj,
					vmin,
					vrev;

		cnt = sscanf(value, &quot;%d.%d.%d&quot;, &amp;amp;vmaj, &amp;amp;vmin, &amp;amp;vrev);

		if (cnt == 3)
		{
			/* old style, e.g. 9.6.1 */
			conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100 + vrev;
		}
		else if (cnt == 2)
		{
			if (vmaj &amp;gt;= 10)
			{
				/* new style, e.g. 10.1 */
				conn-&amp;gt;sversion = 100 * 100 * vmaj + vmin;
			}
			else
			{
				/* old style without minor version, e.g. 9.6devel */
				conn-&amp;gt;sversion = (100 * vmaj + vmin) * 100;
			}
		}
		else if (cnt == 1)
		{
			/* new style without minor version, e.g. 10devel */
			conn-&amp;gt;sversion = 100 * 100 * vmaj;
		}
		else
			conn-&amp;gt;sversion = 0; /* unknown */
	}
}


/*
 * pqRowProcessor
 *	  Add the received row to the current async result (conn-&amp;gt;result).
 *	  Returns 1 if OK, 0 if error occurred.
 *
 * On error, *errmsgp can be set to an error string to be returned.
 * If it is left NULL, the error is presumed to be &quot;out of memory&quot;.
 *
 * In single-row mode, we create a new result holding just the current row,
 * stashing the previous result in conn-&amp;gt;next_result so that it becomes
 * active again after pqPrepareAsyncResult().  This allows the result metadata
 * (column descriptions) to be carried forward to each result row.
 */
int
pqRowProcessor(PGconn *conn, const char **errmsgp)
{
	PGresult   *res = conn-&amp;gt;result;
	int			nfields = res-&amp;gt;numAttributes;
	const PGdataValue *columns = conn-&amp;gt;rowBuf;
	PGresAttValue *tup;
	int			i;

	/*
	 * In single-row mode, make a new PGresult that will hold just this one
	 * row; the original conn-&amp;gt;result is left unchanged so that it can be used
	 * again as the template for future rows.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Copy everything that should be in the result at this point */
		res = PQcopyResult(res,
						   PG_COPYRES_ATTRS | PG_COPYRES_EVENTS |
						   PG_COPYRES_NOTICEHOOKS);
		if (!res)
			return 0;
	}

	/*
	 * Basically we just allocate space in the PGresult for each field and
	 * copy the data over.
	 *
	 * Note: on malloc failure, we return 0 leaving *errmsgp still NULL, which
	 * caller will take to mean &quot;out of memory&quot;.  This is preferable to trying
	 * to set up such a message here, because evidently there's not enough
	 * memory for gettext() to do anything.
	 */
	tup = (PGresAttValue *)
		pqResultAlloc(res, nfields * sizeof(PGresAttValue), TRUE);
	if (tup == NULL)
		goto fail;

	for (i = 0; i &amp;lt; nfields; i++)
	{
		int			clen = columns[i].len;

		if (clen &amp;lt; 0)
		{
			/* null field */
			tup[i].len = NULL_LEN;
			tup[i].value = res-&amp;gt;null_field;
		}
		else
		{
			bool		isbinary = (res-&amp;gt;attDescs[i].format != 0);
			char	   *val;

			val = (char *) pqResultAlloc(res, clen + 1, isbinary);
			if (val == NULL)
				goto fail;

			/* copy and zero-terminate the data (even if it's binary) */
			memcpy(val, columns[i].value, clen);
			val[clen] = '\0';

			tup[i].len = clen;
			tup[i].value = val;
		}
	}

	/* And add the tuple to the PGresult's tuple array */
	if (!pqAddTuple(res, tup))
		goto fail;

	/*
	 * Success.  In single-row mode, make the result available to the client
	 * immediately.
	 */
	if (conn-&amp;gt;singleRowMode)
	{
		/* Change result status to special single-row value */
		res-&amp;gt;resultStatus = PGRES_SINGLE_TUPLE;
		/* Stash old result for re-use later */
		conn-&amp;gt;next_result = conn-&amp;gt;result;
		conn-&amp;gt;result = res;
		/* And mark the result ready to return */
		conn-&amp;gt;asyncStatus = PGASYNC_READY;
	}

	return 1;

fail:
	/* release locally allocated PGresult, if we made one */
	if (res != conn-&amp;gt;result)
		PQclear(res);
	return 0;
}


/*
 * PQsendQuery
 *	 Submit a query, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendQuery(PGconn *conn, const char *query)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the argument */
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}

	/* construct the outgoing Query message */
	if (pqPutMsgStart('Q', false, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* remember we are using simple query protocol */
	conn-&amp;gt;queryclass = PGQUERY_SIMPLE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
	{
		pqHandleSendFailure(conn);
		return 0;
	}

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;
}

/*
 * PQsendQueryParams
 *		Like PQsendQuery, but use protocol 3.0 so we can pass parameters
 */
int
PQsendQueryParams(PGconn *conn,
				  const char *command,
				  int nParams,
				  const Oid *paramTypes,
				  const char *const * paramValues,
				  const int *paramLengths,
				  const int *paramFormats,
				  int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!command)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   command,
						   &quot;&quot;,	/* use unnamed statement */
						   nParams,
						   paramTypes,
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * PQsendPrepare
 *	 Submit a Parse message, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendPrepare(PGconn *conn,
			  const char *stmtName, const char *query,
			  int nParams, const Oid *paramTypes)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (!query)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;command string is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Parse message */
	if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0 ||
		pqPuts(query, conn) &amp;lt; 0)
		goto sendFailed;

	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
	{
		int			i;

		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing just a Parse */
	conn-&amp;gt;queryclass = PGQUERY_PREPARE;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	conn-&amp;gt;last_query = strdup(query);

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQsendQueryPrepared
 *		Like PQsendQuery, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
int
PQsendQueryPrepared(PGconn *conn,
					const char *stmtName,
					int nParams,
					const char *const * paramValues,
					const int *paramLengths,
					const int *paramFormats,
					int resultFormat)
{
	if (!PQsendQueryStart(conn))
		return 0;

	/* check the arguments */
	if (!stmtName)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						libpq_gettext(&quot;statement name is a null pointer\n&quot;));
		return 0;
	}
	if (nParams &amp;lt; 0 || nParams &amp;gt; 65535)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		libpq_gettext(&quot;number of parameters must be between 0 and 65535\n&quot;));
		return 0;
	}

	return PQsendQueryGuts(conn,
						   NULL,	/* no command to parse */
						   stmtName,
						   nParams,
						   NULL,	/* no param types */
						   paramValues,
						   paramLengths,
						   paramFormats,
						   resultFormat);
}

/*
 * Common startup code for PQsendQuery and sibling routines
 */
static bool
PQsendQueryStart(PGconn *conn)
{
	if (!conn)
		return false;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Don't try to send if we know there's no live connection. */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no connection to the server\n&quot;));
		return false;
	}
	/* Can't send while already busy, either. */
	if (conn-&amp;gt;asyncStatus != PGASYNC_IDLE)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;another command is already in progress\n&quot;));
		return false;
	}

	/* initialize async result-accumulation state */
	pqClearAsyncResult(conn);

	/* reset single-row processing mode */
	conn-&amp;gt;singleRowMode = false;

	/* ready to send command message */
	return true;
}

/*
 * PQsendQueryGuts
 *		Common code for protocol-3.0 query sending
 *		PQsendQueryStart should be done already
 *
 * command may be NULL to indicate we use an already-prepared statement
 */
static int
PQsendQueryGuts(PGconn *conn,
				const char *command,
				const char *stmtName,
				int nParams,
				const Oid *paramTypes,
				const char *const * paramValues,
				const int *paramLengths,
				const int *paramFormats,
				int resultFormat)
{
	int			i;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/*
	 * We will send Parse (if needed), Bind, Describe Portal, Execute, Sync,
	 * using specified statement name and the unnamed portal.
	 */

	if (command)
	{
		/* construct the Parse message */
		if (pqPutMsgStart('P', false, conn) &amp;lt; 0 ||
			pqPuts(stmtName, conn) &amp;lt; 0 ||
			pqPuts(command, conn) &amp;lt; 0)
			goto sendFailed;
		if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramTypes)
		{
			if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
				goto sendFailed;
			for (i = 0; i &amp;lt; nParams; i++)
			{
				if (pqPutInt(paramTypes[i], 4, conn) &amp;lt; 0)
					goto sendFailed;
			}
		}
		else
		{
			if (pqPutInt(0, 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
		if (pqPutMsgEnd(conn) &amp;lt; 0)
			goto sendFailed;
	}

	/* Construct the Bind message */
	if (pqPutMsgStart('B', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPuts(stmtName, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameter formats */
	if (nParams &amp;gt; 0 &amp;amp;&amp;amp; paramFormats)
	{
		if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
			goto sendFailed;
		for (i = 0; i &amp;lt; nParams; i++)
		{
			if (pqPutInt(paramFormats[i], 2, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	else
	{
		if (pqPutInt(0, 2, conn) &amp;lt; 0)
			goto sendFailed;
	}

	if (pqPutInt(nParams, 2, conn) &amp;lt; 0)
		goto sendFailed;

	/* Send parameters */
	for (i = 0; i &amp;lt; nParams; i++)
	{
		if (paramValues &amp;amp;&amp;amp; paramValues[i])
		{
			int			nbytes;

			if (paramFormats &amp;amp;&amp;amp; paramFormats[i] != 0)
			{
				/* binary parameter */
				if (paramLengths)
					nbytes = paramLengths[i];
				else
				{
					printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
									  libpq_gettext(&quot;length must be given for binary parameter\n&quot;));
					goto sendFailed;
				}
			}
			else
			{
				/* text parameter, do not use paramLengths */
				nbytes = strlen(paramValues[i]);
			}
			if (pqPutInt(nbytes, 4, conn) &amp;lt; 0 ||
				pqPutnchar(paramValues[i], nbytes, conn) &amp;lt; 0)
				goto sendFailed;
		}
		else
		{
			/* take the param as NULL */
			if (pqPutInt(-1, 4, conn) &amp;lt; 0)
				goto sendFailed;
		}
	}
	if (pqPutInt(1, 2, conn) &amp;lt; 0 ||
		pqPutInt(resultFormat, 2, conn))
		goto sendFailed;
	if (pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Describe Portal message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc('P', conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Execute message */
	if (pqPutMsgStart('E', false, conn) &amp;lt; 0 ||
		pqPuts(&quot;&quot;, conn) &amp;lt; 0 ||
		pqPutInt(0, 4, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are using extended query protocol */
	conn-&amp;gt;queryclass = PGQUERY_EXTENDED;

	/* and remember the query text too, if possible */
	/* if insufficient memory, last_query just winds up NULL */
	if (conn-&amp;gt;last_query)
		free(conn-&amp;gt;last_query);
	if (command)
		conn-&amp;gt;last_query = strdup(command);
	else
		conn-&amp;gt;last_query = NULL;

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * pqHandleSendFailure: try to clean up after failure to send command.
 *
 * Primarily, what we want to accomplish here is to process any ERROR or
 * NOTICE messages that the backend might have sent just before it died.
 * Since we're in IDLE state, all such messages will get sent to the notice
 * processor.
 *
 * NOTE: this routine should only be called in PGASYNC_IDLE state.
 */
void
pqHandleSendFailure(PGconn *conn)
{
	/*
	 * Accept and parse any available input data, ignoring I/O errors.  Note
	 * that if pqReadData decides the backend has closed the channel, it will
	 * close our side of the socket --- that's just what we want here.
	 */
	while (pqReadData(conn) &amp;gt; 0)
		parseInput(conn);

	/*
	 * Be sure to parse available input messages even if we read no data.
	 * (Note: calling parseInput within the above loop isn't really necessary,
	 * but it prevents buffer bloat if there's a lot of data available.)
	 */
	parseInput(conn);
}

/*
 * Select row-by-row processing mode
 */
int
PQsetSingleRowMode(PGconn *conn)
{
	/*
	 * Only allow setting the flag when we have launched a query and not yet
	 * received any results.
	 */
	if (!conn)
		return 0;
	if (conn-&amp;gt;asyncStatus != PGASYNC_BUSY)
		return 0;
	if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE &amp;amp;&amp;amp;
		conn-&amp;gt;queryclass != PGQUERY_EXTENDED)
		return 0;
	if (conn-&amp;gt;result)
		return 0;

	/* OK, set flag */
	conn-&amp;gt;singleRowMode = true;
	return 1;
}

/*
 * Consume any available input from the backend
 * 0 return: some kind of trouble
 * 1 return: no problem
 */
int
PQconsumeInput(PGconn *conn)
{
	if (!conn)
		return 0;

	/*
	 * for non-blocking connections try to flush the send-queue, otherwise we
	 * may never get a response for something that may not have already been
	 * sent because it's in our write buffer!
	 */
	if (pqIsnonblocking(conn))
	{
		if (pqFlush(conn) &amp;lt; 0)
			return 0;
	}

	/*
	 * Load more data, if available. We do this no matter what state we are
	 * in, since we are probably getting called because the application wants
	 * to get rid of a read-select condition. Note that we will NOT block
	 * waiting for more input.
	 */
	if (pqReadData(conn) &amp;lt; 0)
		return 0;

	/* Parsing of the data waits till later. */
	return 1;
}


/*
 * parseInput: if appropriate, parse input data from backend
 * until input is exhausted or a stopping state is reached.
 * Note that this function will NOT attempt to read more data from the backend.
 */
static void
parseInput(PGconn *conn)
{
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		pqParseInput3(conn);
	else
		pqParseInput2(conn);
}

/*
 * PQisBusy
 *	 Return TRUE if PQgetResult would block waiting for input.
 */

int
PQisBusy(PGconn *conn)
{
	if (!conn)
		return FALSE;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* PQgetResult will return immediately in all states except BUSY. */
	return conn-&amp;gt;asyncStatus == PGASYNC_BUSY;
}


/*
 * PQgetResult
 *	  Get the next PGresult produced by a query.  Returns NULL if no
 *	  query work remains or an error has occurred (e.g. out of
 *	  memory).
 */

PGresult *
PQgetResult(PGconn *conn)
{
	PGresult   *res;

	if (!conn)
		return NULL;

	/* Parse any available data, if our state permits. */
	parseInput(conn);

	/* If not ready to return something, block until we are. */
	while (conn-&amp;gt;asyncStatus == PGASYNC_BUSY)
	{
		int			flushResult;

		/*
		 * If data remains unsent, send it.  Else we might be waiting for the
		 * result of a command the backend hasn't even got yet.
		 */
		while ((flushResult = pqFlush(conn)) &amp;gt; 0)
		{
			if (pqWait(FALSE, TRUE, conn))
			{
				flushResult = -1;
				break;
			}
		}

		/* Wait for some more data, and load it. */
		if (flushResult ||
			pqWait(TRUE, FALSE, conn) ||
			pqReadData(conn) &amp;lt; 0)
		{
			/*
			 * conn-&amp;gt;errorMessage has been set by pqWait or pqReadData. We
			 * want to append it to any already-received error message.
			 */
			pqSaveErrorResult(conn);
			conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
			return pqPrepareAsyncResult(conn);
		}

		/* Parse it. */
		parseInput(conn);
	}

	/* Return the appropriate thing. */
	switch (conn-&amp;gt;asyncStatus)
	{
		case PGASYNC_IDLE:
			res = NULL;			/* query is complete */
			break;
		case PGASYNC_READY:
			res = pqPrepareAsyncResult(conn);
			/* Set the state back to BUSY, allowing parsing to proceed. */
			conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
			break;
		case PGASYNC_COPY_IN:
			res = getCopyResult(conn, PGRES_COPY_IN);
			break;
		case PGASYNC_COPY_OUT:
			res = getCopyResult(conn, PGRES_COPY_OUT);
			break;
		case PGASYNC_COPY_BOTH:
			res = getCopyResult(conn, PGRES_COPY_BOTH);
			break;
		default:
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;unexpected asyncStatus: %d\n&quot;),
							  (int) conn-&amp;gt;asyncStatus);
			res = PQmakeEmptyPGresult(conn, PGRES_FATAL_ERROR);
			break;
	}

	if (res)
	{
		int			i;

		for (i = 0; i &amp;lt; res-&amp;gt;nEvents; i++)
		{
			PGEventResultCreate evt;

			evt.conn = conn;
			evt.result = res;
			if (!res-&amp;gt;events[i].proc(PGEVT_RESULTCREATE, &amp;amp;evt,
									 res-&amp;gt;events[i].passThrough))
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
								  libpq_gettext(&quot;PGEventProc \&quot;%s\&quot; failed during PGEVT_RESULTCREATE event\n&quot;),
								  res-&amp;gt;events[i].name);
				pqSetResultError(res, conn-&amp;gt;errorMessage.data);
				res-&amp;gt;resultStatus = PGRES_FATAL_ERROR;
				break;
			}
			res-&amp;gt;events[i].resultInitialized = TRUE;
		}
	}

	return res;
}

/*
 * getCopyResult
 *	  Helper for PQgetResult: generate result for COPY-in-progress cases
 */
static PGresult *
getCopyResult(PGconn *conn, ExecStatusType copytype)
{
	/*
	 * If the server connection has been lost, don't pretend everything is
	 * hunky-dory; instead return a PGRES_FATAL_ERROR result, and reset the
	 * asyncStatus to idle (corresponding to what we'd do if we'd detected I/O
	 * error in the earlier steps in PQgetResult).  The text returned in the
	 * result is whatever is in conn-&amp;gt;errorMessage; we hope that was filled
	 * with something relevant when the lost connection was detected.
	 */
	if (conn-&amp;gt;status != CONNECTION_OK)
	{
		pqSaveErrorResult(conn);
		conn-&amp;gt;asyncStatus = PGASYNC_IDLE;
		return pqPrepareAsyncResult(conn);
	}

	/* If we have an async result for the COPY, return that */
	if (conn-&amp;gt;result &amp;amp;&amp;amp; conn-&amp;gt;result-&amp;gt;resultStatus == copytype)
		return pqPrepareAsyncResult(conn);

	/* Otherwise, invent a suitable PGresult */
	return PQmakeEmptyPGresult(conn, copytype);
}


/*
 * PQexec
 *	  send a query to the backend and package up the result in a PGresult
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQexec(PGconn *conn, const char *query)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQuery(conn, query))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecParams
 *		Like PQexec, but use protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecParams(PGconn *conn,
			 const char *command,
			 int nParams,
			 const Oid *paramTypes,
			 const char *const * paramValues,
			 const int *paramLengths,
			 const int *paramFormats,
			 int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryParams(conn, command,
						   nParams, paramTypes, paramValues, paramLengths,
						   paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQprepare
 *	  Creates a prepared statement by issuing a v3.0 parse message.
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQprepare(PGconn *conn,
		  const char *stmtName, const char *query,
		  int nParams, const Oid *paramTypes)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendPrepare(conn, stmtName, query, nParams, paramTypes))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQexecPrepared
 *		Like PQexec, but execute a previously prepared statement,
 *		using protocol 3.0 so we can pass parameters
 */
PGresult *
PQexecPrepared(PGconn *conn,
			   const char *stmtName,
			   int nParams,
			   const char *const * paramValues,
			   const int *paramLengths,
			   const int *paramFormats,
			   int resultFormat)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendQueryPrepared(conn, stmtName,
							 nParams, paramValues, paramLengths,
							 paramFormats, resultFormat))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * Common code for PQexec and sibling routines: prepare to send command
 */
static bool
PQexecStart(PGconn *conn)
{
	PGresult   *result;

	if (!conn)
		return false;

	/*
	 * Silently discard any prior query result that application didn't eat.
	 * This is probably poor design, but it's here for backward compatibility.
	 */
	while ((result = PQgetResult(conn)) != NULL)
	{
		ExecStatusType resultStatus = result-&amp;gt;resultStatus;

		PQclear(result);		/* only need its status */
		if (resultStatus == PGRES_COPY_IN)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/* In protocol 3, we can get out of a COPY IN state */
				if (PQputCopyEnd(conn,
						 libpq_gettext(&quot;COPY terminated by new PQexec&quot;)) &amp;lt; 0)
					return false;
				/* keep waiting to swallow the copy's failure message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				  libpq_gettext(&quot;COPY IN state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_OUT)
		{
			if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
			{
				/*
				 * In protocol 3, we can get out of a COPY OUT state: we just
				 * switch back to BUSY and allow the remaining COPY data to be
				 * dropped on the floor.
				 */
				conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
				/* keep waiting to swallow the copy's completion message */
			}
			else
			{
				/* In older protocols we have to punt */
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
				 libpq_gettext(&quot;COPY OUT state must be terminated first\n&quot;));
				return false;
			}
		}
		else if (resultStatus == PGRES_COPY_BOTH)
		{
			/* We don't allow PQexec during COPY BOTH */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
					 libpq_gettext(&quot;PQexec not allowed during COPY BOTH\n&quot;));
			return false;
		}
		/* check for loss of connection, too */
		if (conn-&amp;gt;status == CONNECTION_BAD)
			return false;
	}

	/* OK to send a command */
	return true;
}

/*
 * Common code for PQexec and sibling routines: wait for command result
 */
static PGresult *
PQexecFinish(PGconn *conn)
{
	PGresult   *result;
	PGresult   *lastResult;

	/*
	 * For backwards compatibility, return the last result if there are more
	 * than one --- but merge error messages if we get more than one error
	 * result.
	 *
	 * We have to stop if we see copy in/out/both, however. We will resume
	 * parsing after application performs the data transfer.
	 *
	 * Also stop if the connection is lost (else we'll loop infinitely).
	 */
	lastResult = NULL;
	while ((result = PQgetResult(conn)) != NULL)
	{
		if (lastResult)
		{
			if (lastResult-&amp;gt;resultStatus == PGRES_FATAL_ERROR &amp;amp;&amp;amp;
				result-&amp;gt;resultStatus == PGRES_FATAL_ERROR)
			{
				pqCatenateResultError(lastResult, result-&amp;gt;errMsg);
				PQclear(result);
				result = lastResult;

				/*
				 * Make sure PQerrorMessage agrees with concatenated result
				 */
				resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);
				appendPQExpBufferStr(&amp;amp;conn-&amp;gt;errorMessage, result-&amp;gt;errMsg);
			}
			else
				PQclear(lastResult);
		}
		lastResult = result;
		if (result-&amp;gt;resultStatus == PGRES_COPY_IN ||
			result-&amp;gt;resultStatus == PGRES_COPY_OUT ||
			result-&amp;gt;resultStatus == PGRES_COPY_BOTH ||
			conn-&amp;gt;status == CONNECTION_BAD)
			break;
	}

	return lastResult;
}

/*
 * PQdescribePrepared
 *	  Obtain information about a previously prepared statement
 *
 * If the query was not even sent, return NULL; conn-&amp;gt;errorMessage is set to
 * a relevant message.
 * If the query was sent, a new PGresult is returned (which could indicate
 * either success or failure).  On success, the PGresult contains status
 * PGRES_COMMAND_OK, and its parameter and column-heading fields describe
 * the statement's inputs and outputs respectively.
 * The user is responsible for freeing the PGresult via PQclear()
 * when done with it.
 */
PGresult *
PQdescribePrepared(PGconn *conn, const char *stmt)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'S', stmt))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQdescribePortal
 *	  Obtain information about a previously created portal
 *
 * This is much like PQdescribePrepared, except that no parameter info is
 * returned.  Note that at the moment, libpq doesn't really expose portals
 * to the client; but this can be used with a portal created by a SQL
 * DECLARE CURSOR command.
 */
PGresult *
PQdescribePortal(PGconn *conn, const char *portal)
{
	if (!PQexecStart(conn))
		return NULL;
	if (!PQsendDescribe(conn, 'P', portal))
		return NULL;
	return PQexecFinish(conn);
}

/*
 * PQsendDescribePrepared
 *	 Submit a Describe Statement command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePrepared(PGconn *conn, const char *stmt)
{
	return PQsendDescribe(conn, 'S', stmt);
}

/*
 * PQsendDescribePortal
 *	 Submit a Describe Portal command, but don't wait for it to finish
 *
 * Returns: 1 if successfully submitted
 *			0 if error (conn-&amp;gt;errorMessage is set)
 */
int
PQsendDescribePortal(PGconn *conn, const char *portal)
{
	return PQsendDescribe(conn, 'P', portal);
}

/*
 * PQsendDescribe
 *	 Common code to send a Describe command
 *
 * Available options for desc_type are
 *	 'S' to describe a prepared statement; or
 *	 'P' to describe a portal.
 * Returns 1 on success and 0 on failure.
 */
static int
PQsendDescribe(PGconn *conn, char desc_type, const char *desc_target)
{
	/* Treat null desc_target as empty string */
	if (!desc_target)
		desc_target = &quot;&quot;;

	if (!PQsendQueryStart(conn))
		return 0;

	/* This isn't gonna work on a 2.0 server */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;lt; 3)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
		 libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
		return 0;
	}

	/* construct the Describe message */
	if (pqPutMsgStart('D', false, conn) &amp;lt; 0 ||
		pqPutc(desc_type, conn) &amp;lt; 0 ||
		pqPuts(desc_target, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* construct the Sync message */
	if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
		pqPutMsgEnd(conn) &amp;lt; 0)
		goto sendFailed;

	/* remember we are doing a Describe */
	conn-&amp;gt;queryclass = PGQUERY_DESCRIBE;

	/* reset last-query string (not relevant now) */
	if (conn-&amp;gt;last_query)
	{
		free(conn-&amp;gt;last_query);
		conn-&amp;gt;last_query = NULL;
	}

	/*
	 * Give the data a push.  In nonblock mode, don't complain if we're unable
	 * to send it all; PQgetResult() will do any additional flushing needed.
	 */
	if (pqFlush(conn) &amp;lt; 0)
		goto sendFailed;

	/* OK, it's launched! */
	conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	return 1;

sendFailed:
	pqHandleSendFailure(conn);
	return 0;
}

/*
 * PQnotifies
 *	  returns a PGnotify* structure of the latest async notification
 * that has not yet been handled
 *
 * returns NULL, if there is currently
 * no unhandled async notification from the backend
 *
 * the CALLER is responsible for FREE'ing the structure returned
 */
PGnotify *
PQnotifies(PGconn *conn)
{
	PGnotify   *event;

	if (!conn)
		return NULL;

	/* Parse any available data to see if we can extract NOTIFY messages. */
	parseInput(conn);

	event = conn-&amp;gt;notifyHead;
	if (event)
	{
		conn-&amp;gt;notifyHead = event-&amp;gt;next;
		if (!conn-&amp;gt;notifyHead)
			conn-&amp;gt;notifyTail = NULL;
		event-&amp;gt;next = NULL;		/* don't let app see the internal state */
	}
	return event;
}

/*
 * PQputCopyData - send some data to the backend during COPY IN or COPY BOTH
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyData(PGconn *conn, const char *buffer, int nbytes)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Process any NOTICE or NOTIFY messages that might be pending in the
	 * input buffer.  Since the server might generate many notices during the
	 * COPY, we want to clean those out reasonably promptly to prevent
	 * indefinite expansion of the input buffer.  (Note: the actual read of
	 * input data into the input buffer happens down inside pqSendSome, but
	 * it's not authorized to get rid of the data again.)
	 */
	parseInput(conn);

	if (nbytes &amp;gt; 0)
	{
		/*
		 * Try to flush any previously sent data in preference to growing the
		 * output buffer.  If we can't enlarge the buffer enough to hold the
		 * data, return 0 in the nonblock case, else hard error. (For
		 * simplicity, always assume 5 bytes of overhead even in protocol 2.0
		 * case.)
		 */
		if ((conn-&amp;gt;outBufSize - conn-&amp;gt;outCount - 5) &amp;lt; nbytes)
		{
			if (pqFlush(conn) &amp;lt; 0)
				return -1;
			if (pqCheckOutBufferSpace(conn-&amp;gt;outCount + 5 + (size_t) nbytes,
									  conn))
				return pqIsnonblocking(conn) ? 0 : -1;
		}
		/* Send the data (too simple to delegate to fe-protocol files) */
		if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		{
			if (pqPutMsgStart('d', false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(buffer, nbytes, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	return 1;
}

/*
 * PQputCopyEnd - send EOF indication to the backend during COPY IN
 *
 * After calling this, use PQgetResult() to check command completion status.
 *
 * Returns 1 if successful, 0 if data could not be sent (only possible
 * in nonblock mode), or -1 if an error occurs.
 */
int
PQputCopyEnd(PGconn *conn, const char *errormsg)
{
	if (!conn)
		return -1;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_IN &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -1;
	}

	/*
	 * Send the COPY END indicator.  This is simple enough that we don't
	 * bother delegating it to the fe-protocol files.
	 */
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
	{
		if (errormsg)
		{
			/* Send COPY FAIL */
			if (pqPutMsgStart('f', false, conn) &amp;lt; 0 ||
				pqPuts(errormsg, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
		else
		{
			/* Send COPY DONE */
			if (pqPutMsgStart('c', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}

		/*
		 * If we sent the COPY command in extended-query mode, we must issue a
		 * Sync as well.
		 */
		if (conn-&amp;gt;queryclass != PGQUERY_SIMPLE)
		{
			if (pqPutMsgStart('S', false, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}
	else
	{
		if (errormsg)
		{
			/* Oops, no way to do this in 2.0 */
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;function requires at least protocol version 3.0\n&quot;));
			return -1;
		}
		else
		{
			/* Send old-style end-of-data marker */
			if (pqPutMsgStart(0, false, conn) &amp;lt; 0 ||
				pqPutnchar(&quot;\\.\n&quot;, 3, conn) &amp;lt; 0 ||
				pqPutMsgEnd(conn) &amp;lt; 0)
				return -1;
		}
	}

	/* Return to active duty */
	if (conn-&amp;gt;asyncStatus == PGASYNC_COPY_BOTH)
		conn-&amp;gt;asyncStatus = PGASYNC_COPY_OUT;
	else
		conn-&amp;gt;asyncStatus = PGASYNC_BUSY;
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	/* Try to flush data */
	if (pqFlush(conn) &amp;lt; 0)
		return -1;

	return 1;
}

/*
 * PQgetCopyData - read a row of data from the backend during COPY OUT
 * or COPY BOTH
 *
 * If successful, sets *buffer to point to a malloc'd row of data, and
 * returns row length (always &amp;gt; 0) as result.
 * Returns 0 if no row available yet (only possible if async is true),
 * -1 if end of copy (consult PQgetResult), or -2 if error (consult
 * PQerrorMessage).
 */
int
PQgetCopyData(PGconn *conn, char **buffer, int async)
{
	*buffer = NULL;				/* for all failure cases */
	if (!conn)
		return -2;
	if (conn-&amp;gt;asyncStatus != PGASYNC_COPY_OUT &amp;amp;&amp;amp;
		conn-&amp;gt;asyncStatus != PGASYNC_COPY_BOTH)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;no COPY in progress\n&quot;));
		return -2;
	}
	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetCopyData3(conn, buffer, async);
	else
		return pqGetCopyData2(conn, buffer, async);
}

/*
 * PQgetline - gets a newline-terminated string from the backend.
 *
 * Chiefly here so that applications can use &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * and read the output string.  Returns a null-terminated string in s.
 *
 * XXX this routine is now deprecated, because it can't handle binary data.
 * If called during a COPY BINARY we return EOF.
 *
 * PQgetline reads up to maxlen-1 characters (like fgets(3)) but strips
 * the terminating \n (like gets(3)).
 *
 * CAUTION: the caller is responsible for detecting the end-of-copy signal
 * (a line containing just &quot;\.&quot;) when using this routine.
 *
 * RETURNS:
 *		EOF if error (eg, invalid arguments are given)
 *		0 if EOL is reached (i.e., \n has been read)
 *				(this is required for backward-compatibility -- this
 *				 routine used to always return EOF or 0, assuming that
 *				 the line ended within maxlen bytes.)
 *		1 in other cases (i.e., the buffer was filled before \n is reached)
 */
int
PQgetline(PGconn *conn, char *s, int maxlen)
{
	if (!s || maxlen &amp;lt;= 0)
		return EOF;
	*s = '\0';
	/* maxlen must be at least 3 to hold the \. terminator! */
	if (maxlen &amp;lt; 3)
		return EOF;

	if (!conn)
		return EOF;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetline3(conn, s, maxlen);
	else
		return pqGetline2(conn, s, maxlen);
}

/*
 * PQgetlineAsync - gets a COPY data row without blocking.
 *
 * This routine is for applications that want to do &quot;COPY &amp;lt;rel&amp;gt; to stdout&quot;
 * asynchronously, that is without blocking.  Having issued the COPY command
 * and gotten a PGRES_COPY_OUT response, the app should call PQconsumeInput
 * and this routine until the end-of-data signal is detected.  Unlike
 * PQgetline, this routine takes responsibility for detecting end-of-data.
 *
 * On each call, PQgetlineAsync will return data if a complete data row
 * is available in libpq's input buffer.  Otherwise, no data is returned
 * until the rest of the row arrives.
 *
 * If -1 is returned, the end-of-data signal has been recognized (and removed
 * from libpq's input buffer).  The caller *must* next call PQendcopy and
 * then return to normal processing.
 *
 * RETURNS:
 *	 -1    if the end-of-copy-data marker has been recognized
 *	 0	   if no data is available
 *	 &amp;gt;0    the number of bytes returned.
 *
 * The data returned will not extend beyond a data-row boundary.  If possible
 * a whole row will be returned at one time.  But if the buffer offered by
 * the caller is too small to hold a row sent by the backend, then a partial
 * data row will be returned.  In text mode this can be detected by testing
 * whether the last returned byte is '\n' or not.
 *
 * The returned data is *not* null-terminated.
 */

int
PQgetlineAsync(PGconn *conn, char *buffer, int bufsize)
{
	if (!conn)
		return -1;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqGetlineAsync3(conn, buffer, bufsize);
	else
		return pqGetlineAsync2(conn, buffer, bufsize);
}

/*
 * PQputline -- sends a string to the backend during COPY IN.
 * Returns 0 if OK, EOF if not.
 *
 * This is deprecated primarily because the return convention doesn't allow
 * caller to tell the difference between a hard error and a nonblock-mode
 * send failure.
 */
int
PQputline(PGconn *conn, const char *s)
{
	return PQputnbytes(conn, s, strlen(s));
}

/*
 * PQputnbytes -- like PQputline, but buffer need not be null-terminated.
 * Returns 0 if OK, EOF if not.
 */
int
PQputnbytes(PGconn *conn, const char *buffer, int nbytes)
{
	if (PQputCopyData(conn, buffer, nbytes) &amp;gt; 0)
		return 0;
	else
		return EOF;
}

/*
 * PQendcopy
 *		After completing the data transfer portion of a copy in/out,
 *		the application must call this routine to finish the command protocol.
 *
 * When using protocol 3.0 this is deprecated; it's cleaner to use PQgetResult
 * to get the transfer status.  Note however that when using 2.0 protocol,
 * recovering from a copy failure often requires a PQreset.  PQendcopy will
 * take care of that, PQgetResult won't.
 *
 * RETURNS:
 *		0 on success
 *		1 on failure
 */
int
PQendcopy(PGconn *conn)
{
	if (!conn)
		return 0;

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqEndcopy3(conn);
	else
		return pqEndcopy2(conn);
}


/* ----------------
 *		PQfn -	Send a function call to the POSTGRES backend.
 *
 *		conn			: backend connection
 *		fnid			: OID of function to be called
 *		result_buf		: pointer to result buffer
 *		result_len		: actual length of result is returned here
 *		result_is_int	: If the result is an integer, this must be 1,
 *						  otherwise this should be 0
 *		args			: pointer to an array of function arguments
 *						  (each has length, if integer, and value/pointer)
 *		nargs			: # of arguments in args array.
 *
 * RETURNS
 *		PGresult with status = PGRES_COMMAND_OK if successful.
 *			*result_len is &amp;gt; 0 if there is a return value, 0 if not.
 *		PGresult with status = PGRES_FATAL_ERROR if backend returns an error.
 *		NULL on communications failure.  conn-&amp;gt;errorMessage will be set.
 * ----------------
 */

PGresult *
PQfn(PGconn *conn,
	 int fnid,
	 int *result_buf,
	 int *result_len,
	 int result_is_int,
	 const PQArgBlock *args,
	 int nargs)
{
	*result_len = 0;

	if (!conn)
		return NULL;

	/* clear the error string */
	resetPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage);

	if (conn-&amp;gt;sock == PGINVALID_SOCKET || conn-&amp;gt;asyncStatus != PGASYNC_IDLE ||
		conn-&amp;gt;result != NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;connection in wrong state\n&quot;));
		return NULL;
	}

	if (PG_PROTOCOL_MAJOR(conn-&amp;gt;pversion) &amp;gt;= 3)
		return pqFunctionCall3(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
	else
		return pqFunctionCall2(conn, fnid,
							   result_buf, result_len,
							   result_is_int,
							   args, nargs);
}


/* ====== accessor funcs for PGresult ======== */

ExecStatusType
PQresultStatus(const PGresult *res)
{
	if (!res)
		return PGRES_FATAL_ERROR;
	return res-&amp;gt;resultStatus;
}

char *
PQresStatus(ExecStatusType status)
{
	if ((unsigned int) status &amp;gt;= sizeof pgresStatus / sizeof pgresStatus[0])
		return libpq_gettext(&quot;invalid ExecStatusType code&quot;);
	return pgresStatus[status];
}

char *
PQresultErrorMessage(const PGresult *res)
{
	if (!res || !res-&amp;gt;errMsg)
		return &quot;&quot;;
	return res-&amp;gt;errMsg;
}

char *
PQresultVerboseErrorMessage(const PGresult *res,
							PGVerbosity verbosity,
							PGContextVisibility show_context)
{
	PQExpBufferData workBuf;

	/*
	 * Because the caller is expected to free the result string, we must
	 * strdup any constant result.  We use plain strdup and document that
	 * callers should expect NULL if out-of-memory.
	 */
	if (!res ||
		(res-&amp;gt;resultStatus != PGRES_FATAL_ERROR &amp;amp;&amp;amp;
		 res-&amp;gt;resultStatus != PGRES_NONFATAL_ERROR))
		return strdup(libpq_gettext(&quot;PGresult is not an error result\n&quot;));

	initPQExpBuffer(&amp;amp;workBuf);

	/*
	 * Currently, we pass this off to fe-protocol3.c in all cases; it will
	 * behave reasonably sanely with an error reported by fe-protocol2.c as
	 * well.  If necessary, we could record the protocol version in PGresults
	 * so as to be able to invoke a version-specific message formatter, but
	 * for now there's no need.
	 */
	pqBuildErrorMessage3(&amp;amp;workBuf, res, verbosity, show_context);

	/* If insufficient memory to format the message, fail cleanly */
	if (PQExpBufferDataBroken(workBuf))
	{
		termPQExpBuffer(&amp;amp;workBuf);
		return strdup(libpq_gettext(&quot;out of memory\n&quot;));
	}

	return workBuf.data;
}

char *
PQresultErrorField(const PGresult *res, int fieldcode)
{
	PGMessageField *pfield;

	if (!res)
		return NULL;
	for (pfield = res-&amp;gt;errFields; pfield != NULL; pfield = pfield-&amp;gt;next)
	{
		if (pfield-&amp;gt;code == fieldcode)
			return pfield-&amp;gt;contents;
	}
	return NULL;
}

int
PQntuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;ntups;
}

int
PQnfields(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numAttributes;
}

int
PQbinaryTuples(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;binary;
}

/*
 * Helper routines to range-check field numbers and tuple numbers.
 * Return TRUE if OK, FALSE if not
 */

static int
check_field_number(const PGresult *res, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_tuple_field_number(const PGresult *res,
						 int tup_num, int field_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (tup_num &amp;lt; 0 || tup_num &amp;gt;= res-&amp;gt;ntups)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;row number %d is out of range 0..%d&quot;,
						 tup_num, res-&amp;gt;ntups - 1);
		return FALSE;
	}
	if (field_num &amp;lt; 0 || field_num &amp;gt;= res-&amp;gt;numAttributes)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;column number %d is out of range 0..%d&quot;,
						 field_num, res-&amp;gt;numAttributes - 1);
		return FALSE;
	}
	return TRUE;
}

static int
check_param_number(const PGresult *res, int param_num)
{
	if (!res)
		return FALSE;			/* no way to display error message... */
	if (param_num &amp;lt; 0 || param_num &amp;gt;= res-&amp;gt;numParameters)
	{
		pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
						 &quot;parameter number %d is out of range 0..%d&quot;,
						 param_num, res-&amp;gt;numParameters - 1);
		return FALSE;
	}

	return TRUE;
}

/*
 * returns NULL if the field_num is invalid
 */
char *
PQfname(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return NULL;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].name;
	else
		return NULL;
}

/*
 * PQfnumber: find column number given column name
 *
 * The column name is parsed as if it were in a SQL statement, including
 * case-folding and double-quote processing.  But note a possible gotcha:
 * downcasing in the frontend might follow different locale rules than
 * downcasing in the backend...
 *
 * Returns -1 if no match.  In the present backend it is also possible
 * to have multiple matches, in which case the first one is found.
 */
int
PQfnumber(const PGresult *res, const char *field_name)
{
	char	   *field_case;
	bool		in_quotes;
	bool		all_lower = true;
	const char *iptr;
	char	   *optr;
	int			i;

	if (!res)
		return -1;

	/*
	 * Note: it is correct to reject a zero-length input string; the proper
	 * input to match a zero-length field name would be &quot;&quot;.
	 */
	if (field_name == NULL ||
		field_name[0] == '\0' ||
		res-&amp;gt;attDescs == NULL)
		return -1;

	/*
	 * Check if we can avoid the strdup() and related work because the
	 * passed-in string wouldn't be changed before we do the check anyway.
	 */
	for (iptr = field_name; *iptr; iptr++)
	{
		char		c = *iptr;

		if (c == '&quot;' || c != pg_tolower((unsigned char) c))
		{
			all_lower = false;
			break;
		}
	}

	if (all_lower)
		for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
			if (strcmp(field_name, res-&amp;gt;attDescs[i].name) == 0)
				return i;

	/* Fall through to the normal check if that didn't work out. */

	/*
	 * Note: this code will not reject partially quoted strings, eg
	 * foo&quot;BAR&quot;foo will become fooBARfoo when it probably ought to be an error
	 * condition.
	 */
	field_case = strdup(field_name);
	if (field_case == NULL)
		return -1;				/* grotty */

	in_quotes = false;
	optr = field_case;
	for (iptr = field_case; *iptr; iptr++)
	{
		char		c = *iptr;

		if (in_quotes)
		{
			if (c == '&quot;')
			{
				if (iptr[1] == '&quot;')
				{
					/* doubled quotes become a single quote */
					*optr++ = '&quot;';
					iptr++;
				}
				else
					in_quotes = false;
			}
			else
				*optr++ = c;
		}
		else if (c == '&quot;')
			in_quotes = true;
		else
		{
			c = pg_tolower((unsigned char) c);
			*optr++ = c;
		}
	}
	*optr = '\0';

	for (i = 0; i &amp;lt; res-&amp;gt;numAttributes; i++)
	{
		if (strcmp(field_case, res-&amp;gt;attDescs[i].name) == 0)
		{
			free(field_case);
			return i;
		}
	}
	free(field_case);
	return -1;
}

Oid
PQftable(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].tableid;
	else
		return InvalidOid;
}

int
PQftablecol(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].columnid;
	else
		return 0;
}

int
PQfformat(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].format;
	else
		return 0;
}

Oid
PQftype(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return InvalidOid;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typid;
	else
		return InvalidOid;
}

int
PQfsize(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].typlen;
	else
		return 0;
}

int
PQfmod(const PGresult *res, int field_num)
{
	if (!check_field_number(res, field_num))
		return 0;
	if (res-&amp;gt;attDescs)
		return res-&amp;gt;attDescs[field_num].atttypmod;
	else
		return 0;
}

char *
PQcmdStatus(PGresult *res)
{
	if (!res)
		return NULL;
	return res-&amp;gt;cmdStatus;
}

/*
 * PQoidStatus -
 *	if the last command was an INSERT, return the oid string
 *	if not, return &quot;&quot;
 */
char *
PQoidStatus(const PGresult *res)
{
	/*
	 * This must be enough to hold the result. Don't laugh, this is better
	 * than what this function used to do.
	 */
	static char buf[24];

	size_t		len;

	if (!res || strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0)
		return &quot;&quot;;

	len = strspn(res-&amp;gt;cmdStatus + 7, &quot;0123456789&quot;);
	if (len &amp;gt; sizeof(buf) - 1)
		len = sizeof(buf) - 1;
	memcpy(buf, res-&amp;gt;cmdStatus + 7, len);
	buf[len] = '\0';

	return buf;
}

/*
 * PQoidValue -
 *	a perhaps preferable form of the above which just returns
 *	an Oid type
 */
Oid
PQoidValue(const PGresult *res)
{
	char	   *endptr = NULL;
	unsigned long result;

	if (!res ||
		strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) != 0 ||
		res-&amp;gt;cmdStatus[7] &amp;lt; '0' ||
		res-&amp;gt;cmdStatus[7] &amp;gt; '9')
		return InvalidOid;

	result = strtoul(res-&amp;gt;cmdStatus + 7, &amp;amp;endptr, 10);

	if (!endptr || (*endptr != ' ' &amp;amp;&amp;amp; *endptr != '\0'))
		return InvalidOid;
	else
		return (Oid) result;
}


/*
 * PQcmdTuples -
 *	If the last command was INSERT/UPDATE/DELETE/MOVE/FETCH/COPY, return
 *	a string containing the number of inserted/affected tuples. If not,
 *	return &quot;&quot;.
 *
 *	XXX: this should probably return an int
 */
char *
PQcmdTuples(PGresult *res)
{
	char	   *p,
			   *c;

	if (!res)
		return &quot;&quot;;

	if (strncmp(res-&amp;gt;cmdStatus, &quot;INSERT &quot;, 7) == 0)
	{
		p = res-&amp;gt;cmdStatus + 7;
		/* INSERT: skip oid and space */
		while (*p &amp;amp;&amp;amp; *p != ' ')
			p++;
		if (*p == 0)
			goto interpret_error;		/* no space? */
		p++;
	}
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;SELECT &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;DELETE &quot;, 7) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;UPDATE &quot;, 7) == 0)
		p = res-&amp;gt;cmdStatus + 7;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;FETCH &quot;, 6) == 0)
		p = res-&amp;gt;cmdStatus + 6;
	else if (strncmp(res-&amp;gt;cmdStatus, &quot;MOVE &quot;, 5) == 0 ||
			 strncmp(res-&amp;gt;cmdStatus, &quot;COPY &quot;, 5) == 0)
		p = res-&amp;gt;cmdStatus + 5;
	else
		return &quot;&quot;;

	/* check that we have an integer (at least one digit, nothing else) */
	for (c = p; *c; c++)
	{
		if (!isdigit((unsigned char) *c))
			goto interpret_error;
	}
	if (c == p)
		goto interpret_error;

	return p;

interpret_error:
	pqInternalNotice(&amp;amp;res-&amp;gt;noticeHooks,
					 &quot;could not interpret result from server: %s&quot;,
					 res-&amp;gt;cmdStatus);
	return &quot;&quot;;
}

/*
 * PQgetvalue:
 *	return the value of field 'field_num' of row 'tup_num'
 */
char *
PQgetvalue(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return NULL;
	return res-&amp;gt;tuples[tup_num][field_num].value;
}

/* PQgetlength:
 *	returns the actual length of a field value in bytes.
 */
int
PQgetlength(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 0;
	if (res-&amp;gt;tuples[tup_num][field_num].len != NULL_LEN)
		return res-&amp;gt;tuples[tup_num][field_num].len;
	else
		return 0;
}

/* PQgetisnull:
 *	returns the null status of a field value.
 */
int
PQgetisnull(const PGresult *res, int tup_num, int field_num)
{
	if (!check_tuple_field_number(res, tup_num, field_num))
		return 1;				/* pretend it is null */
	if (res-&amp;gt;tuples[tup_num][field_num].len == NULL_LEN)
		return 1;
	else
		return 0;
}

/* PQnparams:
 *	returns the number of input parameters of a prepared statement.
 */
int
PQnparams(const PGresult *res)
{
	if (!res)
		return 0;
	return res-&amp;gt;numParameters;
}

/* PQparamtype:
 *	returns type Oid of the specified statement parameter.
 */
Oid
PQparamtype(const PGresult *res, int param_num)
{
	if (!check_param_number(res, param_num))
		return InvalidOid;
	if (res-&amp;gt;paramDescs)
		return res-&amp;gt;paramDescs[param_num].typid;
	else
		return InvalidOid;
}


/* PQsetnonblocking:
 *	sets the PGconn's database connection non-blocking if the arg is TRUE
 *	or makes it blocking if the arg is FALSE, this will not protect
 *	you from PQexec(), you'll only be safe when using the non-blocking API.
 *	Needs to be called only on a connected database connection.
 */
int
PQsetnonblocking(PGconn *conn, int arg)
{
	bool		barg;

	if (!conn || conn-&amp;gt;status == CONNECTION_BAD)
		return -1;

	barg = (arg ? TRUE : FALSE);

	/* early out if the socket is already in the state requested */
	if (barg == conn-&amp;gt;nonblocking)
		return 0;

	/*
	 * to guarantee constancy for flushing/query/result-polling behavior we
	 * need to flush the send queue at this point in order to guarantee proper
	 * behavior. this is ok because either they are making a transition _from_
	 * or _to_ blocking mode, either way we can block them.
	 */
	/* if we are going from blocking to non-blocking flush here */
	if (pqFlush(conn))
		return -1;

	conn-&amp;gt;nonblocking = barg;

	return 0;
}

/*
 * return the blocking status of the database connection
 *		TRUE == nonblocking, FALSE == blocking
 */
int
PQisnonblocking(const PGconn *conn)
{
	return pqIsnonblocking(conn);
}

/* libpq is thread-safe? */
int
PQisthreadsafe(void)
{
#ifdef ENABLE_THREAD_SAFETY
	return true;
#else
	return false;
#endif
}


/* try to force data out, really only useful for non-blocking users */
int
PQflush(PGconn *conn)
{
	return pqFlush(conn);
}


/*
 *		PQfreemem - safely frees memory allocated
 *
 * Needed mostly by Win32, unless multithreaded DLL (/MD in VC6)
 * Used for freeing memory from PQescapeByte()a/PQunescapeBytea()
 */
void
PQfreemem(void *ptr)
{
	free(ptr);
}

/*
 * PQfreeNotify - free's the memory associated with a PGnotify
 *
 * This function is here only for binary backward compatibility.
 * New code should use PQfreemem().  A macro will automatically map
 * calls to PQfreemem.  It should be removed in the future.  bjm 2003-03-24
 */

#undef PQfreeNotify
void		PQfreeNotify(PGnotify *notify);

void
PQfreeNotify(PGnotify *notify)
{
	PQfreemem(notify);
}


/*
 * Escaping arbitrary strings to get valid SQL literal strings.
 *
 * Replaces &quot;'&quot; with &quot;''&quot;, and if not std_strings, replaces &quot;\&quot; with &quot;\\&quot;.
 *
 * length is the length of the source string.  (Note: if a terminating NUL
 * is encountered sooner, PQescapeString stops short of &quot;length&quot;; the behavior
 * is thus rather like strncpy.)
 *
 * For safety the buffer at &quot;to&quot; must be at least 2*length + 1 bytes long.
 * A terminating NUL character is added to the output string, whether the
 * input is NUL-terminated or not.
 *
 * Returns the actual length of the output (not counting the terminating NUL).
 */
static size_t
PQescapeStringInternal(PGconn *conn,
					   char *to, const char *from, size_t length,
					   int *error,
					   int encoding, bool std_strings)
{
	const char *source = from;
	char	   *target = to;
	size_t		remaining = length;

	if (error)
		*error = 0;

	while (remaining &amp;gt; 0 &amp;amp;&amp;amp; *source != '\0')
	{
		char		c = *source;
		int			len;
		int			i;

		/* Fast path for plain ASCII */
		if (!IS_HIGHBIT_SET(c))
		{
			/* Apply quoting if needed */
			if (SQL_STR_DOUBLE(c, !std_strings))
				*target++ = c;
			/* Copy the character */
			*target++ = c;
			source++;
			remaining--;
			continue;
		}

		/* Slow path for possible multibyte characters */
		len = pg_encoding_mblen(encoding, source);

		/* Copy the character */
		for (i = 0; i &amp;lt; len; i++)
		{
			if (remaining == 0 || *source == '\0')
				break;
			*target++ = *source++;
			remaining--;
		}

		/*
		 * If we hit premature end of string (ie, incomplete multibyte
		 * character), try to pad out to the correct length with spaces. We
		 * may not be able to pad completely, but we will always be able to
		 * insert at least one pad space (since we'd not have quoted a
		 * multibyte character).  This should be enough to make a string that
		 * the server will error out on.
		 */
		if (i &amp;lt; len)
		{
			if (error)
				*error = 1;
			if (conn)
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
			for (; i &amp;lt; len; i++)
			{
				if (((size_t) (target - to)) / 2 &amp;gt;= length)
					break;
				*target++ = ' ';
			}
			break;
		}
	}

	/* Write the terminating NUL character. */
	*target = '\0';

	return target - to;
}

size_t
PQescapeStringConn(PGconn *conn,
				   char *to, const char *from, size_t length,
				   int *error)
{
	if (!conn)
	{
		/* force empty-string result */
		*to = '\0';
		if (error)
			*error = 1;
		return 0;
	}
	return PQescapeStringInternal(conn, to, from, length, error,
								  conn-&amp;gt;client_encoding,
								  conn-&amp;gt;std_strings);
}

size_t
PQescapeString(char *to, const char *from, size_t length)
{
	return PQescapeStringInternal(NULL, to, from, length, NULL,
								  static_client_encoding,
								  static_std_strings);
}


/*
 * Escape arbitrary strings.  If as_ident is true, we escape the result
 * as an identifier; if false, as a literal.  The result is returned in
 * a newly allocated buffer.  If we fail due to an encoding violation or out
 * of memory condition, we return NULL, storing an error message into conn.
 */
static char *
PQescapeInternal(PGconn *conn, const char *str, size_t len, bool as_ident)
{
	const char *s;
	char	   *result;
	char	   *rp;
	int			num_quotes = 0; /* single or double, depending on as_ident */
	int			num_backslashes = 0;
	int			input_len;
	int			result_size;
	char		quote_char = as_ident ? '&quot;' : '\'';

	/* We must have a connection, else fail immediately. */
	if (!conn)
		return NULL;

	/* Scan the string for characters that must be escaped. */
	for (s = str; (s - str) &amp;lt; len &amp;amp;&amp;amp; *s != '\0'; ++s)
	{
		if (*s == quote_char)
			++num_quotes;
		else if (*s == '\\')
			++num_backslashes;
		else if (IS_HIGHBIT_SET(*s))
		{
			int			charlen;

			/* Slow path for possible multibyte characters */
			charlen = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

			/* Multibyte character overruns allowable length. */
			if ((s - str) + charlen &amp;gt; len || memchr(s, 0, charlen) != NULL)
			{
				printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;incomplete multibyte character\n&quot;));
				return NULL;
			}

			/* Adjust s, bearing in mind that for loop will increment it. */
			s += charlen - 1;
		}
	}

	/* Allocate output buffer. */
	input_len = s - str;
	result_size = input_len + num_quotes + 3;	/* two quotes, plus a NUL */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
		result_size += num_backslashes + 2;
	result = rp = (char *) malloc(result_size);
	if (rp == NULL)
	{
		printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
						  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	/*
	 * If we are escaping a literal that contains backslashes, we use the
	 * escape string syntax so that the result is correct under either value
	 * of standard_conforming_strings.  We also emit a leading space in this
	 * case, to guard against the possibility that the result might be
	 * interpolated immediately following an identifier.
	 */
	if (!as_ident &amp;amp;&amp;amp; num_backslashes &amp;gt; 0)
	{
		*rp++ = ' ';
		*rp++ = 'E';
	}

	/* Opening quote. */
	*rp++ = quote_char;

	/*
	 * Use fast path if possible.
	 *
	 * We've already verified that the input string is well-formed in the
	 * current encoding.  If it contains no quotes and, in the case of
	 * literal-escaping, no backslashes, then we can just copy it directly to
	 * the output buffer, adding the necessary quotes.
	 *
	 * If not, we must rescan the input and process each character
	 * individually.
	 */
	if (num_quotes == 0 &amp;amp;&amp;amp; (num_backslashes == 0 || as_ident))
	{
		memcpy(rp, str, input_len);
		rp += input_len;
	}
	else
	{
		for (s = str; s - str &amp;lt; input_len; ++s)
		{
			if (*s == quote_char || (!as_ident &amp;amp;&amp;amp; *s == '\\'))
			{
				*rp++ = *s;
				*rp++ = *s;
			}
			else if (!IS_HIGHBIT_SET(*s))
				*rp++ = *s;
			else
			{
				int			i = pg_encoding_mblen(conn-&amp;gt;client_encoding, s);

				while (1)
				{
					*rp++ = *s;
					if (--i == 0)
						break;
					++s;		/* for loop will provide the final increment */
				}
			}
		}
	}

	/* Closing quote and terminating NUL. */
	*rp++ = quote_char;
	*rp = '\0';

	return result;
}

char *
PQescapeLiteral(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, false);
}

char *
PQescapeIdentifier(PGconn *conn, const char *str, size_t len)
{
	return PQescapeInternal(conn, str, len, true);
}

/* HEX encoding support for bytea */
static const char hextbl[] = &quot;0123456789abcdef&quot;;

static const int8 hexlookup[128] = {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static inline char
get_hex(char c)
{
	int			res = -1;

	if (c &amp;gt; 0 &amp;amp;&amp;amp; c &amp;lt; 127)
		res = hexlookup[(unsigned char) c];

	return (char) res;
}


/*
 *		PQescapeBytea	- converts from binary string to the
 *		minimal encoding necessary to include the string in an SQL
 *		INSERT statement with a bytea type column as the target.
 *
 *		We can use either hex or escape (traditional) encoding.
 *		In escape mode, the following transformations are applied:
 *		'\0' == ASCII  0 == \000
 *		'\'' == ASCII 39 == ''
 *		'\\' == ASCII 92 == \\
 *		anything &amp;lt; 0x20, or &amp;gt; 0x7e ---&amp;gt; \ooo
 *										(where ooo is an octal expression)
 *
 *		If not std_strings, all backslashes sent to the output are doubled.
 */
static unsigned char *
PQescapeByteaInternal(PGconn *conn,
					  const unsigned char *from, size_t from_length,
					  size_t *to_length, bool std_strings, bool use_hex)
{
	const unsigned char *vp;
	unsigned char *rp;
	unsigned char *result;
	size_t		i;
	size_t		len;
	size_t		bslash_len = (std_strings ? 1 : 2);

	/*
	 * empty string has 1 char ('\0')
	 */
	len = 1;

	if (use_hex)
	{
		len += bslash_len + 1 + 2 * from_length;
	}
	else
	{
		vp = from;
		for (i = from_length; i &amp;gt; 0; i--, vp++)
		{
			if (*vp &amp;lt; 0x20 || *vp &amp;gt; 0x7e)
				len += bslash_len + 3;
			else if (*vp == '\'')
				len += 2;
			else if (*vp == '\\')
				len += bslash_len + bslash_len;
			else
				len++;
		}
	}

	*to_length = len;
	rp = result = (unsigned char *) malloc(len);
	if (rp == NULL)
	{
		if (conn)
			printfPQExpBuffer(&amp;amp;conn-&amp;gt;errorMessage,
							  libpq_gettext(&quot;out of memory\n&quot;));
		return NULL;
	}

	if (use_hex)
	{
		if (!std_strings)
			*rp++ = '\\';
		*rp++ = '\\';
		*rp++ = 'x';
	}

	vp = from;
	for (i = from_length; i &amp;gt; 0; i--, vp++)
	{
		unsigned char c = *vp;

		if (use_hex)
		{
			*rp++ = hextbl[(c &amp;gt;&amp;gt; 4) &amp;amp; 0xF];
			*rp++ = hextbl[c &amp;amp; 0xF];
		}
		else if (c &amp;lt; 0x20 || c &amp;gt; 0x7e)
		{
			if (!std_strings)
				*rp++ = '\\';
			*rp++ = '\\';
			*rp++ = (c &amp;gt;&amp;gt; 6) + '0';
			*rp++ = ((c &amp;gt;&amp;gt; 3) &amp;amp; 07) + '0';
			*rp++ = (c &amp;amp; 07) + '0';
		}
		else if (c == '\'')
		{
			*rp++ = '\'';
			*rp++ = '\'';
		}
		else if (c == '\\')
		{
			if (!std_strings)
			{
				*rp++ = '\\';
				*rp++ = '\\';
			}
			*rp++ = '\\';
			*rp++ = '\\';
		}
		else
			*rp++ = c;
	}
	*rp = '\0';

	return result;
}

unsigned char *
PQescapeByteaConn(PGconn *conn,
				  const unsigned char *from, size_t from_length,
				  size_t *to_length)
{
	if (!conn)
		return NULL;
	return PQescapeByteaInternal(conn, from, from_length, to_length,
								 conn-&amp;gt;std_strings,
								 (conn-&amp;gt;sversion &amp;gt;= 90000));
}

unsigned char *
PQescapeBytea(const unsigned char *from, size_t from_length, size_t *to_length)
{
	return PQescapeByteaInternal(NULL, from, from_length, to_length,
								 static_std_strings,
								 false /* can't use hex */ );
}


#define ISFIRSTOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '3')
#define ISOCTDIGIT(CH) ((CH) &amp;gt;= '0' &amp;amp;&amp;amp; (CH) &amp;lt;= '7')
#define OCTVAL(CH) ((CH) - '0')

/*
 *		PQunescapeBytea - converts the null terminated string representation
 *		of a bytea, strtext, into binary, filling a buffer. It returns a
 *		pointer to the buffer (or NULL on error), and the size of the
 *		buffer in retbuflen. The pointer may subsequently be used as an
 *		argument to the function PQfreemem.
 *
 *		The following transformations are made:
 *		\\	 == ASCII 92 == \
 *		\ooo == a byte whose value = ooo (ooo is an octal number)
 *		\x	 == x (x is any character not matched by the above transformations)
 */
unsigned char *
PQunescapeBytea(const unsigned char *strtext, size_t *retbuflen)
{
	size_t		strtextlen,
				buflen;
	unsigned char *buffer,
			   *tmpbuf;
	size_t		i,
				j;

	if (strtext == NULL)
		return NULL;

	strtextlen = strlen((const char *) strtext);

	if (strtext[0] == '\\' &amp;amp;&amp;amp; strtext[1] == 'x')
	{
		const unsigned char *s;
		unsigned char *p;

		buflen = (strtextlen - 2) / 2;
		/* Avoid unportable malloc(0) */
		buffer = (unsigned char *) malloc(buflen &amp;gt; 0 ? buflen : 1);
		if (buffer == NULL)
			return NULL;

		s = strtext + 2;
		p = buffer;
		while (*s)
		{
			char		v1,
						v2;

			/*
			 * Bad input is silently ignored.  Note that this includes
			 * whitespace between hex pairs, which is allowed by byteain.
			 */
			v1 = get_hex(*s++);
			if (!*s || v1 == (char) -1)
				continue;
			v2 = get_hex(*s++);
			if (v2 != (char) -1)
				*p++ = (v1 &amp;lt;&amp;lt; 4) | v2;
		}

		buflen = p - buffer;
	}
	else
	{
		/*
		 * Length of input is max length of output, but add one to avoid
		 * unportable malloc(0) if input is zero-length.
		 */
		buffer = (unsigned char *) malloc(strtextlen + 1);
		if (buffer == NULL)
			return NULL;

		for (i = j = 0; i &amp;lt; strtextlen;)
		{
			switch (strtext[i])
			{
				case '\\':
					i++;
					if (strtext[i] == '\\')
						buffer[j++] = strtext[i++];
					else
					{
						if ((ISFIRSTOCTDIGIT(strtext[i])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 1])) &amp;amp;&amp;amp;
							(ISOCTDIGIT(strtext[i + 2])))
						{
							int			byte;

							byte = OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							byte = (byte &amp;lt;&amp;lt; 3) + OCTVAL(strtext[i++]);
							buffer[j++] = byte;
						}
					}

					/*
					 * Note: if we see '\' followed by something that isn't a
					 * recognized escape sequence, we loop around having done
					 * nothing except advance i.  Therefore the something will
					 * be emitted as ordinary data on the next cycle. Corner
					 * case: '\' at end of string will just be discarded.
					 */
					break;

				default:
					buffer[j++] = strtext[i++];
					break;
			}
		}
		buflen = j;				/* buflen is the length of the dequoted data */
	}

	/* Shrink the buffer to be no larger than necessary */
	/* +1 avoids unportable behavior when buflen==0 */
	tmpbuf = realloc(buffer, buflen + 1);

	/* It would only be a very brain-dead realloc that could fail, but... */
	if (!tmpbuf)
	{
		free(buffer);
		return NULL;
	}

	*retbuflen = buflen;
	return tmpbuf;
}

&lt;/pre&gt;</description>
<category>PostgreSQL</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bpostgresql%20source%20code%202%5D%5D</link>
<pubDate>Wed, 30 Aug 2017 17:40:00 GMT</pubDate>

</item>
<item>
<title>sql developer database diff</title>
<description>&lt;ul&gt;&lt;li&gt; when using the schema/database diff tool of sql developer it's more intuitive to interpret the results if the diff is done both ways. &lt;/li&gt;&lt;li&gt; so let's say if you are comparing PROD and TEST ,open two sql developer programs then do a PROD to TEST compare on one session, and TEST to PROD on another&lt;/li&gt;&lt;li&gt; on the output the left side is the source and the right side is the destination. see example below:&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/EI5JxYn.png&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 50%; height: 50%; cursor: move;&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/lAEpmKo.png&quot; title=&quot;SHIFT-CLICK=show full size, CTRL-CLICK=restore initial size&quot; style=&quot;width: 80%; height: 80%; cursor: move;&quot;&gt;</description>
<category>SQL*Developer</category>
<link>http://karlarao.tiddlyspot.com#%5B%5Bsql%20developer%20database%20diff%5D%5D</link>
<pubDate>Tue, 29 Aug 2017 15:15:00 GMT</pubDate>

</item>
<item>
<title>..python for pl/sql developers</title>
<description>&lt;a target=&quot;_blank&quot; title=&quot;External link to https://community.oracle.com/docs/DOC-1005069&quot; href=&quot;https://community.oracle.com/docs/DOC-1005069&quot; class=&quot;externalLink&quot;&gt;https://community.oracle.com/docs/DOC-1005069&lt;/a&gt;  &amp;lt;- arup, good stuff&lt;br&gt;&lt;a target=&quot;_blank&quot; title=&quot;External link to https://blogs.oracle.com/developers/updates-to-python-php-and-c-drivers-for-oracle-database&quot; href=&quot;https://blogs.oracle.com/developers/updates-to-python-php-and-c-drivers-for-oracle-database&quot; class=&quot;externalLink&quot;&gt;https://blogs.oracle.com/developers/updates-to-python-php-and-c-drivers-for-oracle-database&lt;/a&gt;&lt;br&gt;&lt;br&gt;</description>
<category>Python</category>
<link>http://karlarao.tiddlyspot.com#%5B%5B..python%20for%20pl%2Fsql%20developers%5D%5D</link>
<pubDate>Fri, 18 Aug 2017 04:53:00 GMT</pubDate>

</item>
</channel>
</rss>